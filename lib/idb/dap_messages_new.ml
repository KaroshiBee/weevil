(* NOTE this file was autogenerated - do not modify by hand *)
open Dapper

module RequestMessage = Dap_request_message
module ResponseMessage = Dap_response_message
module EventMessage = Dap_event_message

module Data = struct
  include Dap_base

  (* supporting data modules *)
  module Message : sig
    (* DONE *)
    type t [@@deriving irmin]

    (* DONE *)
    val equal : t -> t -> bool

    (* TODO *)
    val enc : t Data_encoding.t

    (* DONE *)
    val merge : t option Irmin.Merge.t

    (* DONE *)
    val make :
      id:int ->
      format:string ->
      ?variables:Irmin.Contents.Json_value.t ->
      ?sendTelemetry:bool ->
      ?showUser:bool ->
      ?url:string ->
      ?urlLabel:string ->
      unit ->
      t

    (* DONE *)
    val id : t -> int

    val format : t -> string

    val variables : t -> Irmin.Contents.Json_value.t option

    val sendTelemetry : t -> bool option

    val showUser : t -> bool option

    val url : t -> string option

    val urlLabel : t -> string option
  end = struct
    (* DONE *)
    type t = {
      id : int;
      format : string;
      variables : Irmin.Contents.Json_value.t option;
      sendTelemetry : bool option;
      showUser : bool option;
      url : string option;
      urlLabel : string option;
    }
    [@@deriving irmin]

    (* TODO with irmin *)
    let enc =
      let open Data_encoding in
      (* Message.t *)
      conv
        (fun {id; format; variables; sendTelemetry; showUser; url; urlLabel} ->
          (id, format, variables, sendTelemetry, showUser, url, urlLabel))
        (fun (id, format, variables, sendTelemetry, showUser, url, urlLabel) ->
          {id; format; variables; sendTelemetry; showUser; url; urlLabel})
        (obj7
           (req "id" int31)
           (req "format" string)
           (opt "variables" json)
           (opt "sendTelemetry" bool)
           (opt "showUser" bool)
           (opt "url" string)
           (opt "urlLabel" string))

    (* DONE *)
    let equal = Irmin.Type.(unstage (equal t))
    (* DONE *)
    let merge = Irmin.Merge.(option (idempotent t))

    (* DONE *)
    let make ~id ~format ?variables ?sendTelemetry ?showUser ?url ?urlLabel () =
      {id; format; variables; sendTelemetry; showUser; url; urlLabel}

    (* DONE *)
    let id t = t.id

    let format t = t.format

    let variables t = t.variables

    let sendTelemetry t = t.sendTelemetry

    let showUser t = t.showUser

    let url t = t.url

    let urlLabel t = t.urlLabel
  end

  (* module ErrorResponse_body : sig *)
  (*   type t *)

  (*   val equal : t -> t -> bool *)

  (*   val enc : t Data_encoding.t *)

  (*   val make : ?error:Message.t -> unit -> t *)

  (*   val error : t -> Message.t option *)
  (* end = struct *)
  (*   type t = {error : Message.t option} [@@deriving eq] *)

  (*   let enc = *)
  (*     let open Data_encoding in *)
  (*     (\* ErrorResponse_body.t *\) *)
  (*     conv *)
  (*       (fun {error} -> error) *)
  (*       (fun error -> {error}) *)
  (*       (obj1 (opt "error" Message.enc)) *)

  (*   let make ?error () = {error} *)

  (*   let error t = t.error *)
  (* end *)

  (* module CancelArguments : sig *)
  (*   type t *)

  (*   val equal : t -> t -> bool *)

  (*   val enc : t Data_encoding.t *)

  (*   val make : ?requestId:int -> ?progressId:string -> unit -> t *)

  (*   val requestId : t -> int option *)

  (*   val progressId : t -> string option *)
  (* end = struct *)
  (*   type t = { *)
  (*     requestId : int option; *)
  (*     progressId : string option; *)
  (*   } *)
  (*   [@@deriving eq] *)

  (*   let enc = *)
  (*     let open Data_encoding in *)
  (*     (\* CancelArguments.t *\) *)
  (*     conv *)
  (*       (fun {requestId; progressId} -> (requestId, progressId)) *)
  (*       (fun (requestId, progressId) -> {requestId; progressId}) *)
  (*       (obj2 (opt "requestId" int31) (opt "progressId" string)) *)

  (*   let make ?requestId ?progressId () = {requestId; progressId} *)

  (*   let requestId t = t.requestId *)

  (*   let progressId t = t.progressId *)
  (* end *)

  (* (\* dont bother with a sig for enums, the inferred one is fine *\) *)
  (* module StoppedEvent_body_reason = struct *)
  (*   type t = *)
  (*     | Step *)
  (*     | Breakpoint *)
  (*     | Exception *)
  (*     | Pause *)
  (*     | Entry *)
  (*     | Goto *)
  (*     | Function_breakpoint *)
  (*     | Data_breakpoint *)
  (*     | Instruction_breakpoint *)
  (*     | Other of string *)
  (*   [@@deriving eq] *)

  (*   let enc = *)
  (*     let open Data_encoding in *)
  (*     conv_with_guard *)
  (*       (function *)
  (*         | Step -> "step" *)
  (*         | Breakpoint -> "breakpoint" *)
  (*         | Exception -> "exception" *)
  (*         | Pause -> "pause" *)
  (*         | Entry -> "entry" *)
  (*         | Goto -> "goto" *)
  (*         | Function_breakpoint -> "function breakpoint" *)
  (*         | Data_breakpoint -> "data breakpoint" *)
  (*         | Instruction_breakpoint -> "instruction breakpoint" *)
  (*         | Other s -> s) *)
  (*       (function *)
  (*         | "step" -> Ok Step *)
  (*         | "breakpoint" -> Ok Breakpoint *)
  (*         | "exception" -> Ok Exception *)
  (*         | "pause" -> Ok Pause *)
  (*         | "entry" -> Ok Entry *)
  (*         | "goto" -> Ok Goto *)
  (*         | "function breakpoint" -> Ok Function_breakpoint *)
  (*         | "data breakpoint" -> Ok Data_breakpoint *)
  (*         | "instruction breakpoint" -> Ok Instruction_breakpoint *)
  (*         | _ as s -> Ok (Other s)) *)
  (*       string *)
  (* end *)

  (* module StoppedEvent_body : sig *)
  (*   type t *)

  (*   val equal : t -> t -> bool *)

  (*   val enc : t Data_encoding.t *)

  (*   val make : *)
  (*     reason:StoppedEvent_body_reason.t -> *)
  (*     ?description:string -> *)
  (*     ?threadId:int -> *)
  (*     ?preserveFocusHint:bool -> *)
  (*     ?text:string -> *)
  (*     ?allThreadsStopped:bool -> *)
  (*     ?hitBreakpointIds:int list -> *)
  (*     unit -> *)
  (*     t *)

  (*   val reason : t -> StoppedEvent_body_reason.t *)

  (*   val description : t -> string option *)

  (*   val threadId : t -> int option *)

  (*   val preserveFocusHint : t -> bool option *)

  (*   val text : t -> string option *)

  (*   val allThreadsStopped : t -> bool option *)

  (*   val hitBreakpointIds : t -> int list option *)
  (* end = struct *)
  (*   type t = { *)
  (*     reason : StoppedEvent_body_reason.t; *)
  (*     description : string option; *)
  (*     threadId : int option; *)
  (*     preserveFocusHint : bool option; *)
  (*     text : string option; *)
  (*     allThreadsStopped : bool option; *)
  (*     hitBreakpointIds : int list option; *)
  (*   } *)
  (*   [@@deriving eq] *)

  (*   let enc = *)
  (*     let open Data_encoding in *)
  (*     (\* StoppedEvent_body.t *\) *)
  (*     conv *)
  (*       (fun { *)
  (*              reason; *)
  (*              description; *)
  (*              threadId; *)
  (*              preserveFocusHint; *)
  (*              text; *)
  (*              allThreadsStopped; *)
  (*              hitBreakpointIds; *)
  (*            } -> *)
  (*         ( reason, *)
  (*           description, *)
  (*           threadId, *)
  (*           preserveFocusHint, *)
  (*           text, *)
  (*           allThreadsStopped, *)
  (*           hitBreakpointIds )) *)
  (*       (fun ( reason, *)
  (*              description, *)
  (*              threadId, *)
  (*              preserveFocusHint, *)
  (*              text, *)
  (*              allThreadsStopped, *)
  (*              hitBreakpointIds ) -> *)
  (*         { *)
  (*           reason; *)
  (*           description; *)
  (*           threadId; *)
  (*           preserveFocusHint; *)
  (*           text; *)
  (*           allThreadsStopped; *)
  (*           hitBreakpointIds; *)
  (*         }) *)
  (*       (obj7 *)
  (*          (req "reason" StoppedEvent_body_reason.enc) *)
  (*          (opt "description" string) *)
  (*          (opt "threadId" int31) *)
  (*          (opt "preserveFocusHint" bool) *)
  (*          (opt "text" string) *)
  (*          (opt "allThreadsStopped" bool) *)
  (*          (opt "hitBreakpointIds" (list int31))) *)

  (*   let make ~reason ?description ?threadId ?preserveFocusHint ?text *)
  (*       ?allThreadsStopped ?hitBreakpointIds () = *)
  (*     { *)
  (*       reason; *)
  (*       description; *)
  (*       threadId; *)
  (*       preserveFocusHint; *)
  (*       text; *)
  (*       allThreadsStopped; *)
  (*       hitBreakpointIds; *)
  (*     } *)

  (*   let reason t = t.reason *)

  (*   let description t = t.description *)

  (*   let threadId t = t.threadId *)

  (*   let preserveFocusHint t = t.preserveFocusHint *)

  (*   let text t = t.text *)

  (*   let allThreadsStopped t = t.allThreadsStopped *)

  (*   let hitBreakpointIds t = t.hitBreakpointIds *)
  (* end *)


end
