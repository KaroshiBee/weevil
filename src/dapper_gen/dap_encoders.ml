(* NOTE this file was autogenerated - do not modify by hand *)

open Dap_t

module Command = struct
  type t =
    | Disassemble
    | WriteMemory
    | ReadMemory
    | ExceptionInfo
    | Completions
    | GotoTargets
    | StepInTargets
    | SetExpression
    | Evaluate
    | LoadedSources
    | Modules
    | TerminateThreads
    | Threads
    | Source
    | SetVariable
    | Variables
    | Scopes
    | StackTrace
    | Pause
    | Goto
    | RestartFrame
    | ReverseContinue
    | StepBack
    | StepOut
    | StepIn
    | Next
    | Continue
    | SetInstructionBreakpoints
    | SetDataBreakpoints
    | DataBreakpointInfo
    | SetExceptionBreakpoints
    | SetFunctionBreakpoints
    | SetBreakpoints
    | BreakpointLocations
    | Terminate
    | Disconnect
    | Restart
    | Attach
    | Launch
    | ConfigurationDone
    | Initialize
    | RunInTerminal
    | Cancel
    | Error

  let enc =
    let open Data_encoding in
    conv
      (function
        | Disassemble -> "disassemble"
        | WriteMemory -> "writeMemory"
        | ReadMemory -> "readMemory"
        | ExceptionInfo -> "exceptionInfo"
        | Completions -> "completions"
        | GotoTargets -> "gotoTargets"
        | StepInTargets -> "stepInTargets"
        | SetExpression -> "setExpression"
        | Evaluate -> "evaluate"
        | LoadedSources -> "loadedSources"
        | Modules -> "modules"
        | TerminateThreads -> "terminateThreads"
        | Threads -> "threads"
        | Source -> "source"
        | SetVariable -> "setVariable"
        | Variables -> "variables"
        | Scopes -> "scopes"
        | StackTrace -> "stackTrace"
        | Pause -> "pause"
        | Goto -> "goto"
        | RestartFrame -> "restartFrame"
        | ReverseContinue -> "reverseContinue"
        | StepBack -> "stepBack"
        | StepOut -> "stepOut"
        | StepIn -> "stepIn"
        | Next -> "next"
        | Continue -> "continue"
        | SetInstructionBreakpoints -> "setInstructionBreakpoints"
        | SetDataBreakpoints -> "setDataBreakpoints"
        | DataBreakpointInfo -> "dataBreakpointInfo"
        | SetExceptionBreakpoints -> "setExceptionBreakpoints"
        | SetFunctionBreakpoints -> "setFunctionBreakpoints"
        | SetBreakpoints -> "setBreakpoints"
        | BreakpointLocations -> "breakpointLocations"
        | Terminate -> "terminate"
        | Disconnect -> "disconnect"
        | Restart -> "restart"
        | Attach -> "attach"
        | Launch -> "launch"
        | ConfigurationDone -> "configurationDone"
        | Initialize -> "initialize"
        | RunInTerminal -> "runInTerminal"
        | Cancel -> "cancel"
        | Error -> "error")
      (function
        | "disassemble" -> Disassemble
        | "writeMemory" -> WriteMemory
        | "readMemory" -> ReadMemory
        | "exceptionInfo" -> ExceptionInfo
        | "completions" -> Completions
        | "gotoTargets" -> GotoTargets
        | "stepInTargets" -> StepInTargets
        | "setExpression" -> SetExpression
        | "evaluate" -> Evaluate
        | "loadedSources" -> LoadedSources
        | "modules" -> Modules
        | "terminateThreads" -> TerminateThreads
        | "threads" -> Threads
        | "source" -> Source
        | "setVariable" -> SetVariable
        | "variables" -> Variables
        | "scopes" -> Scopes
        | "stackTrace" -> StackTrace
        | "pause" -> Pause
        | "goto" -> Goto
        | "restartFrame" -> RestartFrame
        | "reverseContinue" -> ReverseContinue
        | "stepBack" -> StepBack
        | "stepOut" -> StepOut
        | "stepIn" -> StepIn
        | "next" -> Next
        | "continue" -> Continue
        | "setInstructionBreakpoints" -> SetInstructionBreakpoints
        | "setDataBreakpoints" -> SetDataBreakpoints
        | "dataBreakpointInfo" -> DataBreakpointInfo
        | "setExceptionBreakpoints" -> SetExceptionBreakpoints
        | "setFunctionBreakpoints" -> SetFunctionBreakpoints
        | "setBreakpoints" -> SetBreakpoints
        | "breakpointLocations" -> BreakpointLocations
        | "terminate" -> Terminate
        | "disconnect" -> Disconnect
        | "restart" -> Restart
        | "attach" -> Attach
        | "launch" -> Launch
        | "configurationDone" -> ConfigurationDone
        | "initialize" -> Initialize
        | "runInTerminal" -> RunInTerminal
        | "cancel" -> Cancel
        | "error" -> Error
        | _ -> failwith "Command")
      string
end

module Event = struct
  type t =
    | Memory
    | Invalidated
    | ProgressEnd
    | ProgressUpdate
    | ProgressStart
    | Capabilities
    | Process
    | LoadedSource
    | Module_
    | Breakpoint
    | Output
    | Thread
    | Terminated
    | Exited
    | Continued
    | Stopped
    | Initialized

  let enc =
    let open Data_encoding in
    conv
      (function
        | Memory -> "memory"
        | Invalidated -> "invalidated"
        | ProgressEnd -> "progressEnd"
        | ProgressUpdate -> "progressUpdate"
        | ProgressStart -> "progressStart"
        | Capabilities -> "capabilities"
        | Process -> "process"
        | LoadedSource -> "loadedSource"
        | Module_ -> "module"
        | Breakpoint -> "breakpoint"
        | Output -> "output"
        | Thread -> "thread"
        | Terminated -> "terminated"
        | Exited -> "exited"
        | Continued -> "continued"
        | Stopped -> "stopped"
        | Initialized -> "initialized")
      (function
        | "memory" -> Memory
        | "invalidated" -> Invalidated
        | "progressEnd" -> ProgressEnd
        | "progressUpdate" -> ProgressUpdate
        | "progressStart" -> ProgressStart
        | "capabilities" -> Capabilities
        | "process" -> Process
        | "loadedSource" -> LoadedSource
        | "module" -> Module_
        | "breakpoint" -> Breakpoint
        | "output" -> Output
        | "thread" -> Thread
        | "terminated" -> Terminated
        | "exited" -> Exited
        | "continued" -> Continued
        | "stopped" -> Stopped
        | "initialized" -> Initialized
        | _ -> failwith "Event")
      string
end

module Message = struct
  type t = {
    id : int;
    format : string;
    variables : Data_encoding.json option;
    sendTelemetry : bool option;
    showUser : bool option;
    url : string option;
    urlLabel : string option;
  }

  let enc =
    let open Data_encoding in
    (* Message.t *)
    conv
      (fun {id; format; variables; sendTelemetry; showUser; url; urlLabel} ->
        (id, format, variables, sendTelemetry, showUser, url, urlLabel))
      (fun (id, format, variables, sendTelemetry, showUser, url, urlLabel) ->
        {id; format; variables; sendTelemetry; showUser; url; urlLabel})
      (obj7
         (req "id" int31)
         (req "format" string)
         (opt "variables" json)
         (opt "sendTelemetry" bool)
         (opt "showUser" bool)
         (opt "url" string)
         (opt "urlLabel" string))

  let make ~id ~format ?variables ?sendTelemetry ?showUser ?url ?urlLabel () =
    {id; format; variables; sendTelemetry; showUser; url; urlLabel}
end

module ErrorResponse_body = struct
  type t = {error : Message.t option}

  let enc =
    let open Data_encoding in
    (* ErrorResponse_body.t *)
    conv
      (fun {error} -> error)
      (fun error -> {error})
      (obj1 (opt "error" Message.enc))

  let make ?error () = {error}
end

module ErrorResponseMessage = MakeResponse (struct
  type t = Command.t

  let value = Command.Error

  let enc = Command.enc
end)

module CancelArguments = struct
  type t = {requestId : int option; progressId : string option}

  let enc =
    let open Data_encoding in
    (* CancelArguments.t *)
    conv
      (fun {requestId; progressId} -> (requestId, progressId))
      (fun (requestId, progressId) -> {requestId; progressId})
      (obj2 (opt "requestId" int31) (opt "progressId" string))

  let make ?requestId ?progressId () = {requestId; progressId}
end

module CancelRequestMessage = MakeRequest_optionalArgs (struct
  type t = Command.t

  let value = Command.Cancel

  let enc = Command.enc
end)

module CancelResponseMessage = MakeResponse_optionalBody (struct
  type t = Command.t

  let value = Command.Cancel

  let enc = Command.enc
end)

module InitializedEventMessage = MakeEvent_optionalBody (struct
  type t = Event.t

  let value = Event.Initialized

  let enc = Event.enc
end)

module StoppedEvent_body_reason = struct
  type t =
    | Step
    | Breakpoint
    | Exception
    | Pause
    | Entry
    | Goto
    | Function_breakpoint
    | Data_breakpoint
    | Instruction_breakpoint
    | Other of string

  let enc =
    let open Data_encoding in
    conv
      (function
        | Step -> "step"
        | Breakpoint -> "breakpoint"
        | Exception -> "exception"
        | Pause -> "pause"
        | Entry -> "entry"
        | Goto -> "goto"
        | Function_breakpoint -> "function breakpoint"
        | Data_breakpoint -> "data breakpoint"
        | Instruction_breakpoint -> "instruction breakpoint"
        | Other s -> s)
      (function
        | "step" -> Step
        | "breakpoint" -> Breakpoint
        | "exception" -> Exception
        | "pause" -> Pause
        | "entry" -> Entry
        | "goto" -> Goto
        | "function breakpoint" -> Function_breakpoint
        | "data breakpoint" -> Data_breakpoint
        | "instruction breakpoint" -> Instruction_breakpoint
        | _ as s -> Other s)
      string
end

module StoppedEvent_body = struct
  type t = {
    reason : StoppedEvent_body_reason.t;
    description : string option;
    threadId : int option;
    preserveFocusHint : bool option;
    text : string option;
    allThreadsStopped : bool option;
    hitBreakpointIds : int list option;
  }

  let enc =
    let open Data_encoding in
    (* StoppedEvent_body.t *)
    conv
      (fun {
             reason;
             description;
             threadId;
             preserveFocusHint;
             text;
             allThreadsStopped;
             hitBreakpointIds;
           } ->
        ( reason,
          description,
          threadId,
          preserveFocusHint,
          text,
          allThreadsStopped,
          hitBreakpointIds ))
      (fun ( reason,
             description,
             threadId,
             preserveFocusHint,
             text,
             allThreadsStopped,
             hitBreakpointIds ) ->
        {
          reason;
          description;
          threadId;
          preserveFocusHint;
          text;
          allThreadsStopped;
          hitBreakpointIds;
        })
      (obj7
         (req "reason" StoppedEvent_body_reason.enc)
         (opt "description" string)
         (opt "threadId" int31)
         (opt "preserveFocusHint" bool)
         (opt "text" string)
         (opt "allThreadsStopped" bool)
         (opt "hitBreakpointIds" (list int31)))

  let make ~reason ?description ?threadId ?preserveFocusHint ?text
      ?allThreadsStopped ?hitBreakpointIds () =
    {
      reason;
      description;
      threadId;
      preserveFocusHint;
      text;
      allThreadsStopped;
      hitBreakpointIds;
    }
end

module StoppedEventMessage = MakeEvent (struct
  type t = Event.t

  let value = Event.Stopped

  let enc = Event.enc
end)

module ContinuedEvent_body = struct
  type t = {threadId : int; allThreadsContinued : bool option}

  let enc =
    let open Data_encoding in
    (* ContinuedEvent_body.t *)
    conv
      (fun {threadId; allThreadsContinued} -> (threadId, allThreadsContinued))
      (fun (threadId, allThreadsContinued) -> {threadId; allThreadsContinued})
      (obj2 (req "threadId" int31) (opt "allThreadsContinued" bool))

  let make ~threadId ?allThreadsContinued () = {threadId; allThreadsContinued}
end

module ContinuedEventMessage = MakeEvent (struct
  type t = Event.t

  let value = Event.Continued

  let enc = Event.enc
end)

module ExitedEvent_body = struct
  type t = {exitCode : int}

  let enc =
    let open Data_encoding in
    (* ExitedEvent_body.t *)
    conv
      (fun {exitCode} -> exitCode)
      (fun exitCode -> {exitCode})
      (obj1 (req "exitCode" int31))

  let make ~exitCode () = {exitCode}
end

module ExitedEventMessage = MakeEvent (struct
  type t = Event.t

  let value = Event.Exited

  let enc = Event.enc
end)

module TerminatedEvent_body = struct
  type t = {restart : Data_encoding.json option}

  let enc =
    let open Data_encoding in
    (* TerminatedEvent_body.t *)
    conv
      (fun {restart} -> restart)
      (fun restart -> {restart})
      (obj1 (opt "restart" json))

  let make ?restart () = {restart}
end

module TerminatedEventMessage = MakeEvent_optionalBody (struct
  type t = Event.t

  let value = Event.Terminated

  let enc = Event.enc
end)

module ThreadEvent_body_reason = struct
  type t = Started | Exited | Other of string

  let enc =
    let open Data_encoding in
    conv
      (function Started -> "started" | Exited -> "exited" | Other s -> s)
      (function "started" -> Started | "exited" -> Exited | _ as s -> Other s)
      string
end

module ThreadEvent_body = struct
  type t = {reason : ThreadEvent_body_reason.t; threadId : int}

  let enc =
    let open Data_encoding in
    (* ThreadEvent_body.t *)
    conv
      (fun {reason; threadId} -> (reason, threadId))
      (fun (reason, threadId) -> {reason; threadId})
      (obj2 (req "reason" ThreadEvent_body_reason.enc) (req "threadId" int31))

  let make ~reason ~threadId () = {reason; threadId}
end

module ThreadEventMessage = MakeEvent (struct
  type t = Event.t

  let value = Event.Thread

  let enc = Event.enc
end)

module OutputEvent_body_category = struct
  type t = Console | Important | Stdout | Stderr | Telemetry | Other of string

  let enc =
    let open Data_encoding in
    conv
      (function
        | Console -> "console"
        | Important -> "important"
        | Stdout -> "stdout"
        | Stderr -> "stderr"
        | Telemetry -> "telemetry"
        | Other s -> s)
      (function
        | "console" -> Console
        | "important" -> Important
        | "stdout" -> Stdout
        | "stderr" -> Stderr
        | "telemetry" -> Telemetry
        | _ as s -> Other s)
      string
end

module OutputEvent_body_group = struct
  type t = Start | StartCollapsed | End

  let enc =
    let open Data_encoding in
    conv
      (function
        | Start -> "start" | StartCollapsed -> "startCollapsed" | End -> "end")
      (function
        | "start" -> Start
        | "startCollapsed" -> StartCollapsed
        | "end" -> End
        | _ -> failwith "OutputEvent_body_group")
      string
end

module Source_presentationHint = struct
  type t = Normal | Emphasize | Deemphasize

  let enc =
    let open Data_encoding in
    conv
      (function
        | Normal -> "normal"
        | Emphasize -> "emphasize"
        | Deemphasize -> "deemphasize")
      (function
        | "normal" -> Normal
        | "emphasize" -> Emphasize
        | "deemphasize" -> Deemphasize
        | _ -> failwith "Source_presentationHint")
      string
end

module ChecksumAlgorithm = struct
  type t = MD5 | SHA1 | SHA256 | Timestamp

  let enc =
    let open Data_encoding in
    conv
      (function
        | MD5 -> "MD5"
        | SHA1 -> "SHA1"
        | SHA256 -> "SHA256"
        | Timestamp -> "timestamp")
      (function
        | "MD5" -> MD5
        | "SHA1" -> SHA1
        | "SHA256" -> SHA256
        | "timestamp" -> Timestamp
        | _ -> failwith "ChecksumAlgorithm")
      string
end

module Checksum = struct
  type t = {algorithm : ChecksumAlgorithm.t; checksum : string}

  let enc =
    let open Data_encoding in
    (* Checksum.t *)
    conv
      (fun {algorithm; checksum} -> (algorithm, checksum))
      (fun (algorithm, checksum) -> {algorithm; checksum})
      (obj2 (req "algorithm" ChecksumAlgorithm.enc) (req "checksum" string))

  let make ~algorithm ~checksum () = {algorithm; checksum}
end

module Source = struct
  type t = {
    name : string option;
    path : string option;
    sourceReference : int option;
    presentationHint : Source_presentationHint.t option;
    origin : string option;
    sources : t list option;
    adapterData : Data_encoding.json option;
    checksums : Checksum.t list option;
  }

  let enc =
    let open Data_encoding in
    mu "Source.t" (fun e ->
        conv
          (fun {
                 name;
                 path;
                 sourceReference;
                 presentationHint;
                 origin;
                 sources;
                 adapterData;
                 checksums;
               } ->
            ( name,
              path,
              sourceReference,
              presentationHint,
              origin,
              sources,
              adapterData,
              checksums ))
          (fun ( name,
                 path,
                 sourceReference,
                 presentationHint,
                 origin,
                 sources,
                 adapterData,
                 checksums ) ->
            {
              name;
              path;
              sourceReference;
              presentationHint;
              origin;
              sources;
              adapterData;
              checksums;
            })
          (obj8
             (opt "name" string)
             (opt "path" string)
             (opt "sourceReference" int31)
             (opt "presentationHint" Source_presentationHint.enc)
             (opt "origin" string)
             (opt "sources" (list e))
             (opt "adapterData" json)
             (opt "checksums" (list Checksum.enc))))

  let make ?name ?path ?sourceReference ?presentationHint ?origin ?sources
      ?adapterData ?checksums () =
    {
      name;
      path;
      sourceReference;
      presentationHint;
      origin;
      sources;
      adapterData;
      checksums;
    }
end

module OutputEvent_body = struct
  type t = {
    category : OutputEvent_body_category.t option;
    output : string;
    group : OutputEvent_body_group.t option;
    variablesReference : int option;
    source : Source.t option;
    line : int option;
    column : int option;
    data : Data_encoding.json option;
  }

  let enc =
    let open Data_encoding in
    (* OutputEvent_body.t *)
    conv
      (fun {
             category;
             output;
             group;
             variablesReference;
             source;
             line;
             column;
             data;
           } ->
        (category, output, group, variablesReference, source, line, column, data))
      (fun ( category,
             output,
             group,
             variablesReference,
             source,
             line,
             column,
             data ) ->
        {
          category;
          output;
          group;
          variablesReference;
          source;
          line;
          column;
          data;
        })
      (obj8
         (opt "category" OutputEvent_body_category.enc)
         (req "output" string)
         (opt "group" OutputEvent_body_group.enc)
         (opt "variablesReference" int31)
         (opt "source" Source.enc)
         (opt "line" int31)
         (opt "column" int31)
         (opt "data" json))

  let make ?category ~output ?group ?variablesReference ?source ?line ?column
      ?data () =
    {category; output; group; variablesReference; source; line; column; data}
end

module OutputEventMessage = MakeEvent (struct
  type t = Event.t

  let value = Event.Output

  let enc = Event.enc
end)

module BreakpointEvent_body_reason = struct
  type t = Changed | New | Removed | Other of string

  let enc =
    let open Data_encoding in
    conv
      (function
        | Changed -> "changed"
        | New -> "new"
        | Removed -> "removed"
        | Other s -> s)
      (function
        | "changed" -> Changed
        | "new" -> New
        | "removed" -> Removed
        | _ as s -> Other s)
      string
end

module Breakpoint = struct
  type t = {
    id : int option;
    verified : bool;
    message : string option;
    source : Source.t option;
    line : int option;
    column : int option;
    endLine : int option;
    endColumn : int option;
    instructionReference : string option;
    offset : int option;
  }

  let enc =
    let open Data_encoding in
    (* Breakpoint.t *)
    conv
      (fun {
             id;
             verified;
             message;
             source;
             line;
             column;
             endLine;
             endColumn;
             instructionReference;
             offset;
           } ->
        ( id,
          verified,
          message,
          source,
          line,
          column,
          endLine,
          endColumn,
          instructionReference,
          offset ))
      (fun ( id,
             verified,
             message,
             source,
             line,
             column,
             endLine,
             endColumn,
             instructionReference,
             offset ) ->
        {
          id;
          verified;
          message;
          source;
          line;
          column;
          endLine;
          endColumn;
          instructionReference;
          offset;
        })
      (obj10
         (opt "id" int31)
         (req "verified" bool)
         (opt "message" string)
         (opt "source" Source.enc)
         (opt "line" int31)
         (opt "column" int31)
         (opt "endLine" int31)
         (opt "endColumn" int31)
         (opt "instructionReference" string)
         (opt "offset" int31))

  let make ?id ~verified ?message ?source ?line ?column ?endLine ?endColumn
      ?instructionReference ?offset () =
    {
      id;
      verified;
      message;
      source;
      line;
      column;
      endLine;
      endColumn;
      instructionReference;
      offset;
    }
end

module BreakpointEvent_body = struct
  type t = {reason : BreakpointEvent_body_reason.t; breakpoint : Breakpoint.t}

  let enc =
    let open Data_encoding in
    (* BreakpointEvent_body.t *)
    conv
      (fun {reason; breakpoint} -> (reason, breakpoint))
      (fun (reason, breakpoint) -> {reason; breakpoint})
      (obj2
         (req "reason" BreakpointEvent_body_reason.enc)
         (req "breakpoint" Breakpoint.enc))

  let make ~reason ~breakpoint () = {reason; breakpoint}
end

module BreakpointEventMessage = MakeEvent (struct
  type t = Event.t

  let value = Event.Breakpoint

  let enc = Event.enc
end)

module ModuleEvent_body_reason = struct
  type t = New | Changed | Removed

  let enc =
    let open Data_encoding in
    conv
      (function New -> "new" | Changed -> "changed" | Removed -> "removed")
      (function
        | "new" -> New
        | "changed" -> Changed
        | "removed" -> Removed
        | _ -> failwith "ModuleEvent_body_reason")
      string
end

module Module_ = struct
  type t = {
    id : IntString.t;
    name : string;
    path : string option;
    isOptimized : bool option;
    isUserCode : bool option;
    version : string option;
    symbolStatus : string option;
    symbolFilePath : string option;
    dateTimeStamp : string option;
    addressRange : string option;
  }

  let enc =
    let open Data_encoding in
    (* Module_.t *)
    conv
      (fun {
             id;
             name;
             path;
             isOptimized;
             isUserCode;
             version;
             symbolStatus;
             symbolFilePath;
             dateTimeStamp;
             addressRange;
           } ->
        ( id,
          name,
          path,
          isOptimized,
          isUserCode,
          version,
          symbolStatus,
          symbolFilePath,
          dateTimeStamp,
          addressRange ))
      (fun ( id,
             name,
             path,
             isOptimized,
             isUserCode,
             version,
             symbolStatus,
             symbolFilePath,
             dateTimeStamp,
             addressRange ) ->
        {
          id;
          name;
          path;
          isOptimized;
          isUserCode;
          version;
          symbolStatus;
          symbolFilePath;
          dateTimeStamp;
          addressRange;
        })
      (obj10
         (req "id" IntString.enc)
         (req "name" string)
         (opt "path" string)
         (opt "isOptimized" bool)
         (opt "isUserCode" bool)
         (opt "version" string)
         (opt "symbolStatus" string)
         (opt "symbolFilePath" string)
         (opt "dateTimeStamp" string)
         (opt "addressRange" string))

  let make ~id ~name ?path ?isOptimized ?isUserCode ?version ?symbolStatus
      ?symbolFilePath ?dateTimeStamp ?addressRange () =
    {
      id;
      name;
      path;
      isOptimized;
      isUserCode;
      version;
      symbolStatus;
      symbolFilePath;
      dateTimeStamp;
      addressRange;
    }
end

module ModuleEvent_body = struct
  type t = {reason : ModuleEvent_body_reason.t; module_ : Module_.t}

  let enc =
    let open Data_encoding in
    (* ModuleEvent_body.t *)
    conv
      (fun {reason; module_} -> (reason, module_))
      (fun (reason, module_) -> {reason; module_})
      (obj2
         (req "reason" ModuleEvent_body_reason.enc)
         (req "module" Module_.enc))

  let make ~reason ~module_ () = {reason; module_}
end

module ModuleEventMessage = MakeEvent (struct
  type t = Event.t

  let value = Event.Module_

  let enc = Event.enc
end)

module LoadedSourceEvent_body_reason = struct
  type t = New | Changed | Removed

  let enc =
    let open Data_encoding in
    conv
      (function New -> "new" | Changed -> "changed" | Removed -> "removed")
      (function
        | "new" -> New
        | "changed" -> Changed
        | "removed" -> Removed
        | _ -> failwith "LoadedSourceEvent_body_reason")
      string
end

module LoadedSourceEvent_body = struct
  type t = {reason : LoadedSourceEvent_body_reason.t; source : Source.t}

  let enc =
    let open Data_encoding in
    (* LoadedSourceEvent_body.t *)
    conv
      (fun {reason; source} -> (reason, source))
      (fun (reason, source) -> {reason; source})
      (obj2
         (req "reason" LoadedSourceEvent_body_reason.enc)
         (req "source" Source.enc))

  let make ~reason ~source () = {reason; source}
end

module LoadedSourceEventMessage = MakeEvent (struct
  type t = Event.t

  let value = Event.LoadedSource

  let enc = Event.enc
end)

module ProcessEvent_body_startMethod = struct
  type t = Launch | Attach | AttachForSuspendedLaunch

  let enc =
    let open Data_encoding in
    conv
      (function
        | Launch -> "launch"
        | Attach -> "attach"
        | AttachForSuspendedLaunch -> "attachForSuspendedLaunch")
      (function
        | "launch" -> Launch
        | "attach" -> Attach
        | "attachForSuspendedLaunch" -> AttachForSuspendedLaunch
        | _ -> failwith "ProcessEvent_body_startMethod")
      string
end

module ProcessEvent_body = struct
  type t = {
    name : string;
    systemProcessId : int option;
    isLocalProcess : bool option;
    startMethod : ProcessEvent_body_startMethod.t option;
    pointerSize : int option;
  }

  let enc =
    let open Data_encoding in
    (* ProcessEvent_body.t *)
    conv
      (fun {name; systemProcessId; isLocalProcess; startMethod; pointerSize} ->
        (name, systemProcessId, isLocalProcess, startMethod, pointerSize))
      (fun (name, systemProcessId, isLocalProcess, startMethod, pointerSize) ->
        {name; systemProcessId; isLocalProcess; startMethod; pointerSize})
      (obj5
         (req "name" string)
         (opt "systemProcessId" int31)
         (opt "isLocalProcess" bool)
         (opt "startMethod" ProcessEvent_body_startMethod.enc)
         (opt "pointerSize" int31))

  let make ~name ?systemProcessId ?isLocalProcess ?startMethod ?pointerSize () =
    {name; systemProcessId; isLocalProcess; startMethod; pointerSize}
end

module ProcessEventMessage = MakeEvent (struct
  type t = Event.t

  let value = Event.Process

  let enc = Event.enc
end)

module ExceptionBreakpointsFilter = struct
  type t = {
    filter : string;
    label : string;
    description : string option;
    default : bool option;
    supportsCondition : bool option;
    conditionDescription : string option;
  }

  let enc =
    let open Data_encoding in
    (* ExceptionBreakpointsFilter.t *)
    conv
      (fun {
             filter;
             label;
             description;
             default;
             supportsCondition;
             conditionDescription;
           } ->
        ( filter,
          label,
          description,
          default,
          supportsCondition,
          conditionDescription ))
      (fun ( filter,
             label,
             description,
             default,
             supportsCondition,
             conditionDescription ) ->
        {
          filter;
          label;
          description;
          default;
          supportsCondition;
          conditionDescription;
        })
      (obj6
         (req "filter" string)
         (req "label" string)
         (opt "description" string)
         (opt "default" bool)
         (opt "supportsCondition" bool)
         (opt "conditionDescription" string))

  let make ~filter ~label ?description ?default ?supportsCondition
      ?conditionDescription () =
    {
      filter;
      label;
      description;
      default;
      supportsCondition;
      conditionDescription;
    }
end

module ColumnDescriptor_type_ = struct
  type t = String | Number | Boolean | UnixTimestampUTC

  let enc =
    let open Data_encoding in
    conv
      (function
        | String -> "string"
        | Number -> "number"
        | Boolean -> "boolean"
        | UnixTimestampUTC -> "unixTimestampUTC")
      (function
        | "string" -> String
        | "number" -> Number
        | "boolean" -> Boolean
        | "unixTimestampUTC" -> UnixTimestampUTC
        | _ -> failwith "ColumnDescriptor_type_")
      string
end

module ColumnDescriptor = struct
  type t = {
    attributeName : string;
    label : string;
    format : string option;
    type_ : ColumnDescriptor_type_.t option;
    width : int option;
  }

  let enc =
    let open Data_encoding in
    (* ColumnDescriptor.t *)
    conv
      (fun {attributeName; label; format; type_; width} ->
        (attributeName, label, format, type_, width))
      (fun (attributeName, label, format, type_, width) ->
        {attributeName; label; format; type_; width})
      (obj5
         (req "attributeName" string)
         (req "label" string)
         (opt "format" string)
         (opt "type" ColumnDescriptor_type_.enc)
         (opt "width" int31))

  let make ~attributeName ~label ?format ?type_ ?width () =
    {attributeName; label; format; type_; width}
end

module Capabilities = struct
  module Capabilities_0 = struct
    type t = {
      supportsConfigurationDoneRequest : bool option;
      supportsFunctionBreakpoints : bool option;
      supportsConditionalBreakpoints : bool option;
      supportsHitConditionalBreakpoints : bool option;
      supportsEvaluateForHovers : bool option;
      exceptionBreakpointFilters : ExceptionBreakpointsFilter.t list option;
      supportsStepBack : bool option;
      supportsSetVariable : bool option;
      supportsRestartFrame : bool option;
      supportsGotoTargetsRequest : bool option;
    }

    let enc =
      let open Data_encoding in
      (* Capabilities_0.t *)
      conv
        (fun {
               supportsConfigurationDoneRequest;
               supportsFunctionBreakpoints;
               supportsConditionalBreakpoints;
               supportsHitConditionalBreakpoints;
               supportsEvaluateForHovers;
               exceptionBreakpointFilters;
               supportsStepBack;
               supportsSetVariable;
               supportsRestartFrame;
               supportsGotoTargetsRequest;
             } ->
          ( supportsConfigurationDoneRequest,
            supportsFunctionBreakpoints,
            supportsConditionalBreakpoints,
            supportsHitConditionalBreakpoints,
            supportsEvaluateForHovers,
            exceptionBreakpointFilters,
            supportsStepBack,
            supportsSetVariable,
            supportsRestartFrame,
            supportsGotoTargetsRequest ))
        (fun ( supportsConfigurationDoneRequest,
               supportsFunctionBreakpoints,
               supportsConditionalBreakpoints,
               supportsHitConditionalBreakpoints,
               supportsEvaluateForHovers,
               exceptionBreakpointFilters,
               supportsStepBack,
               supportsSetVariable,
               supportsRestartFrame,
               supportsGotoTargetsRequest ) ->
          {
            supportsConfigurationDoneRequest;
            supportsFunctionBreakpoints;
            supportsConditionalBreakpoints;
            supportsHitConditionalBreakpoints;
            supportsEvaluateForHovers;
            exceptionBreakpointFilters;
            supportsStepBack;
            supportsSetVariable;
            supportsRestartFrame;
            supportsGotoTargetsRequest;
          })
        (obj10
           (opt "supportsConfigurationDoneRequest" bool)
           (opt "supportsFunctionBreakpoints" bool)
           (opt "supportsConditionalBreakpoints" bool)
           (opt "supportsHitConditionalBreakpoints" bool)
           (opt "supportsEvaluateForHovers" bool)
           (opt
              "exceptionBreakpointFilters"
              (list ExceptionBreakpointsFilter.enc))
           (opt "supportsStepBack" bool)
           (opt "supportsSetVariable" bool)
           (opt "supportsRestartFrame" bool)
           (opt "supportsGotoTargetsRequest" bool))

    let make ?supportsConfigurationDoneRequest ?supportsFunctionBreakpoints
        ?supportsConditionalBreakpoints ?supportsHitConditionalBreakpoints
        ?supportsEvaluateForHovers ?exceptionBreakpointFilters ?supportsStepBack
        ?supportsSetVariable ?supportsRestartFrame ?supportsGotoTargetsRequest
        () =
      {
        supportsConfigurationDoneRequest;
        supportsFunctionBreakpoints;
        supportsConditionalBreakpoints;
        supportsHitConditionalBreakpoints;
        supportsEvaluateForHovers;
        exceptionBreakpointFilters;
        supportsStepBack;
        supportsSetVariable;
        supportsRestartFrame;
        supportsGotoTargetsRequest;
      }
  end

  module Capabilities_10 = struct
    type t = {
      supportsStepInTargetsRequest : bool option;
      supportsCompletionsRequest : bool option;
      completionTriggerCharacters : string list option;
      supportsModulesRequest : bool option;
      additionalModuleColumns : ColumnDescriptor.t list option;
      supportedChecksumAlgorithms : ChecksumAlgorithm.t list option;
      supportsRestartRequest : bool option;
      supportsExceptionOptions : bool option;
      supportsValueFormattingOptions : bool option;
      supportsExceptionInfoRequest : bool option;
    }

    let enc =
      let open Data_encoding in
      (* Capabilities_10.t *)
      conv
        (fun {
               supportsStepInTargetsRequest;
               supportsCompletionsRequest;
               completionTriggerCharacters;
               supportsModulesRequest;
               additionalModuleColumns;
               supportedChecksumAlgorithms;
               supportsRestartRequest;
               supportsExceptionOptions;
               supportsValueFormattingOptions;
               supportsExceptionInfoRequest;
             } ->
          ( supportsStepInTargetsRequest,
            supportsCompletionsRequest,
            completionTriggerCharacters,
            supportsModulesRequest,
            additionalModuleColumns,
            supportedChecksumAlgorithms,
            supportsRestartRequest,
            supportsExceptionOptions,
            supportsValueFormattingOptions,
            supportsExceptionInfoRequest ))
        (fun ( supportsStepInTargetsRequest,
               supportsCompletionsRequest,
               completionTriggerCharacters,
               supportsModulesRequest,
               additionalModuleColumns,
               supportedChecksumAlgorithms,
               supportsRestartRequest,
               supportsExceptionOptions,
               supportsValueFormattingOptions,
               supportsExceptionInfoRequest ) ->
          {
            supportsStepInTargetsRequest;
            supportsCompletionsRequest;
            completionTriggerCharacters;
            supportsModulesRequest;
            additionalModuleColumns;
            supportedChecksumAlgorithms;
            supportsRestartRequest;
            supportsExceptionOptions;
            supportsValueFormattingOptions;
            supportsExceptionInfoRequest;
          })
        (obj10
           (opt "supportsStepInTargetsRequest" bool)
           (opt "supportsCompletionsRequest" bool)
           (opt "completionTriggerCharacters" (list string))
           (opt "supportsModulesRequest" bool)
           (opt "additionalModuleColumns" (list ColumnDescriptor.enc))
           (opt "supportedChecksumAlgorithms" (list ChecksumAlgorithm.enc))
           (opt "supportsRestartRequest" bool)
           (opt "supportsExceptionOptions" bool)
           (opt "supportsValueFormattingOptions" bool)
           (opt "supportsExceptionInfoRequest" bool))

    let make ?supportsStepInTargetsRequest ?supportsCompletionsRequest
        ?completionTriggerCharacters ?supportsModulesRequest
        ?additionalModuleColumns ?supportedChecksumAlgorithms
        ?supportsRestartRequest ?supportsExceptionOptions
        ?supportsValueFormattingOptions ?supportsExceptionInfoRequest () =
      {
        supportsStepInTargetsRequest;
        supportsCompletionsRequest;
        completionTriggerCharacters;
        supportsModulesRequest;
        additionalModuleColumns;
        supportedChecksumAlgorithms;
        supportsRestartRequest;
        supportsExceptionOptions;
        supportsValueFormattingOptions;
        supportsExceptionInfoRequest;
      }
  end

  module Capabilities_20 = struct
    type t = {
      supportTerminateDebuggee : bool option;
      supportSuspendDebuggee : bool option;
      supportsDelayedStackTraceLoading : bool option;
      supportsLoadedSourcesRequest : bool option;
      supportsLogPoints : bool option;
      supportsTerminateThreadsRequest : bool option;
      supportsSetExpression : bool option;
      supportsTerminateRequest : bool option;
      supportsDataBreakpoints : bool option;
      supportsReadMemoryRequest : bool option;
    }

    let enc =
      let open Data_encoding in
      (* Capabilities_20.t *)
      conv
        (fun {
               supportTerminateDebuggee;
               supportSuspendDebuggee;
               supportsDelayedStackTraceLoading;
               supportsLoadedSourcesRequest;
               supportsLogPoints;
               supportsTerminateThreadsRequest;
               supportsSetExpression;
               supportsTerminateRequest;
               supportsDataBreakpoints;
               supportsReadMemoryRequest;
             } ->
          ( supportTerminateDebuggee,
            supportSuspendDebuggee,
            supportsDelayedStackTraceLoading,
            supportsLoadedSourcesRequest,
            supportsLogPoints,
            supportsTerminateThreadsRequest,
            supportsSetExpression,
            supportsTerminateRequest,
            supportsDataBreakpoints,
            supportsReadMemoryRequest ))
        (fun ( supportTerminateDebuggee,
               supportSuspendDebuggee,
               supportsDelayedStackTraceLoading,
               supportsLoadedSourcesRequest,
               supportsLogPoints,
               supportsTerminateThreadsRequest,
               supportsSetExpression,
               supportsTerminateRequest,
               supportsDataBreakpoints,
               supportsReadMemoryRequest ) ->
          {
            supportTerminateDebuggee;
            supportSuspendDebuggee;
            supportsDelayedStackTraceLoading;
            supportsLoadedSourcesRequest;
            supportsLogPoints;
            supportsTerminateThreadsRequest;
            supportsSetExpression;
            supportsTerminateRequest;
            supportsDataBreakpoints;
            supportsReadMemoryRequest;
          })
        (obj10
           (opt "supportTerminateDebuggee" bool)
           (opt "supportSuspendDebuggee" bool)
           (opt "supportsDelayedStackTraceLoading" bool)
           (opt "supportsLoadedSourcesRequest" bool)
           (opt "supportsLogPoints" bool)
           (opt "supportsTerminateThreadsRequest" bool)
           (opt "supportsSetExpression" bool)
           (opt "supportsTerminateRequest" bool)
           (opt "supportsDataBreakpoints" bool)
           (opt "supportsReadMemoryRequest" bool))

    let make ?supportTerminateDebuggee ?supportSuspendDebuggee
        ?supportsDelayedStackTraceLoading ?supportsLoadedSourcesRequest
        ?supportsLogPoints ?supportsTerminateThreadsRequest
        ?supportsSetExpression ?supportsTerminateRequest
        ?supportsDataBreakpoints ?supportsReadMemoryRequest () =
      {
        supportTerminateDebuggee;
        supportSuspendDebuggee;
        supportsDelayedStackTraceLoading;
        supportsLoadedSourcesRequest;
        supportsLogPoints;
        supportsTerminateThreadsRequest;
        supportsSetExpression;
        supportsTerminateRequest;
        supportsDataBreakpoints;
        supportsReadMemoryRequest;
      }
  end

  module Capabilities_30 = struct
    type t = {
      supportsWriteMemoryRequest : bool option;
      supportsDisassembleRequest : bool option;
      supportsCancelRequest : bool option;
      supportsBreakpointLocationsRequest : bool option;
      supportsClipboardContext : bool option;
      supportsSteppingGranularity : bool option;
      supportsInstructionBreakpoints : bool option;
      supportsExceptionFilterOptions : bool option;
      supportsSingleThreadExecutionRequests : bool option;
    }

    let enc =
      let open Data_encoding in
      (* Capabilities_30.t *)
      conv
        (fun {
               supportsWriteMemoryRequest;
               supportsDisassembleRequest;
               supportsCancelRequest;
               supportsBreakpointLocationsRequest;
               supportsClipboardContext;
               supportsSteppingGranularity;
               supportsInstructionBreakpoints;
               supportsExceptionFilterOptions;
               supportsSingleThreadExecutionRequests;
             } ->
          ( supportsWriteMemoryRequest,
            supportsDisassembleRequest,
            supportsCancelRequest,
            supportsBreakpointLocationsRequest,
            supportsClipboardContext,
            supportsSteppingGranularity,
            supportsInstructionBreakpoints,
            supportsExceptionFilterOptions,
            supportsSingleThreadExecutionRequests ))
        (fun ( supportsWriteMemoryRequest,
               supportsDisassembleRequest,
               supportsCancelRequest,
               supportsBreakpointLocationsRequest,
               supportsClipboardContext,
               supportsSteppingGranularity,
               supportsInstructionBreakpoints,
               supportsExceptionFilterOptions,
               supportsSingleThreadExecutionRequests ) ->
          {
            supportsWriteMemoryRequest;
            supportsDisassembleRequest;
            supportsCancelRequest;
            supportsBreakpointLocationsRequest;
            supportsClipboardContext;
            supportsSteppingGranularity;
            supportsInstructionBreakpoints;
            supportsExceptionFilterOptions;
            supportsSingleThreadExecutionRequests;
          })
        (obj9
           (opt "supportsWriteMemoryRequest" bool)
           (opt "supportsDisassembleRequest" bool)
           (opt "supportsCancelRequest" bool)
           (opt "supportsBreakpointLocationsRequest" bool)
           (opt "supportsClipboardContext" bool)
           (opt "supportsSteppingGranularity" bool)
           (opt "supportsInstructionBreakpoints" bool)
           (opt "supportsExceptionFilterOptions" bool)
           (opt "supportsSingleThreadExecutionRequests" bool))

    let make ?supportsWriteMemoryRequest ?supportsDisassembleRequest
        ?supportsCancelRequest ?supportsBreakpointLocationsRequest
        ?supportsClipboardContext ?supportsSteppingGranularity
        ?supportsInstructionBreakpoints ?supportsExceptionFilterOptions
        ?supportsSingleThreadExecutionRequests () =
      {
        supportsWriteMemoryRequest;
        supportsDisassembleRequest;
        supportsCancelRequest;
        supportsBreakpointLocationsRequest;
        supportsClipboardContext;
        supportsSteppingGranularity;
        supportsInstructionBreakpoints;
        supportsExceptionFilterOptions;
        supportsSingleThreadExecutionRequests;
      }
  end

  type t =
    Capabilities_0.t
    * (Capabilities_10.t * (Capabilities_20.t * Capabilities_30.t))

  let enc =
    let open Data_encoding in
    merge_objs Capabilities_0.enc
    @@ merge_objs Capabilities_10.enc
    @@ merge_objs Capabilities_20.enc Capabilities_30.enc

  let make ?supportsConfigurationDoneRequest ?supportsFunctionBreakpoints
      ?supportsConditionalBreakpoints ?supportsHitConditionalBreakpoints
      ?supportsEvaluateForHovers ?exceptionBreakpointFilters ?supportsStepBack
      ?supportsSetVariable ?supportsRestartFrame ?supportsGotoTargetsRequest
      ?supportsStepInTargetsRequest ?supportsCompletionsRequest
      ?completionTriggerCharacters ?supportsModulesRequest
      ?additionalModuleColumns ?supportedChecksumAlgorithms
      ?supportsRestartRequest ?supportsExceptionOptions
      ?supportsValueFormattingOptions ?supportsExceptionInfoRequest
      ?supportTerminateDebuggee ?supportSuspendDebuggee
      ?supportsDelayedStackTraceLoading ?supportsLoadedSourcesRequest
      ?supportsLogPoints ?supportsTerminateThreadsRequest ?supportsSetExpression
      ?supportsTerminateRequest ?supportsDataBreakpoints
      ?supportsReadMemoryRequest ?supportsWriteMemoryRequest
      ?supportsDisassembleRequest ?supportsCancelRequest
      ?supportsBreakpointLocationsRequest ?supportsClipboardContext
      ?supportsSteppingGranularity ?supportsInstructionBreakpoints
      ?supportsExceptionFilterOptions ?supportsSingleThreadExecutionRequests ()
      =
    let t0 =
      Capabilities_0.make
        ?supportsConfigurationDoneRequest
        ?supportsFunctionBreakpoints
        ?supportsConditionalBreakpoints
        ?supportsHitConditionalBreakpoints
        ?supportsEvaluateForHovers
        ?exceptionBreakpointFilters
        ?supportsStepBack
        ?supportsSetVariable
        ?supportsRestartFrame
        ?supportsGotoTargetsRequest
        ()
    in

    let t1 =
      Capabilities_10.make
        ?supportsStepInTargetsRequest
        ?supportsCompletionsRequest
        ?completionTriggerCharacters
        ?supportsModulesRequest
        ?additionalModuleColumns
        ?supportedChecksumAlgorithms
        ?supportsRestartRequest
        ?supportsExceptionOptions
        ?supportsValueFormattingOptions
        ?supportsExceptionInfoRequest
        ()
    in

    let t2 =
      Capabilities_20.make
        ?supportTerminateDebuggee
        ?supportSuspendDebuggee
        ?supportsDelayedStackTraceLoading
        ?supportsLoadedSourcesRequest
        ?supportsLogPoints
        ?supportsTerminateThreadsRequest
        ?supportsSetExpression
        ?supportsTerminateRequest
        ?supportsDataBreakpoints
        ?supportsReadMemoryRequest
        ()
    in

    let t3 =
      Capabilities_30.make
        ?supportsWriteMemoryRequest
        ?supportsDisassembleRequest
        ?supportsCancelRequest
        ?supportsBreakpointLocationsRequest
        ?supportsClipboardContext
        ?supportsSteppingGranularity
        ?supportsInstructionBreakpoints
        ?supportsExceptionFilterOptions
        ?supportsSingleThreadExecutionRequests
        ()
    in

    (t0, (t1, (t2, t3)))
end

module CapabilitiesEvent_body = struct
  type t = {capabilities : Capabilities.t}

  let enc =
    let open Data_encoding in
    (* CapabilitiesEvent_body.t *)
    conv
      (fun {capabilities} -> capabilities)
      (fun capabilities -> {capabilities})
      (obj1 (req "capabilities" Capabilities.enc))

  let make ~capabilities () = {capabilities}
end

module CapabilitiesEventMessage = MakeEvent (struct
  type t = Event.t

  let value = Event.Capabilities

  let enc = Event.enc
end)

module ProgressStartEvent_body = struct
  type t = {
    progressId : string;
    title : string;
    requestId : int option;
    cancellable : bool option;
    message : string option;
    percentage : int option;
  }

  let enc =
    let open Data_encoding in
    (* ProgressStartEvent_body.t *)
    conv
      (fun {progressId; title; requestId; cancellable; message; percentage} ->
        (progressId, title, requestId, cancellable, message, percentage))
      (fun (progressId, title, requestId, cancellable, message, percentage) ->
        {progressId; title; requestId; cancellable; message; percentage})
      (obj6
         (req "progressId" string)
         (req "title" string)
         (opt "requestId" int31)
         (opt "cancellable" bool)
         (opt "message" string)
         (opt "percentage" int31))

  let make ~progressId ~title ?requestId ?cancellable ?message ?percentage () =
    {progressId; title; requestId; cancellable; message; percentage}
end

module ProgressStartEventMessage = MakeEvent (struct
  type t = Event.t

  let value = Event.ProgressStart

  let enc = Event.enc
end)

module ProgressUpdateEvent_body = struct
  type t = {
    progressId : string;
    message : string option;
    percentage : int option;
  }

  let enc =
    let open Data_encoding in
    (* ProgressUpdateEvent_body.t *)
    conv
      (fun {progressId; message; percentage} ->
        (progressId, message, percentage))
      (fun (progressId, message, percentage) ->
        {progressId; message; percentage})
      (obj3
         (req "progressId" string)
         (opt "message" string)
         (opt "percentage" int31))

  let make ~progressId ?message ?percentage () =
    {progressId; message; percentage}
end

module ProgressUpdateEventMessage = MakeEvent (struct
  type t = Event.t

  let value = Event.ProgressUpdate

  let enc = Event.enc
end)

module ProgressEndEvent_body = struct
  type t = {progressId : string; message : string option}

  let enc =
    let open Data_encoding in
    (* ProgressEndEvent_body.t *)
    conv
      (fun {progressId; message} -> (progressId, message))
      (fun (progressId, message) -> {progressId; message})
      (obj2 (req "progressId" string) (opt "message" string))

  let make ~progressId ?message () = {progressId; message}
end

module ProgressEndEventMessage = MakeEvent (struct
  type t = Event.t

  let value = Event.ProgressEnd

  let enc = Event.enc
end)

module InvalidatedAreas = struct
  type t = All | Stacks | Threads | Variables | Other of string

  let enc =
    let open Data_encoding in
    conv
      (function
        | All -> "all"
        | Stacks -> "stacks"
        | Threads -> "threads"
        | Variables -> "variables"
        | Other s -> s)
      (function
        | "all" -> All
        | "stacks" -> Stacks
        | "threads" -> Threads
        | "variables" -> Variables
        | _ as s -> Other s)
      string
end

module InvalidatedEvent_body = struct
  type t = {
    areas : InvalidatedAreas.t list option;
    threadId : int option;
    stackFrameId : int option;
  }

  let enc =
    let open Data_encoding in
    (* InvalidatedEvent_body.t *)
    conv
      (fun {areas; threadId; stackFrameId} -> (areas, threadId, stackFrameId))
      (fun (areas, threadId, stackFrameId) -> {areas; threadId; stackFrameId})
      (obj3
         (opt "areas" (list InvalidatedAreas.enc))
         (opt "threadId" int31)
         (opt "stackFrameId" int31))

  let make ?areas ?threadId ?stackFrameId () = {areas; threadId; stackFrameId}
end

module InvalidatedEventMessage = MakeEvent (struct
  type t = Event.t

  let value = Event.Invalidated

  let enc = Event.enc
end)

module MemoryEvent_body = struct
  type t = {memoryReference : string; offset : int; count : int}

  let enc =
    let open Data_encoding in
    (* MemoryEvent_body.t *)
    conv
      (fun {memoryReference; offset; count} -> (memoryReference, offset, count))
      (fun (memoryReference, offset, count) -> {memoryReference; offset; count})
      (obj3
         (req "memoryReference" string)
         (req "offset" int31)
         (req "count" int31))

  let make ~memoryReference ~offset ~count () = {memoryReference; offset; count}
end

module MemoryEventMessage = MakeEvent (struct
  type t = Event.t

  let value = Event.Memory

  let enc = Event.enc
end)

module RunInTerminalRequestArguments_kind = struct
  type t = Integrated | External

  let enc =
    let open Data_encoding in
    conv
      (function Integrated -> "integrated" | External -> "external")
      (function
        | "integrated" -> Integrated
        | "external" -> External
        | _ -> failwith "RunInTerminalRequestArguments_kind")
      string
end

module RunInTerminalRequestArguments = struct
  type t = {
    kind : RunInTerminalRequestArguments_kind.t option;
    title : string option;
    cwd : string;
    args : string list;
    env : Data_encoding.json option;
  }

  let enc =
    let open Data_encoding in
    (* RunInTerminalRequestArguments.t *)
    conv
      (fun {kind; title; cwd; args; env} -> (kind, title, cwd, args, env))
      (fun (kind, title, cwd, args, env) -> {kind; title; cwd; args; env})
      (obj5
         (opt "kind" RunInTerminalRequestArguments_kind.enc)
         (opt "title" string)
         (req "cwd" string)
         (req "args" (list string))
         (opt "env" json))

  let make ?kind ?title ~cwd ~args ?env () = {kind; title; cwd; args; env}
end

module RunInTerminalRequestMessage = MakeRequest (struct
  type t = Command.t

  let value = Command.RunInTerminal

  let enc = Command.enc
end)

module RunInTerminalResponse_body = struct
  type t = {processId : int option; shellProcessId : int option}

  let enc =
    let open Data_encoding in
    (* RunInTerminalResponse_body.t *)
    conv
      (fun {processId; shellProcessId} -> (processId, shellProcessId))
      (fun (processId, shellProcessId) -> {processId; shellProcessId})
      (obj2 (opt "processId" int31) (opt "shellProcessId" int31))

  let make ?processId ?shellProcessId () = {processId; shellProcessId}
end

module RunInTerminalResponseMessage = MakeResponse (struct
  type t = Command.t

  let value = Command.RunInTerminal

  let enc = Command.enc
end)

module InitializeRequestArguments_pathFormat = struct
  type t = Path | Uri | Other of string

  let enc =
    let open Data_encoding in
    conv
      (function Path -> "path" | Uri -> "uri" | Other s -> s)
      (function "path" -> Path | "uri" -> Uri | _ as s -> Other s)
      string
end

module InitializeRequestArguments = struct
  module InitializeRequestArguments_0 = struct
    type t = {
      clientID : string option;
      clientName : string option;
      adapterID : string;
      locale : string option;
      linesStartAt1 : bool option;
      columnsStartAt1 : bool option;
      pathFormat : InitializeRequestArguments_pathFormat.t option;
      supportsVariableType : bool option;
      supportsVariablePaging : bool option;
      supportsRunInTerminalRequest : bool option;
    }

    let enc =
      let open Data_encoding in
      (* InitializeRequestArguments_0.t *)
      conv
        (fun {
               clientID;
               clientName;
               adapterID;
               locale;
               linesStartAt1;
               columnsStartAt1;
               pathFormat;
               supportsVariableType;
               supportsVariablePaging;
               supportsRunInTerminalRequest;
             } ->
          ( clientID,
            clientName,
            adapterID,
            locale,
            linesStartAt1,
            columnsStartAt1,
            pathFormat,
            supportsVariableType,
            supportsVariablePaging,
            supportsRunInTerminalRequest ))
        (fun ( clientID,
               clientName,
               adapterID,
               locale,
               linesStartAt1,
               columnsStartAt1,
               pathFormat,
               supportsVariableType,
               supportsVariablePaging,
               supportsRunInTerminalRequest ) ->
          {
            clientID;
            clientName;
            adapterID;
            locale;
            linesStartAt1;
            columnsStartAt1;
            pathFormat;
            supportsVariableType;
            supportsVariablePaging;
            supportsRunInTerminalRequest;
          })
        (obj10
           (opt "clientID" string)
           (opt "clientName" string)
           (req "adapterID" string)
           (opt "locale" string)
           (opt "linesStartAt1" bool)
           (opt "columnsStartAt1" bool)
           (opt "pathFormat" InitializeRequestArguments_pathFormat.enc)
           (opt "supportsVariableType" bool)
           (opt "supportsVariablePaging" bool)
           (opt "supportsRunInTerminalRequest" bool))

    let make ?clientID ?clientName ~adapterID ?locale ?linesStartAt1
        ?columnsStartAt1 ?pathFormat ?supportsVariableType
        ?supportsVariablePaging ?supportsRunInTerminalRequest () =
      {
        clientID;
        clientName;
        adapterID;
        locale;
        linesStartAt1;
        columnsStartAt1;
        pathFormat;
        supportsVariableType;
        supportsVariablePaging;
        supportsRunInTerminalRequest;
      }
  end

  module InitializeRequestArguments_10 = struct
    type t = {
      supportsMemoryReferences : bool option;
      supportsProgressReporting : bool option;
      supportsInvalidatedEvent : bool option;
      supportsMemoryEvent : bool option;
    }

    let enc =
      let open Data_encoding in
      (* InitializeRequestArguments_10.t *)
      conv
        (fun {
               supportsMemoryReferences;
               supportsProgressReporting;
               supportsInvalidatedEvent;
               supportsMemoryEvent;
             } ->
          ( supportsMemoryReferences,
            supportsProgressReporting,
            supportsInvalidatedEvent,
            supportsMemoryEvent ))
        (fun ( supportsMemoryReferences,
               supportsProgressReporting,
               supportsInvalidatedEvent,
               supportsMemoryEvent ) ->
          {
            supportsMemoryReferences;
            supportsProgressReporting;
            supportsInvalidatedEvent;
            supportsMemoryEvent;
          })
        (obj4
           (opt "supportsMemoryReferences" bool)
           (opt "supportsProgressReporting" bool)
           (opt "supportsInvalidatedEvent" bool)
           (opt "supportsMemoryEvent" bool))

    let make ?supportsMemoryReferences ?supportsProgressReporting
        ?supportsInvalidatedEvent ?supportsMemoryEvent () =
      {
        supportsMemoryReferences;
        supportsProgressReporting;
        supportsInvalidatedEvent;
        supportsMemoryEvent;
      }
  end

  type t = InitializeRequestArguments_0.t * InitializeRequestArguments_10.t

  let enc =
    let open Data_encoding in
    merge_objs
      InitializeRequestArguments_0.enc
      InitializeRequestArguments_10.enc

  let make ?clientID ?clientName ~adapterID ?locale ?linesStartAt1
      ?columnsStartAt1 ?pathFormat ?supportsVariableType ?supportsVariablePaging
      ?supportsRunInTerminalRequest ?supportsMemoryReferences
      ?supportsProgressReporting ?supportsInvalidatedEvent ?supportsMemoryEvent
      () =
    let t0 =
      InitializeRequestArguments_0.make
        ?clientID
        ?clientName
        ~adapterID
        ?locale
        ?linesStartAt1
        ?columnsStartAt1
        ?pathFormat
        ?supportsVariableType
        ?supportsVariablePaging
        ?supportsRunInTerminalRequest
        ()
    in

    let t1 =
      InitializeRequestArguments_10.make
        ?supportsMemoryReferences
        ?supportsProgressReporting
        ?supportsInvalidatedEvent
        ?supportsMemoryEvent
        ()
    in

    (t0, t1)
end

module InitializeRequestMessage = MakeRequest (struct
  type t = Command.t

  let value = Command.Initialize

  let enc = Command.enc
end)

module InitializeResponseMessage = MakeResponse_optionalBody (struct
  type t = Command.t

  let value = Command.Initialize

  let enc = Command.enc
end)

module ConfigurationDoneArguments = struct
  type t = unit

  let enc = Data_encoding.empty

  let make () = ()
end

module ConfigurationDoneRequestMessage = MakeRequest_optionalArgs (struct
  type t = Command.t

  let value = Command.ConfigurationDone

  let enc = Command.enc
end)

module ConfigurationDoneResponseMessage = MakeResponse_optionalBody (struct
  type t = Command.t

  let value = Command.ConfigurationDone

  let enc = Command.enc
end)

module LaunchRequestMessage = MakeRequest (struct
  type t = Command.t

  let value = Command.Launch

  let enc = Command.enc
end)

module LaunchResponseMessage = MakeResponse_optionalBody (struct
  type t = Command.t

  let value = Command.Launch

  let enc = Command.enc
end)

module AttachRequestMessage = MakeRequest (struct
  type t = Command.t

  let value = Command.Attach

  let enc = Command.enc
end)

module AttachResponseMessage = MakeResponse_optionalBody (struct
  type t = Command.t

  let value = Command.Attach

  let enc = Command.enc
end)

module RestartRequestMessage = MakeRequest_optionalArgs (struct
  type t = Command.t

  let value = Command.Restart

  let enc = Command.enc
end)

module RestartResponseMessage = MakeResponse_optionalBody (struct
  type t = Command.t

  let value = Command.Restart

  let enc = Command.enc
end)

module DisconnectArguments = struct
  type t = {
    restart : bool option;
    terminateDebuggee : bool option;
    suspendDebuggee : bool option;
  }

  let enc =
    let open Data_encoding in
    (* DisconnectArguments.t *)
    conv
      (fun {restart; terminateDebuggee; suspendDebuggee} ->
        (restart, terminateDebuggee, suspendDebuggee))
      (fun (restart, terminateDebuggee, suspendDebuggee) ->
        {restart; terminateDebuggee; suspendDebuggee})
      (obj3
         (opt "restart" bool)
         (opt "terminateDebuggee" bool)
         (opt "suspendDebuggee" bool))

  let make ?restart ?terminateDebuggee ?suspendDebuggee () =
    {restart; terminateDebuggee; suspendDebuggee}
end

module DisconnectRequestMessage = MakeRequest_optionalArgs (struct
  type t = Command.t

  let value = Command.Disconnect

  let enc = Command.enc
end)

module DisconnectResponseMessage = MakeResponse_optionalBody (struct
  type t = Command.t

  let value = Command.Disconnect

  let enc = Command.enc
end)

module TerminateArguments = struct
  type t = {restart : bool option}

  let enc =
    let open Data_encoding in
    (* TerminateArguments.t *)
    conv
      (fun {restart} -> restart)
      (fun restart -> {restart})
      (obj1 (opt "restart" bool))

  let make ?restart () = {restart}
end

module TerminateRequestMessage = MakeRequest_optionalArgs (struct
  type t = Command.t

  let value = Command.Terminate

  let enc = Command.enc
end)

module TerminateResponseMessage = MakeResponse_optionalBody (struct
  type t = Command.t

  let value = Command.Terminate

  let enc = Command.enc
end)

module BreakpointLocationsArguments = struct
  type t = {
    source : Source.t;
    line : int;
    column : int option;
    endLine : int option;
    endColumn : int option;
  }

  let enc =
    let open Data_encoding in
    (* BreakpointLocationsArguments.t *)
    conv
      (fun {source; line; column; endLine; endColumn} ->
        (source, line, column, endLine, endColumn))
      (fun (source, line, column, endLine, endColumn) ->
        {source; line; column; endLine; endColumn})
      (obj5
         (req "source" Source.enc)
         (req "line" int31)
         (opt "column" int31)
         (opt "endLine" int31)
         (opt "endColumn" int31))

  let make ~source ~line ?column ?endLine ?endColumn () =
    {source; line; column; endLine; endColumn}
end

module BreakpointLocationsRequestMessage = MakeRequest_optionalArgs (struct
  type t = Command.t

  let value = Command.BreakpointLocations

  let enc = Command.enc
end)

module BreakpointLocation = struct
  type t = {
    line : int;
    column : int option;
    endLine : int option;
    endColumn : int option;
  }

  let enc =
    let open Data_encoding in
    (* BreakpointLocation.t *)
    conv
      (fun {line; column; endLine; endColumn} ->
        (line, column, endLine, endColumn))
      (fun (line, column, endLine, endColumn) ->
        {line; column; endLine; endColumn})
      (obj4
         (req "line" int31)
         (opt "column" int31)
         (opt "endLine" int31)
         (opt "endColumn" int31))

  let make ~line ?column ?endLine ?endColumn () =
    {line; column; endLine; endColumn}
end

module BreakpointLocationsResponse_body = struct
  type t = {breakpoints : BreakpointLocation.t list}

  let enc =
    let open Data_encoding in
    (* BreakpointLocationsResponse_body.t *)
    conv
      (fun {breakpoints} -> breakpoints)
      (fun breakpoints -> {breakpoints})
      (obj1 (req "breakpoints" (list BreakpointLocation.enc)))

  let make ~breakpoints () = {breakpoints}
end

module BreakpointLocationsResponseMessage = MakeResponse (struct
  type t = Command.t

  let value = Command.BreakpointLocations

  let enc = Command.enc
end)

module SourceBreakpoint = struct
  type t = {
    line : int;
    column : int option;
    condition : string option;
    hitCondition : string option;
    logMessage : string option;
  }

  let enc =
    let open Data_encoding in
    (* SourceBreakpoint.t *)
    conv
      (fun {line; column; condition; hitCondition; logMessage} ->
        (line, column, condition, hitCondition, logMessage))
      (fun (line, column, condition, hitCondition, logMessage) ->
        {line; column; condition; hitCondition; logMessage})
      (obj5
         (req "line" int31)
         (opt "column" int31)
         (opt "condition" string)
         (opt "hitCondition" string)
         (opt "logMessage" string))

  let make ~line ?column ?condition ?hitCondition ?logMessage () =
    {line; column; condition; hitCondition; logMessage}
end

module SetBreakpointsArguments = struct
  type t = {
    source : Source.t;
    breakpoints : SourceBreakpoint.t list option;
    lines : int list option;
    sourceModified : bool option;
  }

  let enc =
    let open Data_encoding in
    (* SetBreakpointsArguments.t *)
    conv
      (fun {source; breakpoints; lines; sourceModified} ->
        (source, breakpoints, lines, sourceModified))
      (fun (source, breakpoints, lines, sourceModified) ->
        {source; breakpoints; lines; sourceModified})
      (obj4
         (req "source" Source.enc)
         (opt "breakpoints" (list SourceBreakpoint.enc))
         (opt "lines" (list int31))
         (opt "sourceModified" bool))

  let make ~source ?breakpoints ?lines ?sourceModified () =
    {source; breakpoints; lines; sourceModified}
end

module SetBreakpointsRequestMessage = MakeRequest (struct
  type t = Command.t

  let value = Command.SetBreakpoints

  let enc = Command.enc
end)

module SetBreakpointsResponse_body = struct
  type t = {breakpoints : Breakpoint.t list}

  let enc =
    let open Data_encoding in
    (* SetBreakpointsResponse_body.t *)
    conv
      (fun {breakpoints} -> breakpoints)
      (fun breakpoints -> {breakpoints})
      (obj1 (req "breakpoints" (list Breakpoint.enc)))

  let make ~breakpoints () = {breakpoints}
end

module SetBreakpointsResponseMessage = MakeResponse (struct
  type t = Command.t

  let value = Command.SetBreakpoints

  let enc = Command.enc
end)

module FunctionBreakpoint = struct
  type t = {
    name : string;
    condition : string option;
    hitCondition : string option;
  }

  let enc =
    let open Data_encoding in
    (* FunctionBreakpoint.t *)
    conv
      (fun {name; condition; hitCondition} -> (name, condition, hitCondition))
      (fun (name, condition, hitCondition) -> {name; condition; hitCondition})
      (obj3
         (req "name" string)
         (opt "condition" string)
         (opt "hitCondition" string))

  let make ~name ?condition ?hitCondition () = {name; condition; hitCondition}
end

module SetFunctionBreakpointsArguments = struct
  type t = {breakpoints : FunctionBreakpoint.t list}

  let enc =
    let open Data_encoding in
    (* SetFunctionBreakpointsArguments.t *)
    conv
      (fun {breakpoints} -> breakpoints)
      (fun breakpoints -> {breakpoints})
      (obj1 (req "breakpoints" (list FunctionBreakpoint.enc)))

  let make ~breakpoints () = {breakpoints}
end

module SetFunctionBreakpointsRequestMessage = MakeRequest (struct
  type t = Command.t

  let value = Command.SetFunctionBreakpoints

  let enc = Command.enc
end)

module SetFunctionBreakpointsResponse_body = struct
  type t = {breakpoints : Breakpoint.t list}

  let enc =
    let open Data_encoding in
    (* SetFunctionBreakpointsResponse_body.t *)
    conv
      (fun {breakpoints} -> breakpoints)
      (fun breakpoints -> {breakpoints})
      (obj1 (req "breakpoints" (list Breakpoint.enc)))

  let make ~breakpoints () = {breakpoints}
end

module SetFunctionBreakpointsResponseMessage = MakeResponse (struct
  type t = Command.t

  let value = Command.SetFunctionBreakpoints

  let enc = Command.enc
end)

module ExceptionFilterOptions = struct
  type t = {filterId : string; condition : string option}

  let enc =
    let open Data_encoding in
    (* ExceptionFilterOptions.t *)
    conv
      (fun {filterId; condition} -> (filterId, condition))
      (fun (filterId, condition) -> {filterId; condition})
      (obj2 (req "filterId" string) (opt "condition" string))

  let make ~filterId ?condition () = {filterId; condition}
end

module ExceptionPathSegment = struct
  type t = {negate : bool option; names : string list}

  let enc =
    let open Data_encoding in
    (* ExceptionPathSegment.t *)
    conv
      (fun {negate; names} -> (negate, names))
      (fun (negate, names) -> {negate; names})
      (obj2 (opt "negate" bool) (req "names" (list string)))

  let make ?negate ~names () = {negate; names}
end

module ExceptionBreakMode = struct
  type t = Never | Always | Unhandled | UserUnhandled

  let enc =
    let open Data_encoding in
    conv
      (function
        | Never -> "never"
        | Always -> "always"
        | Unhandled -> "unhandled"
        | UserUnhandled -> "userUnhandled")
      (function
        | "never" -> Never
        | "always" -> Always
        | "unhandled" -> Unhandled
        | "userUnhandled" -> UserUnhandled
        | _ -> failwith "ExceptionBreakMode")
      string
end

module ExceptionOptions = struct
  type t = {
    path : ExceptionPathSegment.t list option;
    breakMode : ExceptionBreakMode.t;
  }

  let enc =
    let open Data_encoding in
    (* ExceptionOptions.t *)
    conv
      (fun {path; breakMode} -> (path, breakMode))
      (fun (path, breakMode) -> {path; breakMode})
      (obj2
         (opt "path" (list ExceptionPathSegment.enc))
         (req "breakMode" ExceptionBreakMode.enc))

  let make ?path ~breakMode () = {path; breakMode}
end

module SetExceptionBreakpointsArguments = struct
  type t = {
    filters : string list;
    filterOptions : ExceptionFilterOptions.t list option;
    exceptionOptions : ExceptionOptions.t list option;
  }

  let enc =
    let open Data_encoding in
    (* SetExceptionBreakpointsArguments.t *)
    conv
      (fun {filters; filterOptions; exceptionOptions} ->
        (filters, filterOptions, exceptionOptions))
      (fun (filters, filterOptions, exceptionOptions) ->
        {filters; filterOptions; exceptionOptions})
      (obj3
         (req "filters" (list string))
         (opt "filterOptions" (list ExceptionFilterOptions.enc))
         (opt "exceptionOptions" (list ExceptionOptions.enc)))

  let make ~filters ?filterOptions ?exceptionOptions () =
    {filters; filterOptions; exceptionOptions}
end

module SetExceptionBreakpointsRequestMessage = MakeRequest (struct
  type t = Command.t

  let value = Command.SetExceptionBreakpoints

  let enc = Command.enc
end)

module SetExceptionBreakpointsResponse_body = struct
  type t = {breakpoints : Breakpoint.t list option}

  let enc =
    let open Data_encoding in
    (* SetExceptionBreakpointsResponse_body.t *)
    conv
      (fun {breakpoints} -> breakpoints)
      (fun breakpoints -> {breakpoints})
      (obj1 (opt "breakpoints" (list Breakpoint.enc)))

  let make ?breakpoints () = {breakpoints}
end

module SetExceptionBreakpointsResponseMessage =
MakeResponse_optionalBody (struct
  type t = Command.t

  let value = Command.SetExceptionBreakpoints

  let enc = Command.enc
end)

module DataBreakpointInfoArguments = struct
  type t = {variablesReference : int option; name : string}

  let enc =
    let open Data_encoding in
    (* DataBreakpointInfoArguments.t *)
    conv
      (fun {variablesReference; name} -> (variablesReference, name))
      (fun (variablesReference, name) -> {variablesReference; name})
      (obj2 (opt "variablesReference" int31) (req "name" string))

  let make ?variablesReference ~name () = {variablesReference; name}
end

module DataBreakpointInfoRequestMessage = MakeRequest (struct
  type t = Command.t

  let value = Command.DataBreakpointInfo

  let enc = Command.enc
end)

module DataBreakpointAccessType = struct
  type t = Read | Write | ReadWrite

  let enc =
    let open Data_encoding in
    conv
      (function Read -> "read" | Write -> "write" | ReadWrite -> "readWrite")
      (function
        | "read" -> Read
        | "write" -> Write
        | "readWrite" -> ReadWrite
        | _ -> failwith "DataBreakpointAccessType")
      string
end

module DataBreakpointInfoResponse_body = struct
  type t = {
    dataId : string option;
    description : string;
    accessTypes : DataBreakpointAccessType.t list option;
    canPersist : bool option;
  }

  let enc =
    let open Data_encoding in
    (* DataBreakpointInfoResponse_body.t *)
    conv
      (fun {dataId; description; accessTypes; canPersist} ->
        (dataId, description, accessTypes, canPersist))
      (fun (dataId, description, accessTypes, canPersist) ->
        {dataId; description; accessTypes; canPersist})
      (obj4
         (req "dataId" (option string))
         (req "description" string)
         (opt "accessTypes" (list DataBreakpointAccessType.enc))
         (opt "canPersist" bool))

  let make ~dataId ~description ?accessTypes ?canPersist () =
    {dataId; description; accessTypes; canPersist}
end

module DataBreakpointInfoResponseMessage = MakeResponse (struct
  type t = Command.t

  let value = Command.DataBreakpointInfo

  let enc = Command.enc
end)

module DataBreakpoint = struct
  type t = {
    dataId : string;
    accessType : DataBreakpointAccessType.t option;
    condition : string option;
    hitCondition : string option;
  }

  let enc =
    let open Data_encoding in
    (* DataBreakpoint.t *)
    conv
      (fun {dataId; accessType; condition; hitCondition} ->
        (dataId, accessType, condition, hitCondition))
      (fun (dataId, accessType, condition, hitCondition) ->
        {dataId; accessType; condition; hitCondition})
      (obj4
         (req "dataId" string)
         (opt "accessType" DataBreakpointAccessType.enc)
         (opt "condition" string)
         (opt "hitCondition" string))

  let make ~dataId ?accessType ?condition ?hitCondition () =
    {dataId; accessType; condition; hitCondition}
end

module SetDataBreakpointsArguments = struct
  type t = {breakpoints : DataBreakpoint.t list}

  let enc =
    let open Data_encoding in
    (* SetDataBreakpointsArguments.t *)
    conv
      (fun {breakpoints} -> breakpoints)
      (fun breakpoints -> {breakpoints})
      (obj1 (req "breakpoints" (list DataBreakpoint.enc)))

  let make ~breakpoints () = {breakpoints}
end

module SetDataBreakpointsRequestMessage = MakeRequest (struct
  type t = Command.t

  let value = Command.SetDataBreakpoints

  let enc = Command.enc
end)

module SetDataBreakpointsResponse_body = struct
  type t = {breakpoints : Breakpoint.t list}

  let enc =
    let open Data_encoding in
    (* SetDataBreakpointsResponse_body.t *)
    conv
      (fun {breakpoints} -> breakpoints)
      (fun breakpoints -> {breakpoints})
      (obj1 (req "breakpoints" (list Breakpoint.enc)))

  let make ~breakpoints () = {breakpoints}
end

module SetDataBreakpointsResponseMessage = MakeResponse (struct
  type t = Command.t

  let value = Command.SetDataBreakpoints

  let enc = Command.enc
end)

module InstructionBreakpoint = struct
  type t = {
    instructionReference : string;
    offset : int option;
    condition : string option;
    hitCondition : string option;
  }

  let enc =
    let open Data_encoding in
    (* InstructionBreakpoint.t *)
    conv
      (fun {instructionReference; offset; condition; hitCondition} ->
        (instructionReference, offset, condition, hitCondition))
      (fun (instructionReference, offset, condition, hitCondition) ->
        {instructionReference; offset; condition; hitCondition})
      (obj4
         (req "instructionReference" string)
         (opt "offset" int31)
         (opt "condition" string)
         (opt "hitCondition" string))

  let make ~instructionReference ?offset ?condition ?hitCondition () =
    {instructionReference; offset; condition; hitCondition}
end

module SetInstructionBreakpointsArguments = struct
  type t = {breakpoints : InstructionBreakpoint.t list}

  let enc =
    let open Data_encoding in
    (* SetInstructionBreakpointsArguments.t *)
    conv
      (fun {breakpoints} -> breakpoints)
      (fun breakpoints -> {breakpoints})
      (obj1 (req "breakpoints" (list InstructionBreakpoint.enc)))

  let make ~breakpoints () = {breakpoints}
end

module SetInstructionBreakpointsRequestMessage = MakeRequest (struct
  type t = Command.t

  let value = Command.SetInstructionBreakpoints

  let enc = Command.enc
end)

module SetInstructionBreakpointsResponse_body = struct
  type t = {breakpoints : Breakpoint.t list}

  let enc =
    let open Data_encoding in
    (* SetInstructionBreakpointsResponse_body.t *)
    conv
      (fun {breakpoints} -> breakpoints)
      (fun breakpoints -> {breakpoints})
      (obj1 (req "breakpoints" (list Breakpoint.enc)))

  let make ~breakpoints () = {breakpoints}
end

module SetInstructionBreakpointsResponseMessage = MakeResponse (struct
  type t = Command.t

  let value = Command.SetInstructionBreakpoints

  let enc = Command.enc
end)

module ContinueArguments = struct
  type t = {threadId : int; singleThread : bool option}

  let enc =
    let open Data_encoding in
    (* ContinueArguments.t *)
    conv
      (fun {threadId; singleThread} -> (threadId, singleThread))
      (fun (threadId, singleThread) -> {threadId; singleThread})
      (obj2 (req "threadId" int31) (opt "singleThread" bool))

  let make ~threadId ?singleThread () = {threadId; singleThread}
end

module ContinueRequestMessage = MakeRequest (struct
  type t = Command.t

  let value = Command.Continue

  let enc = Command.enc
end)

module ContinueResponse_body = struct
  type t = {allThreadsContinued : bool option}

  let enc =
    let open Data_encoding in
    (* ContinueResponse_body.t *)
    conv
      (fun {allThreadsContinued} -> allThreadsContinued)
      (fun allThreadsContinued -> {allThreadsContinued})
      (obj1 (opt "allThreadsContinued" bool))

  let make ?allThreadsContinued () = {allThreadsContinued}
end

module ContinueResponseMessage = MakeResponse (struct
  type t = Command.t

  let value = Command.Continue

  let enc = Command.enc
end)

module SteppingGranularity = struct
  type t = Statement | Line | Instruction

  let enc =
    let open Data_encoding in
    conv
      (function
        | Statement -> "statement"
        | Line -> "line"
        | Instruction -> "instruction")
      (function
        | "statement" -> Statement
        | "line" -> Line
        | "instruction" -> Instruction
        | _ -> failwith "SteppingGranularity")
      string
end

module NextArguments = struct
  type t = {
    threadId : int;
    singleThread : bool option;
    granularity : SteppingGranularity.t option;
  }

  let enc =
    let open Data_encoding in
    (* NextArguments.t *)
    conv
      (fun {threadId; singleThread; granularity} ->
        (threadId, singleThread, granularity))
      (fun (threadId, singleThread, granularity) ->
        {threadId; singleThread; granularity})
      (obj3
         (req "threadId" int31)
         (opt "singleThread" bool)
         (opt "granularity" SteppingGranularity.enc))

  let make ~threadId ?singleThread ?granularity () =
    {threadId; singleThread; granularity}
end

module NextRequestMessage = MakeRequest (struct
  type t = Command.t

  let value = Command.Next

  let enc = Command.enc
end)

module NextResponseMessage = MakeResponse_optionalBody (struct
  type t = Command.t

  let value = Command.Next

  let enc = Command.enc
end)

module StepInArguments = struct
  type t = {
    threadId : int;
    singleThread : bool option;
    targetId : int option;
    granularity : SteppingGranularity.t option;
  }

  let enc =
    let open Data_encoding in
    (* StepInArguments.t *)
    conv
      (fun {threadId; singleThread; targetId; granularity} ->
        (threadId, singleThread, targetId, granularity))
      (fun (threadId, singleThread, targetId, granularity) ->
        {threadId; singleThread; targetId; granularity})
      (obj4
         (req "threadId" int31)
         (opt "singleThread" bool)
         (opt "targetId" int31)
         (opt "granularity" SteppingGranularity.enc))

  let make ~threadId ?singleThread ?targetId ?granularity () =
    {threadId; singleThread; targetId; granularity}
end

module StepInRequestMessage = MakeRequest (struct
  type t = Command.t

  let value = Command.StepIn

  let enc = Command.enc
end)

module StepInResponseMessage = MakeResponse_optionalBody (struct
  type t = Command.t

  let value = Command.StepIn

  let enc = Command.enc
end)

module StepOutArguments = struct
  type t = {
    threadId : int;
    singleThread : bool option;
    granularity : SteppingGranularity.t option;
  }

  let enc =
    let open Data_encoding in
    (* StepOutArguments.t *)
    conv
      (fun {threadId; singleThread; granularity} ->
        (threadId, singleThread, granularity))
      (fun (threadId, singleThread, granularity) ->
        {threadId; singleThread; granularity})
      (obj3
         (req "threadId" int31)
         (opt "singleThread" bool)
         (opt "granularity" SteppingGranularity.enc))

  let make ~threadId ?singleThread ?granularity () =
    {threadId; singleThread; granularity}
end

module StepOutRequestMessage = MakeRequest (struct
  type t = Command.t

  let value = Command.StepOut

  let enc = Command.enc
end)

module StepOutResponseMessage = MakeResponse_optionalBody (struct
  type t = Command.t

  let value = Command.StepOut

  let enc = Command.enc
end)

module StepBackArguments = struct
  type t = {
    threadId : int;
    singleThread : bool option;
    granularity : SteppingGranularity.t option;
  }

  let enc =
    let open Data_encoding in
    (* StepBackArguments.t *)
    conv
      (fun {threadId; singleThread; granularity} ->
        (threadId, singleThread, granularity))
      (fun (threadId, singleThread, granularity) ->
        {threadId; singleThread; granularity})
      (obj3
         (req "threadId" int31)
         (opt "singleThread" bool)
         (opt "granularity" SteppingGranularity.enc))

  let make ~threadId ?singleThread ?granularity () =
    {threadId; singleThread; granularity}
end

module StepBackRequestMessage = MakeRequest (struct
  type t = Command.t

  let value = Command.StepBack

  let enc = Command.enc
end)

module StepBackResponseMessage = MakeResponse_optionalBody (struct
  type t = Command.t

  let value = Command.StepBack

  let enc = Command.enc
end)

module ReverseContinueArguments = struct
  type t = {threadId : int; singleThread : bool option}

  let enc =
    let open Data_encoding in
    (* ReverseContinueArguments.t *)
    conv
      (fun {threadId; singleThread} -> (threadId, singleThread))
      (fun (threadId, singleThread) -> {threadId; singleThread})
      (obj2 (req "threadId" int31) (opt "singleThread" bool))

  let make ~threadId ?singleThread () = {threadId; singleThread}
end

module ReverseContinueRequestMessage = MakeRequest (struct
  type t = Command.t

  let value = Command.ReverseContinue

  let enc = Command.enc
end)

module ReverseContinueResponseMessage = MakeResponse_optionalBody (struct
  type t = Command.t

  let value = Command.ReverseContinue

  let enc = Command.enc
end)

module RestartFrameArguments = struct
  type t = {frameId : int}

  let enc =
    let open Data_encoding in
    (* RestartFrameArguments.t *)
    conv
      (fun {frameId} -> frameId)
      (fun frameId -> {frameId})
      (obj1 (req "frameId" int31))

  let make ~frameId () = {frameId}
end

module RestartFrameRequestMessage = MakeRequest (struct
  type t = Command.t

  let value = Command.RestartFrame

  let enc = Command.enc
end)

module RestartFrameResponseMessage = MakeResponse_optionalBody (struct
  type t = Command.t

  let value = Command.RestartFrame

  let enc = Command.enc
end)

module GotoArguments = struct
  type t = {threadId : int; targetId : int}

  let enc =
    let open Data_encoding in
    (* GotoArguments.t *)
    conv
      (fun {threadId; targetId} -> (threadId, targetId))
      (fun (threadId, targetId) -> {threadId; targetId})
      (obj2 (req "threadId" int31) (req "targetId" int31))

  let make ~threadId ~targetId () = {threadId; targetId}
end

module GotoRequestMessage = MakeRequest (struct
  type t = Command.t

  let value = Command.Goto

  let enc = Command.enc
end)

module GotoResponseMessage = MakeResponse_optionalBody (struct
  type t = Command.t

  let value = Command.Goto

  let enc = Command.enc
end)

module PauseArguments = struct
  type t = {threadId : int}

  let enc =
    let open Data_encoding in
    (* PauseArguments.t *)
    conv
      (fun {threadId} -> threadId)
      (fun threadId -> {threadId})
      (obj1 (req "threadId" int31))

  let make ~threadId () = {threadId}
end

module PauseRequestMessage = MakeRequest (struct
  type t = Command.t

  let value = Command.Pause

  let enc = Command.enc
end)

module PauseResponseMessage = MakeResponse_optionalBody (struct
  type t = Command.t

  let value = Command.Pause

  let enc = Command.enc
end)

module ValueFormat = struct
  type t = {hex : bool option}

  let enc =
    let open Data_encoding in
    (* ValueFormat.t *)
    conv (fun {hex} -> hex) (fun hex -> {hex}) (obj1 (opt "hex" bool))

  let make ?hex () = {hex}
end

module StackFrameFormat = struct
  type t = {
    hex : bool option;
    parameters : bool option;
    parameterTypes : bool option;
    parameterNames : bool option;
    parameterValues : bool option;
    line : bool option;
    module_ : bool option;
    includeAll : bool option;
  }

  let enc =
    let open Data_encoding in
    (* StackFrameFormat.t *)
    conv
      (fun {
             hex;
             parameters;
             parameterTypes;
             parameterNames;
             parameterValues;
             line;
             module_;
             includeAll;
           } ->
        ( hex,
          parameters,
          parameterTypes,
          parameterNames,
          parameterValues,
          line,
          module_,
          includeAll ))
      (fun ( hex,
             parameters,
             parameterTypes,
             parameterNames,
             parameterValues,
             line,
             module_,
             includeAll ) ->
        {
          hex;
          parameters;
          parameterTypes;
          parameterNames;
          parameterValues;
          line;
          module_;
          includeAll;
        })
      (obj8
         (opt "hex" bool)
         (opt "parameters" bool)
         (opt "parameterTypes" bool)
         (opt "parameterNames" bool)
         (opt "parameterValues" bool)
         (opt "line" bool)
         (opt "module" bool)
         (opt "includeAll" bool))

  let make ?hex ?parameters ?parameterTypes ?parameterNames ?parameterValues
      ?line ?module_ ?includeAll () =
    {
      hex;
      parameters;
      parameterTypes;
      parameterNames;
      parameterValues;
      line;
      module_;
      includeAll;
    }
end

module StackTraceArguments = struct
  type t = {
    threadId : int;
    startFrame : int option;
    levels : int option;
    format : StackFrameFormat.t option;
  }

  let enc =
    let open Data_encoding in
    (* StackTraceArguments.t *)
    conv
      (fun {threadId; startFrame; levels; format} ->
        (threadId, startFrame, levels, format))
      (fun (threadId, startFrame, levels, format) ->
        {threadId; startFrame; levels; format})
      (obj4
         (req "threadId" int31)
         (opt "startFrame" int31)
         (opt "levels" int31)
         (opt "format" StackFrameFormat.enc))

  let make ~threadId ?startFrame ?levels ?format () =
    {threadId; startFrame; levels; format}
end

module StackTraceRequestMessage = MakeRequest (struct
  type t = Command.t

  let value = Command.StackTrace

  let enc = Command.enc
end)

module StackFrame_presentationHint = struct
  type t = Normal | Label | Subtle

  let enc =
    let open Data_encoding in
    conv
      (function Normal -> "normal" | Label -> "label" | Subtle -> "subtle")
      (function
        | "normal" -> Normal
        | "label" -> Label
        | "subtle" -> Subtle
        | _ -> failwith "StackFrame_presentationHint")
      string
end

module StackFrame = struct
  module StackFrame_0 = struct
    type t = {
      id : int;
      name : string;
      source : Source.t option;
      line : int;
      column : int;
      endLine : int option;
      endColumn : int option;
      canRestart : bool option;
      instructionPointerReference : string option;
      moduleId : IntString.t option;
    }

    let enc =
      let open Data_encoding in
      (* StackFrame_0.t *)
      conv
        (fun {
               id;
               name;
               source;
               line;
               column;
               endLine;
               endColumn;
               canRestart;
               instructionPointerReference;
               moduleId;
             } ->
          ( id,
            name,
            source,
            line,
            column,
            endLine,
            endColumn,
            canRestart,
            instructionPointerReference,
            moduleId ))
        (fun ( id,
               name,
               source,
               line,
               column,
               endLine,
               endColumn,
               canRestart,
               instructionPointerReference,
               moduleId ) ->
          {
            id;
            name;
            source;
            line;
            column;
            endLine;
            endColumn;
            canRestart;
            instructionPointerReference;
            moduleId;
          })
        (obj10
           (req "id" int31)
           (req "name" string)
           (opt "source" Source.enc)
           (req "line" int31)
           (req "column" int31)
           (opt "endLine" int31)
           (opt "endColumn" int31)
           (opt "canRestart" bool)
           (opt "instructionPointerReference" string)
           (opt "moduleId" IntString.enc))

    let make ~id ~name ?source ~line ~column ?endLine ?endColumn ?canRestart
        ?instructionPointerReference ?moduleId () =
      {
        id;
        name;
        source;
        line;
        column;
        endLine;
        endColumn;
        canRestart;
        instructionPointerReference;
        moduleId;
      }
  end

  module StackFrame_10 = struct
    type t = {presentationHint : StackFrame_presentationHint.t option}

    let enc =
      let open Data_encoding in
      (* StackFrame_10.t *)
      conv
        (fun {presentationHint} -> presentationHint)
        (fun presentationHint -> {presentationHint})
        (obj1 (opt "presentationHint" StackFrame_presentationHint.enc))

    let make ?presentationHint () = {presentationHint}
  end

  type t = StackFrame_0.t * StackFrame_10.t

  let enc =
    let open Data_encoding in
    merge_objs StackFrame_0.enc StackFrame_10.enc

  let make ~id ~name ?source ~line ~column ?endLine ?endColumn ?canRestart
      ?instructionPointerReference ?moduleId ?presentationHint () =
    let t0 =
      StackFrame_0.make
        ~id
        ~name
        ?source
        ~line
        ~column
        ?endLine
        ?endColumn
        ?canRestart
        ?instructionPointerReference
        ?moduleId
        ()
    in

    let t1 = StackFrame_10.make ?presentationHint () in

    (t0, t1)
end

module StackTraceResponse_body = struct
  type t = {stackFrames : StackFrame.t list; totalFrames : int option}

  let enc =
    let open Data_encoding in
    (* StackTraceResponse_body.t *)
    conv
      (fun {stackFrames; totalFrames} -> (stackFrames, totalFrames))
      (fun (stackFrames, totalFrames) -> {stackFrames; totalFrames})
      (obj2 (req "stackFrames" (list StackFrame.enc)) (opt "totalFrames" int31))

  let make ~stackFrames ?totalFrames () = {stackFrames; totalFrames}
end

module StackTraceResponseMessage = MakeResponse (struct
  type t = Command.t

  let value = Command.StackTrace

  let enc = Command.enc
end)

module ScopesArguments = struct
  type t = {frameId : int}

  let enc =
    let open Data_encoding in
    (* ScopesArguments.t *)
    conv
      (fun {frameId} -> frameId)
      (fun frameId -> {frameId})
      (obj1 (req "frameId" int31))

  let make ~frameId () = {frameId}
end

module ScopesRequestMessage = MakeRequest (struct
  type t = Command.t

  let value = Command.Scopes

  let enc = Command.enc
end)

module Scope_presentationHint = struct
  type t = Arguments | Locals | Registers | Other of string

  let enc =
    let open Data_encoding in
    conv
      (function
        | Arguments -> "arguments"
        | Locals -> "locals"
        | Registers -> "registers"
        | Other s -> s)
      (function
        | "arguments" -> Arguments
        | "locals" -> Locals
        | "registers" -> Registers
        | _ as s -> Other s)
      string
end

module Scope = struct
  module Scope_0 = struct
    type t = {
      name : string;
      presentationHint : Scope_presentationHint.t option;
      variablesReference : int;
      namedVariables : int option;
      indexedVariables : int option;
      expensive : bool;
      source : Source.t option;
      line : int option;
      column : int option;
      endLine : int option;
    }

    let enc =
      let open Data_encoding in
      (* Scope_0.t *)
      conv
        (fun {
               name;
               presentationHint;
               variablesReference;
               namedVariables;
               indexedVariables;
               expensive;
               source;
               line;
               column;
               endLine;
             } ->
          ( name,
            presentationHint,
            variablesReference,
            namedVariables,
            indexedVariables,
            expensive,
            source,
            line,
            column,
            endLine ))
        (fun ( name,
               presentationHint,
               variablesReference,
               namedVariables,
               indexedVariables,
               expensive,
               source,
               line,
               column,
               endLine ) ->
          {
            name;
            presentationHint;
            variablesReference;
            namedVariables;
            indexedVariables;
            expensive;
            source;
            line;
            column;
            endLine;
          })
        (obj10
           (req "name" string)
           (opt "presentationHint" Scope_presentationHint.enc)
           (req "variablesReference" int31)
           (opt "namedVariables" int31)
           (opt "indexedVariables" int31)
           (req "expensive" bool)
           (opt "source" Source.enc)
           (opt "line" int31)
           (opt "column" int31)
           (opt "endLine" int31))

    let make ~name ?presentationHint ~variablesReference ?namedVariables
        ?indexedVariables ~expensive ?source ?line ?column ?endLine () =
      {
        name;
        presentationHint;
        variablesReference;
        namedVariables;
        indexedVariables;
        expensive;
        source;
        line;
        column;
        endLine;
      }
  end

  module Scope_10 = struct
    type t = {endColumn : int option}

    let enc =
      let open Data_encoding in
      (* Scope_10.t *)
      conv
        (fun {endColumn} -> endColumn)
        (fun endColumn -> {endColumn})
        (obj1 (opt "endColumn" int31))

    let make ?endColumn () = {endColumn}
  end

  type t = Scope_0.t * Scope_10.t

  let enc =
    let open Data_encoding in
    merge_objs Scope_0.enc Scope_10.enc

  let make ~name ?presentationHint ~variablesReference ?namedVariables
      ?indexedVariables ~expensive ?source ?line ?column ?endLine ?endColumn ()
      =
    let t0 =
      Scope_0.make
        ~name
        ?presentationHint
        ~variablesReference
        ?namedVariables
        ?indexedVariables
        ~expensive
        ?source
        ?line
        ?column
        ?endLine
        ()
    in

    let t1 = Scope_10.make ?endColumn () in

    (t0, t1)
end

module ScopesResponse_body = struct
  type t = {scopes : Scope.t list}

  let enc =
    let open Data_encoding in
    (* ScopesResponse_body.t *)
    conv
      (fun {scopes} -> scopes)
      (fun scopes -> {scopes})
      (obj1 (req "scopes" (list Scope.enc)))

  let make ~scopes () = {scopes}
end

module ScopesResponseMessage = MakeResponse (struct
  type t = Command.t

  let value = Command.Scopes

  let enc = Command.enc
end)

module VariablesArguments_filter = struct
  type t = Indexed | Named

  let enc =
    let open Data_encoding in
    conv
      (function Indexed -> "indexed" | Named -> "named")
      (function
        | "indexed" -> Indexed
        | "named" -> Named
        | _ -> failwith "VariablesArguments_filter")
      string
end

module VariablesArguments = struct
  type t = {
    variablesReference : int;
    filter : VariablesArguments_filter.t option;
    start : int option;
    count : int option;
    format : ValueFormat.t option;
  }

  let enc =
    let open Data_encoding in
    (* VariablesArguments.t *)
    conv
      (fun {variablesReference; filter; start; count; format} ->
        (variablesReference, filter, start, count, format))
      (fun (variablesReference, filter, start, count, format) ->
        {variablesReference; filter; start; count; format})
      (obj5
         (req "variablesReference" int31)
         (opt "filter" VariablesArguments_filter.enc)
         (opt "start" int31)
         (opt "count" int31)
         (opt "format" ValueFormat.enc))

  let make ~variablesReference ?filter ?start ?count ?format () =
    {variablesReference; filter; start; count; format}
end

module VariablesRequestMessage = MakeRequest (struct
  type t = Command.t

  let value = Command.Variables

  let enc = Command.enc
end)

module VariablePresentationHint_kind = struct
  type t =
    | Property
    | Method
    | Class
    | Data
    | Event
    | BaseClass
    | InnerClass
    | Interface
    | MostDerivedClass
    | Virtual
    | DataBreakpoint
    | Other of string

  let enc =
    let open Data_encoding in
    conv
      (function
        | Property -> "property"
        | Method -> "method"
        | Class -> "class"
        | Data -> "data"
        | Event -> "event"
        | BaseClass -> "baseClass"
        | InnerClass -> "innerClass"
        | Interface -> "interface"
        | MostDerivedClass -> "mostDerivedClass"
        | Virtual -> "virtual"
        | DataBreakpoint -> "dataBreakpoint"
        | Other s -> s)
      (function
        | "property" -> Property
        | "method" -> Method
        | "class" -> Class
        | "data" -> Data
        | "event" -> Event
        | "baseClass" -> BaseClass
        | "innerClass" -> InnerClass
        | "interface" -> Interface
        | "mostDerivedClass" -> MostDerivedClass
        | "virtual" -> Virtual
        | "dataBreakpoint" -> DataBreakpoint
        | _ as s -> Other s)
      string
end

module VariablePresentationHint_attributes_items = struct
  type t =
    | Static
    | Constant
    | ReadOnly
    | RawString
    | HasObjectId
    | CanHaveObjectId
    | HasSideEffects
    | HasDataBreakpoint
    | Other of string

  let enc =
    let open Data_encoding in
    conv
      (function
        | Static -> "static"
        | Constant -> "constant"
        | ReadOnly -> "readOnly"
        | RawString -> "rawString"
        | HasObjectId -> "hasObjectId"
        | CanHaveObjectId -> "canHaveObjectId"
        | HasSideEffects -> "hasSideEffects"
        | HasDataBreakpoint -> "hasDataBreakpoint"
        | Other s -> s)
      (function
        | "static" -> Static
        | "constant" -> Constant
        | "readOnly" -> ReadOnly
        | "rawString" -> RawString
        | "hasObjectId" -> HasObjectId
        | "canHaveObjectId" -> CanHaveObjectId
        | "hasSideEffects" -> HasSideEffects
        | "hasDataBreakpoint" -> HasDataBreakpoint
        | _ as s -> Other s)
      string
end

module VariablePresentationHint_visibility = struct
  type t = Public | Private | Protected | Internal | Final | Other of string

  let enc =
    let open Data_encoding in
    conv
      (function
        | Public -> "public"
        | Private -> "private"
        | Protected -> "protected"
        | Internal -> "internal"
        | Final -> "final"
        | Other s -> s)
      (function
        | "public" -> Public
        | "private" -> Private
        | "protected" -> Protected
        | "internal" -> Internal
        | "final" -> Final
        | _ as s -> Other s)
      string
end

module VariablePresentationHint = struct
  type t = {
    kind : VariablePresentationHint_kind.t option;
    attributes : VariablePresentationHint_attributes_items.t list option;
    visibility : VariablePresentationHint_visibility.t option;
    lazy_ : bool option;
  }

  let enc =
    let open Data_encoding in
    (* VariablePresentationHint.t *)
    conv
      (fun {kind; attributes; visibility; lazy_} ->
        (kind, attributes, visibility, lazy_))
      (fun (kind, attributes, visibility, lazy_) ->
        {kind; attributes; visibility; lazy_})
      (obj4
         (opt "kind" VariablePresentationHint_kind.enc)
         (opt "attributes" (list VariablePresentationHint_attributes_items.enc))
         (opt "visibility" VariablePresentationHint_visibility.enc)
         (opt "lazy" bool))

  let make ?kind ?attributes ?visibility ?lazy_ () =
    {kind; attributes; visibility; lazy_}
end

module Variable_ = struct
  type t = {
    name : string;
    value : string;
    type_ : string option;
    presentationHint : VariablePresentationHint.t option;
    evaluateName : string option;
    variablesReference : int;
    namedVariables : int option;
    indexedVariables : int option;
    memoryReference : string option;
  }

  let enc =
    let open Data_encoding in
    (* Variable_.t *)
    conv
      (fun {
             name;
             value;
             type_;
             presentationHint;
             evaluateName;
             variablesReference;
             namedVariables;
             indexedVariables;
             memoryReference;
           } ->
        ( name,
          value,
          type_,
          presentationHint,
          evaluateName,
          variablesReference,
          namedVariables,
          indexedVariables,
          memoryReference ))
      (fun ( name,
             value,
             type_,
             presentationHint,
             evaluateName,
             variablesReference,
             namedVariables,
             indexedVariables,
             memoryReference ) ->
        {
          name;
          value;
          type_;
          presentationHint;
          evaluateName;
          variablesReference;
          namedVariables;
          indexedVariables;
          memoryReference;
        })
      (obj9
         (req "name" string)
         (req "value" string)
         (opt "type" string)
         (opt "presentationHint" VariablePresentationHint.enc)
         (opt "evaluateName" string)
         (req "variablesReference" int31)
         (opt "namedVariables" int31)
         (opt "indexedVariables" int31)
         (opt "memoryReference" string))

  let make ~name ~value ?type_ ?presentationHint ?evaluateName
      ~variablesReference ?namedVariables ?indexedVariables ?memoryReference ()
      =
    {
      name;
      value;
      type_;
      presentationHint;
      evaluateName;
      variablesReference;
      namedVariables;
      indexedVariables;
      memoryReference;
    }
end

module VariablesResponse_body = struct
  type t = {variables : Variable_.t list}

  let enc =
    let open Data_encoding in
    (* VariablesResponse_body.t *)
    conv
      (fun {variables} -> variables)
      (fun variables -> {variables})
      (obj1 (req "variables" (list Variable_.enc)))

  let make ~variables () = {variables}
end

module VariablesResponseMessage = MakeResponse (struct
  type t = Command.t

  let value = Command.Variables

  let enc = Command.enc
end)

module SetVariableArguments = struct
  type t = {
    variablesReference : int;
    name : string;
    value : string;
    format : ValueFormat.t option;
  }

  let enc =
    let open Data_encoding in
    (* SetVariableArguments.t *)
    conv
      (fun {variablesReference; name; value; format} ->
        (variablesReference, name, value, format))
      (fun (variablesReference, name, value, format) ->
        {variablesReference; name; value; format})
      (obj4
         (req "variablesReference" int31)
         (req "name" string)
         (req "value" string)
         (opt "format" ValueFormat.enc))

  let make ~variablesReference ~name ~value ?format () =
    {variablesReference; name; value; format}
end

module SetVariableRequestMessage = MakeRequest (struct
  type t = Command.t

  let value = Command.SetVariable

  let enc = Command.enc
end)

module SetVariableResponse_body = struct
  type t = {
    value : string;
    type_ : string option;
    variablesReference : int option;
    namedVariables : int option;
    indexedVariables : int option;
  }

  let enc =
    let open Data_encoding in
    (* SetVariableResponse_body.t *)
    conv
      (fun {value; type_; variablesReference; namedVariables; indexedVariables} ->
        (value, type_, variablesReference, namedVariables, indexedVariables))
      (fun (value, type_, variablesReference, namedVariables, indexedVariables) ->
        {value; type_; variablesReference; namedVariables; indexedVariables})
      (obj5
         (req "value" string)
         (opt "type" string)
         (opt "variablesReference" int31)
         (opt "namedVariables" int31)
         (opt "indexedVariables" int31))

  let make ~value ?type_ ?variablesReference ?namedVariables ?indexedVariables
      () =
    {value; type_; variablesReference; namedVariables; indexedVariables}
end

module SetVariableResponseMessage = MakeResponse (struct
  type t = Command.t

  let value = Command.SetVariable

  let enc = Command.enc
end)

module SourceArguments = struct
  type t = {source : Source.t option; sourceReference : int}

  let enc =
    let open Data_encoding in
    (* SourceArguments.t *)
    conv
      (fun {source; sourceReference} -> (source, sourceReference))
      (fun (source, sourceReference) -> {source; sourceReference})
      (obj2 (opt "source" Source.enc) (req "sourceReference" int31))

  let make ?source ~sourceReference () = {source; sourceReference}
end

module SourceRequestMessage = MakeRequest (struct
  type t = Command.t

  let value = Command.Source

  let enc = Command.enc
end)

module SourceResponse_body = struct
  type t = {content : string; mimeType : string option}

  let enc =
    let open Data_encoding in
    (* SourceResponse_body.t *)
    conv
      (fun {content; mimeType} -> (content, mimeType))
      (fun (content, mimeType) -> {content; mimeType})
      (obj2 (req "content" string) (opt "mimeType" string))

  let make ~content ?mimeType () = {content; mimeType}
end

module SourceResponseMessage = MakeResponse (struct
  type t = Command.t

  let value = Command.Source

  let enc = Command.enc
end)

module ThreadsRequestMessage = MakeRequest_optionalArgs (struct
  type t = Command.t

  let value = Command.Threads

  let enc = Command.enc
end)

module Thread = struct
  type t = {id : int; name : string}

  let enc =
    let open Data_encoding in
    (* Thread.t *)
    conv
      (fun {id; name} -> (id, name))
      (fun (id, name) -> {id; name})
      (obj2 (req "id" int31) (req "name" string))

  let make ~id ~name () = {id; name}
end

module ThreadsResponse_body = struct
  type t = {threads : Thread.t list}

  let enc =
    let open Data_encoding in
    (* ThreadsResponse_body.t *)
    conv
      (fun {threads} -> threads)
      (fun threads -> {threads})
      (obj1 (req "threads" (list Thread.enc)))

  let make ~threads () = {threads}
end

module ThreadsResponseMessage = MakeResponse (struct
  type t = Command.t

  let value = Command.Threads

  let enc = Command.enc
end)

module TerminateThreadsArguments = struct
  type t = {threadIds : int list option}

  let enc =
    let open Data_encoding in
    (* TerminateThreadsArguments.t *)
    conv
      (fun {threadIds} -> threadIds)
      (fun threadIds -> {threadIds})
      (obj1 (opt "threadIds" (list int31)))

  let make ?threadIds () = {threadIds}
end

module TerminateThreadsRequestMessage = MakeRequest (struct
  type t = Command.t

  let value = Command.TerminateThreads

  let enc = Command.enc
end)

module TerminateThreadsResponseMessage = MakeResponse_optionalBody (struct
  type t = Command.t

  let value = Command.TerminateThreads

  let enc = Command.enc
end)

module ModulesArguments = struct
  type t = {startModule : int option; moduleCount : int option}

  let enc =
    let open Data_encoding in
    (* ModulesArguments.t *)
    conv
      (fun {startModule; moduleCount} -> (startModule, moduleCount))
      (fun (startModule, moduleCount) -> {startModule; moduleCount})
      (obj2 (opt "startModule" int31) (opt "moduleCount" int31))

  let make ?startModule ?moduleCount () = {startModule; moduleCount}
end

module ModulesRequestMessage = MakeRequest (struct
  type t = Command.t

  let value = Command.Modules

  let enc = Command.enc
end)

module ModulesResponse_body = struct
  type t = {modules : Module_.t list; totalModules : int option}

  let enc =
    let open Data_encoding in
    (* ModulesResponse_body.t *)
    conv
      (fun {modules; totalModules} -> (modules, totalModules))
      (fun (modules, totalModules) -> {modules; totalModules})
      (obj2 (req "modules" (list Module_.enc)) (opt "totalModules" int31))

  let make ~modules ?totalModules () = {modules; totalModules}
end

module ModulesResponseMessage = MakeResponse (struct
  type t = Command.t

  let value = Command.Modules

  let enc = Command.enc
end)

module LoadedSourcesArguments = struct
  type t = unit

  let enc = Data_encoding.empty

  let make () = ()
end

module LoadedSourcesRequestMessage = MakeRequest_optionalArgs (struct
  type t = Command.t

  let value = Command.LoadedSources

  let enc = Command.enc
end)

module LoadedSourcesResponse_body = struct
  type t = {sources : Source.t list}

  let enc =
    let open Data_encoding in
    (* LoadedSourcesResponse_body.t *)
    conv
      (fun {sources} -> sources)
      (fun sources -> {sources})
      (obj1 (req "sources" (list Source.enc)))

  let make ~sources () = {sources}
end

module LoadedSourcesResponseMessage = MakeResponse (struct
  type t = Command.t

  let value = Command.LoadedSources

  let enc = Command.enc
end)

module EvaluateArguments_context = struct
  type t = Variables | Watch | Repl | Hover | Clipboard | Other of string

  let enc =
    let open Data_encoding in
    conv
      (function
        | Variables -> "variables"
        | Watch -> "watch"
        | Repl -> "repl"
        | Hover -> "hover"
        | Clipboard -> "clipboard"
        | Other s -> s)
      (function
        | "variables" -> Variables
        | "watch" -> Watch
        | "repl" -> Repl
        | "hover" -> Hover
        | "clipboard" -> Clipboard
        | _ as s -> Other s)
      string
end

module EvaluateArguments = struct
  type t = {
    expression : string;
    frameId : int option;
    context : EvaluateArguments_context.t option;
    format : ValueFormat.t option;
  }

  let enc =
    let open Data_encoding in
    (* EvaluateArguments.t *)
    conv
      (fun {expression; frameId; context; format} ->
        (expression, frameId, context, format))
      (fun (expression, frameId, context, format) ->
        {expression; frameId; context; format})
      (obj4
         (req "expression" string)
         (opt "frameId" int31)
         (opt "context" EvaluateArguments_context.enc)
         (opt "format" ValueFormat.enc))

  let make ~expression ?frameId ?context ?format () =
    {expression; frameId; context; format}
end

module EvaluateRequestMessage = MakeRequest (struct
  type t = Command.t

  let value = Command.Evaluate

  let enc = Command.enc
end)

module EvaluateResponse_body = struct
  type t = {
    result : string;
    type_ : string option;
    presentationHint : VariablePresentationHint.t option;
    variablesReference : int;
    namedVariables : int option;
    indexedVariables : int option;
    memoryReference : string option;
  }

  let enc =
    let open Data_encoding in
    (* EvaluateResponse_body.t *)
    conv
      (fun {
             result;
             type_;
             presentationHint;
             variablesReference;
             namedVariables;
             indexedVariables;
             memoryReference;
           } ->
        ( result,
          type_,
          presentationHint,
          variablesReference,
          namedVariables,
          indexedVariables,
          memoryReference ))
      (fun ( result,
             type_,
             presentationHint,
             variablesReference,
             namedVariables,
             indexedVariables,
             memoryReference ) ->
        {
          result;
          type_;
          presentationHint;
          variablesReference;
          namedVariables;
          indexedVariables;
          memoryReference;
        })
      (obj7
         (req "result" string)
         (opt "type" string)
         (opt "presentationHint" VariablePresentationHint.enc)
         (req "variablesReference" int31)
         (opt "namedVariables" int31)
         (opt "indexedVariables" int31)
         (opt "memoryReference" string))

  let make ~result ?type_ ?presentationHint ~variablesReference ?namedVariables
      ?indexedVariables ?memoryReference () =
    {
      result;
      type_;
      presentationHint;
      variablesReference;
      namedVariables;
      indexedVariables;
      memoryReference;
    }
end

module EvaluateResponseMessage = MakeResponse (struct
  type t = Command.t

  let value = Command.Evaluate

  let enc = Command.enc
end)

module SetExpressionArguments = struct
  type t = {
    expression : string;
    value : string;
    frameId : int option;
    format : ValueFormat.t option;
  }

  let enc =
    let open Data_encoding in
    (* SetExpressionArguments.t *)
    conv
      (fun {expression; value; frameId; format} ->
        (expression, value, frameId, format))
      (fun (expression, value, frameId, format) ->
        {expression; value; frameId; format})
      (obj4
         (req "expression" string)
         (req "value" string)
         (opt "frameId" int31)
         (opt "format" ValueFormat.enc))

  let make ~expression ~value ?frameId ?format () =
    {expression; value; frameId; format}
end

module SetExpressionRequestMessage = MakeRequest (struct
  type t = Command.t

  let value = Command.SetExpression

  let enc = Command.enc
end)

module SetExpressionResponse_body = struct
  type t = {
    value : string;
    type_ : string option;
    presentationHint : VariablePresentationHint.t option;
    variablesReference : int option;
    namedVariables : int option;
    indexedVariables : int option;
  }

  let enc =
    let open Data_encoding in
    (* SetExpressionResponse_body.t *)
    conv
      (fun {
             value;
             type_;
             presentationHint;
             variablesReference;
             namedVariables;
             indexedVariables;
           } ->
        ( value,
          type_,
          presentationHint,
          variablesReference,
          namedVariables,
          indexedVariables ))
      (fun ( value,
             type_,
             presentationHint,
             variablesReference,
             namedVariables,
             indexedVariables ) ->
        {
          value;
          type_;
          presentationHint;
          variablesReference;
          namedVariables;
          indexedVariables;
        })
      (obj6
         (req "value" string)
         (opt "type" string)
         (opt "presentationHint" VariablePresentationHint.enc)
         (opt "variablesReference" int31)
         (opt "namedVariables" int31)
         (opt "indexedVariables" int31))

  let make ~value ?type_ ?presentationHint ?variablesReference ?namedVariables
      ?indexedVariables () =
    {
      value;
      type_;
      presentationHint;
      variablesReference;
      namedVariables;
      indexedVariables;
    }
end

module SetExpressionResponseMessage = MakeResponse (struct
  type t = Command.t

  let value = Command.SetExpression

  let enc = Command.enc
end)

module StepInTargetsArguments = struct
  type t = {frameId : int}

  let enc =
    let open Data_encoding in
    (* StepInTargetsArguments.t *)
    conv
      (fun {frameId} -> frameId)
      (fun frameId -> {frameId})
      (obj1 (req "frameId" int31))

  let make ~frameId () = {frameId}
end

module StepInTargetsRequestMessage = MakeRequest (struct
  type t = Command.t

  let value = Command.StepInTargets

  let enc = Command.enc
end)

module StepInTarget = struct
  type t = {
    id : int;
    label : string;
    line : int option;
    column : int option;
    endLine : int option;
    endColumn : int option;
  }

  let enc =
    let open Data_encoding in
    (* StepInTarget.t *)
    conv
      (fun {id; label; line; column; endLine; endColumn} ->
        (id, label, line, column, endLine, endColumn))
      (fun (id, label, line, column, endLine, endColumn) ->
        {id; label; line; column; endLine; endColumn})
      (obj6
         (req "id" int31)
         (req "label" string)
         (opt "line" int31)
         (opt "column" int31)
         (opt "endLine" int31)
         (opt "endColumn" int31))

  let make ~id ~label ?line ?column ?endLine ?endColumn () =
    {id; label; line; column; endLine; endColumn}
end

module StepInTargetsResponse_body = struct
  type t = {targets : StepInTarget.t list}

  let enc =
    let open Data_encoding in
    (* StepInTargetsResponse_body.t *)
    conv
      (fun {targets} -> targets)
      (fun targets -> {targets})
      (obj1 (req "targets" (list StepInTarget.enc)))

  let make ~targets () = {targets}
end

module StepInTargetsResponseMessage = MakeResponse (struct
  type t = Command.t

  let value = Command.StepInTargets

  let enc = Command.enc
end)

module GotoTargetsArguments = struct
  type t = {source : Source.t; line : int; column : int option}

  let enc =
    let open Data_encoding in
    (* GotoTargetsArguments.t *)
    conv
      (fun {source; line; column} -> (source, line, column))
      (fun (source, line, column) -> {source; line; column})
      (obj3 (req "source" Source.enc) (req "line" int31) (opt "column" int31))

  let make ~source ~line ?column () = {source; line; column}
end

module GotoTargetsRequestMessage = MakeRequest (struct
  type t = Command.t

  let value = Command.GotoTargets

  let enc = Command.enc
end)

module GotoTarget = struct
  type t = {
    id : int;
    label : string;
    line : int;
    column : int option;
    endLine : int option;
    endColumn : int option;
    instructionPointerReference : string option;
  }

  let enc =
    let open Data_encoding in
    (* GotoTarget.t *)
    conv
      (fun {
             id;
             label;
             line;
             column;
             endLine;
             endColumn;
             instructionPointerReference;
           } ->
        ( id,
          label,
          line,
          column,
          endLine,
          endColumn,
          instructionPointerReference ))
      (fun ( id,
             label,
             line,
             column,
             endLine,
             endColumn,
             instructionPointerReference ) ->
        {
          id;
          label;
          line;
          column;
          endLine;
          endColumn;
          instructionPointerReference;
        })
      (obj7
         (req "id" int31)
         (req "label" string)
         (req "line" int31)
         (opt "column" int31)
         (opt "endLine" int31)
         (opt "endColumn" int31)
         (opt "instructionPointerReference" string))

  let make ~id ~label ~line ?column ?endLine ?endColumn
      ?instructionPointerReference () =
    {id; label; line; column; endLine; endColumn; instructionPointerReference}
end

module GotoTargetsResponse_body = struct
  type t = {targets : GotoTarget.t list}

  let enc =
    let open Data_encoding in
    (* GotoTargetsResponse_body.t *)
    conv
      (fun {targets} -> targets)
      (fun targets -> {targets})
      (obj1 (req "targets" (list GotoTarget.enc)))

  let make ~targets () = {targets}
end

module GotoTargetsResponseMessage = MakeResponse (struct
  type t = Command.t

  let value = Command.GotoTargets

  let enc = Command.enc
end)

module CompletionsArguments = struct
  type t = {
    frameId : int option;
    text : string;
    column : int;
    line : int option;
  }

  let enc =
    let open Data_encoding in
    (* CompletionsArguments.t *)
    conv
      (fun {frameId; text; column; line} -> (frameId, text, column, line))
      (fun (frameId, text, column, line) -> {frameId; text; column; line})
      (obj4
         (opt "frameId" int31)
         (req "text" string)
         (req "column" int31)
         (opt "line" int31))

  let make ?frameId ~text ~column ?line () = {frameId; text; column; line}
end

module CompletionsRequestMessage = MakeRequest (struct
  type t = Command.t

  let value = Command.Completions

  let enc = Command.enc
end)

module CompletionItemType = struct
  type t =
    | Method
    | Function
    | Constructor
    | Field
    | Variable_
    | Class
    | Interface
    | Module_
    | Property
    | Unit
    | Value
    | Enum
    | Keyword
    | Snippet
    | Text
    | Color
    | File
    | Reference
    | Customcolor

  let enc =
    let open Data_encoding in
    conv
      (function
        | Method -> "method"
        | Function -> "function"
        | Constructor -> "constructor"
        | Field -> "field"
        | Variable_ -> "variable"
        | Class -> "class"
        | Interface -> "interface"
        | Module_ -> "module"
        | Property -> "property"
        | Unit -> "unit"
        | Value -> "value"
        | Enum -> "enum"
        | Keyword -> "keyword"
        | Snippet -> "snippet"
        | Text -> "text"
        | Color -> "color"
        | File -> "file"
        | Reference -> "reference"
        | Customcolor -> "customcolor")
      (function
        | "method" -> Method
        | "function" -> Function
        | "constructor" -> Constructor
        | "field" -> Field
        | "variable" -> Variable_
        | "class" -> Class
        | "interface" -> Interface
        | "module" -> Module_
        | "property" -> Property
        | "unit" -> Unit
        | "value" -> Value
        | "enum" -> Enum
        | "keyword" -> Keyword
        | "snippet" -> Snippet
        | "text" -> Text
        | "color" -> Color
        | "file" -> File
        | "reference" -> Reference
        | "customcolor" -> Customcolor
        | _ -> failwith "CompletionItemType")
      string
end

module CompletionItem = struct
  type t = {
    label : string;
    text : string option;
    sortText : string option;
    detail : string option;
    type_ : CompletionItemType.t option;
    start : int option;
    length : int option;
    selectionStart : int option;
    selectionLength : int option;
  }

  let enc =
    let open Data_encoding in
    (* CompletionItem.t *)
    conv
      (fun {
             label;
             text;
             sortText;
             detail;
             type_;
             start;
             length;
             selectionStart;
             selectionLength;
           } ->
        ( label,
          text,
          sortText,
          detail,
          type_,
          start,
          length,
          selectionStart,
          selectionLength ))
      (fun ( label,
             text,
             sortText,
             detail,
             type_,
             start,
             length,
             selectionStart,
             selectionLength ) ->
        {
          label;
          text;
          sortText;
          detail;
          type_;
          start;
          length;
          selectionStart;
          selectionLength;
        })
      (obj9
         (req "label" string)
         (opt "text" string)
         (opt "sortText" string)
         (opt "detail" string)
         (opt "type" CompletionItemType.enc)
         (opt "start" int31)
         (opt "length" int31)
         (opt "selectionStart" int31)
         (opt "selectionLength" int31))

  let make ~label ?text ?sortText ?detail ?type_ ?start ?length ?selectionStart
      ?selectionLength () =
    {
      label;
      text;
      sortText;
      detail;
      type_;
      start;
      length;
      selectionStart;
      selectionLength;
    }
end

module CompletionsResponse_body = struct
  type t = {targets : CompletionItem.t list}

  let enc =
    let open Data_encoding in
    (* CompletionsResponse_body.t *)
    conv
      (fun {targets} -> targets)
      (fun targets -> {targets})
      (obj1 (req "targets" (list CompletionItem.enc)))

  let make ~targets () = {targets}
end

module CompletionsResponseMessage = MakeResponse (struct
  type t = Command.t

  let value = Command.Completions

  let enc = Command.enc
end)

module ExceptionInfoArguments = struct
  type t = {threadId : int}

  let enc =
    let open Data_encoding in
    (* ExceptionInfoArguments.t *)
    conv
      (fun {threadId} -> threadId)
      (fun threadId -> {threadId})
      (obj1 (req "threadId" int31))

  let make ~threadId () = {threadId}
end

module ExceptionInfoRequestMessage = MakeRequest (struct
  type t = Command.t

  let value = Command.ExceptionInfo

  let enc = Command.enc
end)

module ExceptionDetails = struct
  type t = {
    message : string option;
    typeName : string option;
    fullTypeName : string option;
    evaluateName : string option;
    stackTrace : string option;
    innerException : t list option;
  }

  let enc =
    let open Data_encoding in
    mu "ExceptionDetails.t" (fun e ->
        conv
          (fun {
                 message;
                 typeName;
                 fullTypeName;
                 evaluateName;
                 stackTrace;
                 innerException;
               } ->
            ( message,
              typeName,
              fullTypeName,
              evaluateName,
              stackTrace,
              innerException ))
          (fun ( message,
                 typeName,
                 fullTypeName,
                 evaluateName,
                 stackTrace,
                 innerException ) ->
            {
              message;
              typeName;
              fullTypeName;
              evaluateName;
              stackTrace;
              innerException;
            })
          (obj6
             (opt "message" string)
             (opt "typeName" string)
             (opt "fullTypeName" string)
             (opt "evaluateName" string)
             (opt "stackTrace" string)
             (opt "innerException" (list e))))

  let make ?message ?typeName ?fullTypeName ?evaluateName ?stackTrace
      ?innerException () =
    {message; typeName; fullTypeName; evaluateName; stackTrace; innerException}
end

module ExceptionInfoResponse_body = struct
  type t = {
    exceptionId : string;
    description : string option;
    breakMode : ExceptionBreakMode.t;
    details : ExceptionDetails.t option;
  }

  let enc =
    let open Data_encoding in
    (* ExceptionInfoResponse_body.t *)
    conv
      (fun {exceptionId; description; breakMode; details} ->
        (exceptionId, description, breakMode, details))
      (fun (exceptionId, description, breakMode, details) ->
        {exceptionId; description; breakMode; details})
      (obj4
         (req "exceptionId" string)
         (opt "description" string)
         (req "breakMode" ExceptionBreakMode.enc)
         (opt "details" ExceptionDetails.enc))

  let make ~exceptionId ?description ~breakMode ?details () =
    {exceptionId; description; breakMode; details}
end

module ExceptionInfoResponseMessage = MakeResponse (struct
  type t = Command.t

  let value = Command.ExceptionInfo

  let enc = Command.enc
end)

module ReadMemoryArguments = struct
  type t = {memoryReference : string; offset : int option; count : int}

  let enc =
    let open Data_encoding in
    (* ReadMemoryArguments.t *)
    conv
      (fun {memoryReference; offset; count} -> (memoryReference, offset, count))
      (fun (memoryReference, offset, count) -> {memoryReference; offset; count})
      (obj3
         (req "memoryReference" string)
         (opt "offset" int31)
         (req "count" int31))

  let make ~memoryReference ?offset ~count () = {memoryReference; offset; count}
end

module ReadMemoryRequestMessage = MakeRequest (struct
  type t = Command.t

  let value = Command.ReadMemory

  let enc = Command.enc
end)

module ReadMemoryResponse_body = struct
  type t = {
    address : string;
    unreadableBytes : int option;
    data : string option;
  }

  let enc =
    let open Data_encoding in
    (* ReadMemoryResponse_body.t *)
    conv
      (fun {address; unreadableBytes; data} -> (address, unreadableBytes, data))
      (fun (address, unreadableBytes, data) -> {address; unreadableBytes; data})
      (obj3
         (req "address" string)
         (opt "unreadableBytes" int31)
         (opt "data" string))

  let make ~address ?unreadableBytes ?data () = {address; unreadableBytes; data}
end

module ReadMemoryResponseMessage = MakeResponse_optionalBody (struct
  type t = Command.t

  let value = Command.ReadMemory

  let enc = Command.enc
end)

module WriteMemoryArguments = struct
  type t = {
    memoryReference : string;
    offset : int option;
    allowPartial : bool option;
    data : string;
  }

  let enc =
    let open Data_encoding in
    (* WriteMemoryArguments.t *)
    conv
      (fun {memoryReference; offset; allowPartial; data} ->
        (memoryReference, offset, allowPartial, data))
      (fun (memoryReference, offset, allowPartial, data) ->
        {memoryReference; offset; allowPartial; data})
      (obj4
         (req "memoryReference" string)
         (opt "offset" int31)
         (opt "allowPartial" bool)
         (req "data" string))

  let make ~memoryReference ?offset ?allowPartial ~data () =
    {memoryReference; offset; allowPartial; data}
end

module WriteMemoryRequestMessage = MakeRequest (struct
  type t = Command.t

  let value = Command.WriteMemory

  let enc = Command.enc
end)

module WriteMemoryResponse_body = struct
  type t = {offset : int option; bytesWritten : int option}

  let enc =
    let open Data_encoding in
    (* WriteMemoryResponse_body.t *)
    conv
      (fun {offset; bytesWritten} -> (offset, bytesWritten))
      (fun (offset, bytesWritten) -> {offset; bytesWritten})
      (obj2 (opt "offset" int31) (opt "bytesWritten" int31))

  let make ?offset ?bytesWritten () = {offset; bytesWritten}
end

module WriteMemoryResponseMessage = MakeResponse_optionalBody (struct
  type t = Command.t

  let value = Command.WriteMemory

  let enc = Command.enc
end)

module DisassembleArguments = struct
  type t = {
    memoryReference : string;
    offset : int option;
    instructionOffset : int option;
    instructionCount : int;
    resolveSymbols : bool option;
  }

  let enc =
    let open Data_encoding in
    (* DisassembleArguments.t *)
    conv
      (fun {
             memoryReference;
             offset;
             instructionOffset;
             instructionCount;
             resolveSymbols;
           } ->
        ( memoryReference,
          offset,
          instructionOffset,
          instructionCount,
          resolveSymbols ))
      (fun ( memoryReference,
             offset,
             instructionOffset,
             instructionCount,
             resolveSymbols ) ->
        {
          memoryReference;
          offset;
          instructionOffset;
          instructionCount;
          resolveSymbols;
        })
      (obj5
         (req "memoryReference" string)
         (opt "offset" int31)
         (opt "instructionOffset" int31)
         (req "instructionCount" int31)
         (opt "resolveSymbols" bool))

  let make ~memoryReference ?offset ?instructionOffset ~instructionCount
      ?resolveSymbols () =
    {
      memoryReference;
      offset;
      instructionOffset;
      instructionCount;
      resolveSymbols;
    }
end

module DisassembleRequestMessage = MakeRequest (struct
  type t = Command.t

  let value = Command.Disassemble

  let enc = Command.enc
end)

module DisassembledInstruction = struct
  type t = {
    address : string;
    instructionBytes : string option;
    instruction : string;
    symbol : string option;
    location : Source.t option;
    line : int option;
    column : int option;
    endLine : int option;
    endColumn : int option;
  }

  let enc =
    let open Data_encoding in
    (* DisassembledInstruction.t *)
    conv
      (fun {
             address;
             instructionBytes;
             instruction;
             symbol;
             location;
             line;
             column;
             endLine;
             endColumn;
           } ->
        ( address,
          instructionBytes,
          instruction,
          symbol,
          location,
          line,
          column,
          endLine,
          endColumn ))
      (fun ( address,
             instructionBytes,
             instruction,
             symbol,
             location,
             line,
             column,
             endLine,
             endColumn ) ->
        {
          address;
          instructionBytes;
          instruction;
          symbol;
          location;
          line;
          column;
          endLine;
          endColumn;
        })
      (obj9
         (req "address" string)
         (opt "instructionBytes" string)
         (req "instruction" string)
         (opt "symbol" string)
         (opt "location" Source.enc)
         (opt "line" int31)
         (opt "column" int31)
         (opt "endLine" int31)
         (opt "endColumn" int31))

  let make ~address ?instructionBytes ~instruction ?symbol ?location ?line
      ?column ?endLine ?endColumn () =
    {
      address;
      instructionBytes;
      instruction;
      symbol;
      location;
      line;
      column;
      endLine;
      endColumn;
    }
end

module DisassembleResponse_body = struct
  type t = {instructions : DisassembledInstruction.t list}

  let enc =
    let open Data_encoding in
    (* DisassembleResponse_body.t *)
    conv
      (fun {instructions} -> instructions)
      (fun instructions -> {instructions})
      (obj1 (req "instructions" (list DisassembledInstruction.enc)))

  let make ~instructions () = {instructions}
end

module DisassembleResponseMessage = MakeResponse_optionalBody (struct
  type t = Command.t

  let value = Command.Disassemble

  let enc = Command.enc
end)

module ModulesViewDescriptor = struct
  type t = {columns : ColumnDescriptor.t list}

  let enc =
    let open Data_encoding in
    (* ModulesViewDescriptor.t *)
    conv
      (fun {columns} -> columns)
      (fun columns -> {columns})
      (obj1 (req "columns" (list ColumnDescriptor.enc)))

  let make ~columns () = {columns}
end

type request =
  | CancelRequest of CancelArguments.t CancelRequestMessage.t
  | RunInTerminalRequest of
      RunInTerminalRequestArguments.t RunInTerminalRequestMessage.t
  | InitializeRequest of InitializeRequestArguments.t InitializeRequestMessage.t
  | ConfigurationDoneRequest of
      ConfigurationDoneArguments.t ConfigurationDoneRequestMessage.t
  | LaunchRequest of LaunchRequestArguments.t LaunchRequestMessage.t
  | AttachRequest of AttachRequestArguments.t AttachRequestMessage.t
  | RestartRequest of RestartArguments.t RestartRequestMessage.t
  | DisconnectRequest of DisconnectArguments.t DisconnectRequestMessage.t
  | TerminateRequest of TerminateArguments.t TerminateRequestMessage.t
  | BreakpointLocationsRequest of
      BreakpointLocationsArguments.t BreakpointLocationsRequestMessage.t
  | SetBreakpointsRequest of
      SetBreakpointsArguments.t SetBreakpointsRequestMessage.t
  | SetFunctionBreakpointsRequest of
      SetFunctionBreakpointsArguments.t SetFunctionBreakpointsRequestMessage.t
  | SetExceptionBreakpointsRequest of
      SetExceptionBreakpointsArguments.t SetExceptionBreakpointsRequestMessage.t
  | DataBreakpointInfoRequest of
      DataBreakpointInfoArguments.t DataBreakpointInfoRequestMessage.t
  | SetDataBreakpointsRequest of
      SetDataBreakpointsArguments.t SetDataBreakpointsRequestMessage.t
  | SetInstructionBreakpointsRequest of
      SetInstructionBreakpointsArguments.t
      SetInstructionBreakpointsRequestMessage.t
  | ContinueRequest of ContinueArguments.t ContinueRequestMessage.t
  | NextRequest of NextArguments.t NextRequestMessage.t
  | StepInRequest of StepInArguments.t StepInRequestMessage.t
  | StepOutRequest of StepOutArguments.t StepOutRequestMessage.t
  | StepBackRequest of StepBackArguments.t StepBackRequestMessage.t
  | ReverseContinueRequest of
      ReverseContinueArguments.t ReverseContinueRequestMessage.t
  | RestartFrameRequest of RestartFrameArguments.t RestartFrameRequestMessage.t
  | GotoRequest of GotoArguments.t GotoRequestMessage.t
  | PauseRequest of PauseArguments.t PauseRequestMessage.t
  | StackTraceRequest of StackTraceArguments.t StackTraceRequestMessage.t
  | ScopesRequest of ScopesArguments.t ScopesRequestMessage.t
  | VariablesRequest of VariablesArguments.t VariablesRequestMessage.t
  | SetVariableRequest of SetVariableArguments.t SetVariableRequestMessage.t
  | SourceRequest of SourceArguments.t SourceRequestMessage.t
  | ThreadsRequest of EmptyObject.t ThreadsRequestMessage.t
  | TerminateThreadsRequest of
      TerminateThreadsArguments.t TerminateThreadsRequestMessage.t
  | ModulesRequest of ModulesArguments.t ModulesRequestMessage.t
  | LoadedSourcesRequest of
      LoadedSourcesArguments.t LoadedSourcesRequestMessage.t
  | EvaluateRequest of EvaluateArguments.t EvaluateRequestMessage.t
  | SetExpressionRequest of
      SetExpressionArguments.t SetExpressionRequestMessage.t
  | StepInTargetsRequest of
      StepInTargetsArguments.t StepInTargetsRequestMessage.t
  | GotoTargetsRequest of GotoTargetsArguments.t GotoTargetsRequestMessage.t
  | CompletionsRequest of CompletionsArguments.t CompletionsRequestMessage.t
  | ExceptionInfoRequest of
      ExceptionInfoArguments.t ExceptionInfoRequestMessage.t
  | ReadMemoryRequest of ReadMemoryArguments.t ReadMemoryRequestMessage.t
  | WriteMemoryRequest of WriteMemoryArguments.t WriteMemoryRequestMessage.t
  | DisassembleRequest of DisassembleArguments.t DisassembleRequestMessage.t

type response =
  | ErrorResponse of ErrorResponse_body.t ErrorResponseMessage.t
  | CancelResponse of EmptyObject.t CancelResponseMessage.t
  | RunInTerminalResponse of
      RunInTerminalResponse_body.t RunInTerminalResponseMessage.t
  | InitializeResponse of Capabilities.t InitializeResponseMessage.t
  | ConfigurationDoneResponse of
      EmptyObject.t ConfigurationDoneResponseMessage.t
  | LaunchResponse of EmptyObject.t LaunchResponseMessage.t
  | AttachResponse of EmptyObject.t AttachResponseMessage.t
  | RestartResponse of EmptyObject.t RestartResponseMessage.t
  | DisconnectResponse of EmptyObject.t DisconnectResponseMessage.t
  | TerminateResponse of EmptyObject.t TerminateResponseMessage.t
  | BreakpointLocationsResponse of
      BreakpointLocationsResponse_body.t BreakpointLocationsResponseMessage.t
  | SetBreakpointsResponse of
      SetBreakpointsResponse_body.t SetBreakpointsResponseMessage.t
  | SetFunctionBreakpointsResponse of
      SetFunctionBreakpointsResponse_body.t
      SetFunctionBreakpointsResponseMessage.t
  | SetExceptionBreakpointsResponse of
      SetExceptionBreakpointsResponse_body.t
      SetExceptionBreakpointsResponseMessage.t
  | DataBreakpointInfoResponse of
      DataBreakpointInfoResponse_body.t DataBreakpointInfoResponseMessage.t
  | SetDataBreakpointsResponse of
      SetDataBreakpointsResponse_body.t SetDataBreakpointsResponseMessage.t
  | SetInstructionBreakpointsResponse of
      SetInstructionBreakpointsResponse_body.t
      SetInstructionBreakpointsResponseMessage.t
  | ContinueResponse of ContinueResponse_body.t ContinueResponseMessage.t
  | NextResponse of EmptyObject.t NextResponseMessage.t
  | StepInResponse of EmptyObject.t StepInResponseMessage.t
  | StepOutResponse of EmptyObject.t StepOutResponseMessage.t
  | StepBackResponse of EmptyObject.t StepBackResponseMessage.t
  | ReverseContinueResponse of EmptyObject.t ReverseContinueResponseMessage.t
  | RestartFrameResponse of EmptyObject.t RestartFrameResponseMessage.t
  | GotoResponse of EmptyObject.t GotoResponseMessage.t
  | PauseResponse of EmptyObject.t PauseResponseMessage.t
  | StackTraceResponse of StackTraceResponse_body.t StackTraceResponseMessage.t
  | ScopesResponse of ScopesResponse_body.t ScopesResponseMessage.t
  | VariablesResponse of VariablesResponse_body.t VariablesResponseMessage.t
  | SetVariableResponse of
      SetVariableResponse_body.t SetVariableResponseMessage.t
  | SourceResponse of SourceResponse_body.t SourceResponseMessage.t
  | ThreadsResponse of ThreadsResponse_body.t ThreadsResponseMessage.t
  | TerminateThreadsResponse of EmptyObject.t TerminateThreadsResponseMessage.t
  | ModulesResponse of ModulesResponse_body.t ModulesResponseMessage.t
  | LoadedSourcesResponse of
      LoadedSourcesResponse_body.t LoadedSourcesResponseMessage.t
  | EvaluateResponse of EvaluateResponse_body.t EvaluateResponseMessage.t
  | SetExpressionResponse of
      SetExpressionResponse_body.t SetExpressionResponseMessage.t
  | StepInTargetsResponse of
      StepInTargetsResponse_body.t StepInTargetsResponseMessage.t
  | GotoTargetsResponse of
      GotoTargetsResponse_body.t GotoTargetsResponseMessage.t
  | CompletionsResponse of
      CompletionsResponse_body.t CompletionsResponseMessage.t
  | ExceptionInfoResponse of
      ExceptionInfoResponse_body.t ExceptionInfoResponseMessage.t
  | ReadMemoryResponse of ReadMemoryResponse_body.t ReadMemoryResponseMessage.t
  | WriteMemoryResponse of
      WriteMemoryResponse_body.t WriteMemoryResponseMessage.t
  | DisassembleResponse of
      DisassembleResponse_body.t DisassembleResponseMessage.t

type event =
  | InitializedEvent of EmptyObject.t InitializedEventMessage.t
  | StoppedEvent of StoppedEvent_body.t StoppedEventMessage.t
  | ContinuedEvent of ContinuedEvent_body.t ContinuedEventMessage.t
  | ExitedEvent of ExitedEvent_body.t ExitedEventMessage.t
  | TerminatedEvent of TerminatedEvent_body.t TerminatedEventMessage.t
  | ThreadEvent of ThreadEvent_body.t ThreadEventMessage.t
  | OutputEvent of OutputEvent_body.t OutputEventMessage.t
  | BreakpointEvent of BreakpointEvent_body.t BreakpointEventMessage.t
  | ModuleEvent of ModuleEvent_body.t ModuleEventMessage.t
  | LoadedSourceEvent of LoadedSourceEvent_body.t LoadedSourceEventMessage.t
  | ProcessEvent of ProcessEvent_body.t ProcessEventMessage.t
  | CapabilitiesEvent of CapabilitiesEvent_body.t CapabilitiesEventMessage.t
  | ProgressStartEvent of ProgressStartEvent_body.t ProgressStartEventMessage.t
  | ProgressUpdateEvent of
      ProgressUpdateEvent_body.t ProgressUpdateEventMessage.t
  | ProgressEndEvent of ProgressEndEvent_body.t ProgressEndEventMessage.t
  | InvalidatedEvent of InvalidatedEvent_body.t InvalidatedEventMessage.t
  | MemoryEvent of MemoryEvent_body.t MemoryEventMessage.t
