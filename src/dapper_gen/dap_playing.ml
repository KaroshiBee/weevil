(* NOTE this file was autogenerated - do not modify by hand *)

open Dap_t


module Event = struct
  type memory
  type invalidated
  type progressend
  (* type progressupdate *)
  (* type progressstart *)
  (* type capabilities *)
  (* type process *)
  (* type loadedsource *)
  (* type module_ *)
  (* type breakpoint *)
  (* type output *)
  (* type thread *)
  (* type terminated *)
  (* type exited *)
  (* type continued *)
  (* type stopped *)
  (* type initialized *)

  module T = struct

    type ev =
      | Memory
      | Invalidated
      | ProgressEnd
      (* | ProgressUpdate *)
    (* | ProgressStart *)
    (* | Capabilities *)
    (* | Process *)
    (* | LoadedSource *)
    (* | Module_ *)
    (* | Breakpoint *)
    (* | Output *)
    (* | Thread *)
    (* | Terminated *)
    (* | Exited *)
    (* | Continued *)
    (* | Stopped *)
    (* | Initialized *)

    type 'a t = {value: ev}

    let make_Memory : memory t = {value=Memory}
    let make_Invalidated : invalidated t = {value=Invalidated}
    let make_ProgressEnd : progressend t = {value=ProgressEnd}
    (* let make_ProgressUpdate : progressupdate t = {value=ProgressUpdate} *)
    (* let make_ProgressStart : progressstart t = {value=ProgressStart} *)
    (* let make_Capabilities : capabilities t = {value=Capabilities} *)
    (* let make_Process : process t = {value=Process} *)
    (* let make_LoadedSource : loadedsource t = {value=LoadedSource} *)
    (* let make_Module_ : module_ t = {value= Module_} *)
    (* let make_Breakpoint : breakpoint t = {value=Breakpoint} *)
    (* let make_Output : output t = {value=Output} *)
    (* let make_Thread : thread t = {value=Thread} *)
    (* let make_Terminated : terminated t = {value=Terminated} *)
    (* let make_Exited : exited t = {value=Exited} *)
    (* let make_Continued : continued t = {value=Continued} *)
    (* let make_Stopped : stopped t = {value=Stopped} *)
    (* let make_Initialized : initialized t = {value=Initialized} *)
  end

  type t =
    | Memory : memory T.t -> t
    | Invalidated : invalidated T.t -> t
    | ProgressEnd : progressend T.t -> t

  let enc =
    let f : t -> string = function
      | Memory _ -> "memory"
      | Invalidated _ -> "invalidated"
      | ProgressEnd _ -> "progressEnd"
    in
    let g : string -> t = function
      | "memory" -> let v = T.make_Memory in Memory v
      | "invalidated" -> let v = T.make_Invalidated in Invalidated v
      | "progressEnd" -> let v = T.make_ProgressEnd in ProgressEnd v
      | _ -> failwith "Event"
    in
    Data_encoding.(conv f g string)

  (* let enc = *)
  (*   let f : type a. a t -> string = function *)
  (*       | Memory _ -> "memory" *)
  (*       | Invalidated _ -> "invalidated" *)
  (*       | ProgressEnd _ -> "progressEnd" *)
  (*       | ProgressUpdate _ -> "progressUpdate" *)
  (*       | ProgressStart _ -> "progressStart" *)
  (*       | Capabilities _ -> "capabilities" *)
  (*       | Process _ -> "process" *)
  (*       | LoadedSource _ -> "loadedSource" *)
  (*       | Module_ _ -> "module" *)
  (*       | Breakpoint _ -> "breakpoint" *)
  (*       | Output _ -> "output" *)
  (*       | Thread _ -> "thread" *)
  (*       | Terminated _ -> "terminated" *)
  (*       | Exited _ -> "exited" *)
  (*       | Continued _ -> "continued" *)
  (*       | Stopped _ -> "stopped" *)
  (*       | Initialized _ -> "initialized" *)
  (*   in *)
  (*   let g : type a. string -> a t = function *)
  (*       | "memory" -> Memory memory *)
  (*       | "invalidated" -> Invalidated _ *)
  (*       | "progressEnd" -> ProgressEnd _ *)
  (*       | "progressUpdate" -> ProgressUpdate _ *)
  (*       | "progressStart" -> ProgressStart _ *)
  (*       | "capabilities" -> Capabilities _ *)
  (*       | "process" -> Process _ *)
  (*       | "loadedSource" -> LoadedSource _ *)
  (*       | "module" -> Module_ _ *)
  (*       | "breakpoint" -> Breakpoint _ *)
  (*       | "output" -> Output _ *)
  (*       | "thread" -> Thread _ *)
  (*       | "terminated" -> Terminated _ *)
  (*       | "exited" -> Exited _ *)
  (*       | "continued" -> Continued _ *)
  (*       | "stopped" -> Stopped _ *)
  (*       | "initialized" -> Initialized _ *)
  (*       | _ -> failwith "Event" *)
  (*   in *)
  (*   let open Data_encoding in *)
  (*   conv f g string *)
end

module Command = struct
  type disassemble
  type writememory
  type readmemory
  type exceptioninfo
  type completions
  type gototargets
  type stepintargets
  type setexpression
  type evaluate
  type loadedsources
  type modules
  type terminatethreads
  type threads
  type source
  type setvariable
  type variables
  type scopes
  type stacktrace
  type pause
  type goto
  type restartframe
  type reversecontinue
  type stepback
  type stepout
  type stepin
  type next
  type continue
  type setinstructionbreakpoints
  type setdatabreakpoints
  type databreakpointinfo
  type setexceptionbreakpoints
  type setfunctionbreakpoints
  type setbreakpoints
  type breakpointlocations
  type terminate
  type disconnect
  type restart
  type attach
  type launch
  type configurationdone
  type initialize
  type runinterminal
  type cancel
  type error

  type t =
    | Disassemble : disassemble -> t
    | WriteMemory : writememory -> t
    | ReadMemory : readmemory -> t
    | ExceptionInfo : exceptioninfo -> t
    | Completions : completions -> t
    | GotoTargets : gototargets -> t
    | StepInTargets : stepintargets -> t
    | SetExpression : setexpression -> t
    | Evaluate : evaluate -> t
    | LoadedSources : loadedsources -> t
    | Modules : modules -> t
    | TerminateThreads : terminatethreads -> t
    | Threads : threads -> t
    | Source : source -> t
    | SetVariable : setvariable -> t
    | Variables : variables -> t
    | Scopes : scopes -> t
    | StackTrace : stacktrace -> t
    | Pause : pause -> t
    | Goto : goto -> t
    | RestartFrame : restartframe -> t
    | ReverseContinue : reversecontinue -> t
    | StepBack : stepback -> t
    | StepOut : stepout -> t
    | StepIn : stepin -> t
    | Next : next -> t
    | Continue : continue -> t
    | SetInstructionBreakpoints : setinstructionbreakpoints -> t
    | SetDataBreakpoints : setdatabreakpoints -> t
    | DataBreakpointInfo : databreakpointinfo -> t
    | SetExceptionBreakpoints : setexceptionbreakpoints -> t
    | SetFunctionBreakpoints : setfunctionbreakpoints -> t
    | SetBreakpoints : setbreakpoints -> t
    | BreakpointLocations : breakpointlocations -> t
    | Terminate : terminate -> t
    | Disconnect : disconnect -> t
    | Restart : restart -> t
    | Attach : attach -> t
    | Launch : launch -> t
    | ConfigurationDone : configurationdone -> t
    | Initialize : initialize -> t
    | RunInTerminal : runinterminal -> t
    | Cancel : cancel -> t 
    | Error : error -> t

  (* let enc = *)
  (*   let f : t -> string = function *)
  (*       | Disassemble _ -> "disassemble" *)
  (*       | WriteMemory _ -> "writeMemory" *)
  (*       | ReadMemory _ -> "readMemory" *)
  (*       | ExceptionInfo _ -> "exceptionInfo" *)
  (*       | Completions _ -> "completions" *)
  (*       | GotoTargets _ -> "gotoTargets" *)
  (*       | StepInTargets _ -> "stepInTargets" *)
  (*       | SetExpression _ -> "setExpression" *)
  (*       | Evaluate _ -> "evaluate" *)
  (*       | LoadedSources _ -> "loadedSources" *)
  (*       | Modules _ -> "modules" *)
  (*       | TerminateThreads _ -> "terminateThreads" *)
  (*       | Threads _ -> "threads" *)
  (*       | Source _ -> "source" *)
  (*       | SetVariable _ -> "setVariable" *)
  (*       | Variables _ -> "variables" *)
  (*       | Scopes _ -> "scopes" *)
  (*       | StackTrace _ -> "stackTrace" *)
  (*       | Pause _ -> "pause" *)
  (*       | Goto _ -> "goto" *)
  (*       | RestartFrame _ -> "restartFrame" *)
  (*       | ReverseContinue _ -> "reverseContinue" *)
  (*       | StepBack _ -> "stepBack" *)
  (*       | StepOut _ -> "stepOut" *)
  (*       | StepIn _ -> "stepIn" *)
  (*       | Next _ -> "next" *)
  (*       | Continue _ -> "continue" *)
  (*       | SetInstructionBreakpoints _ -> "setInstructionBreakpoints" *)
  (*       | SetDataBreakpoints _ -> "setDataBreakpoints" *)
  (*       | DataBreakpointInfo _ -> "dataBreakpointInfo" *)
  (*       | SetExceptionBreakpoints _ -> "setExceptionBreakpoints" *)
  (*       | SetFunctionBreakpoints _ -> "setFunctionBreakpoints" *)
  (*       | SetBreakpoints _ -> "setBreakpoints" *)
  (*       | BreakpointLocations _ -> "breakpointLocations" *)
  (*       | Terminate _ -> "terminate" *)
  (*       | Disconnect _ -> "disconnect" *)
  (*       | Restart _ -> "restart" *)
  (*       | Attach _ -> "attach" *)
  (*       | Launch _ -> "launch" *)
  (*       | ConfigurationDone _ -> "configurationDone" *)
  (*       | Initialize _ -> "initialize" *)
  (*       | RunInTerminal _ -> "runInTerminal" *)
  (*       | Cancel _ -> "cancel" *)
  (*       | Error _ -> "error" *)
  (*   in *)
  (*   let g : string -> t = function *)
  (*       | "disassemble" -> Disassemble _ *)
  (*       | "writeMemory" -> WriteMemory _ *)
  (*       | "readMemory" -> ReadMemory _ *)
  (*       | "exceptionInfo" -> ExceptionInfo _ *)
  (*       | "completions" -> Completions _ *)
  (*       | "gotoTargets" -> GotoTargets _ *)
  (*       | "stepInTargets" -> StepInTargets _ *)
  (*       | "setExpression" -> SetExpression _ *)
  (*       | "evaluate" -> Evaluate _ *)
  (*       | "loadedSources" -> LoadedSources _ *)
  (*       | "modules" -> Modules _ *)
  (*       | "terminateThreads" -> TerminateThreads _ *)
  (*       | "threads" -> Threads _ *)
  (*       | "source" -> Source _ *)
  (*       | "setVariable" -> SetVariable _ *)
  (*       | "variables" -> Variables _ *)
  (*       | "scopes" -> Scopes _ *)
  (*       | "stackTrace" -> StackTrace _ *)
  (*       | "pause" -> Pause _ *)
  (*       | "goto" -> Goto _ *)
  (*       | "restartFrame" -> RestartFrame _ *)
  (*       | "reverseContinue" -> ReverseContinue _ *)
  (*       | "stepBack" -> StepBack _ *)
  (*       | "stepOut" -> StepOut _ *)
  (*       | "stepIn" -> StepIn _ *)
  (*       | "next" -> Next _ *)
  (*       | "continue" -> Continue _ *)
  (*       | "setInstructionBreakpoints" -> SetInstructionBreakpoints _ *)
  (*       | "setDataBreakpoints" -> SetDataBreakpoints _ *)
  (*       | "dataBreakpointInfo" -> DataBreakpointInfo _ *)
  (*       | "setExceptionBreakpoints" -> SetExceptionBreakpoints _ *)
  (*       | "setFunctionBreakpoints" -> SetFunctionBreakpoints _ *)
  (*       | "setBreakpoints" -> SetBreakpoints _ *)
  (*       | "breakpointLocations" -> BreakpointLocations _ *)
  (*       | "terminate" -> Terminate _ *)
  (*       | "disconnect" -> Disconnect _ *)
  (*       | "restart" -> Restart _ *)
  (*       | "attach" -> Attach _ *)
  (*       | "launch" -> Launch _ *)
  (*       | "configurationDone" -> ConfigurationDone _ *)
  (*       | "initialize" -> Initialize _ *)
  (*       | "runInTerminal" -> RunInTerminal _ *)
  (*       | "cancel" -> Cancel _ *)
  (*       | "error" -> Error _ *)
  (*       | _ -> failwith "Command" in *)
  (*   let open Data_encoding in *)
  (*   conv f g string *)

end


module Message = struct
  type t = {
    id : int;
    format : string;
    variables : Data_encoding.json option;
    sendTelemetry : bool option;
    showUser : bool option;
    url : string option;
    urlLabel : string option;
  }

  let enc =
    let open Data_encoding in
    (* Message.t *)
    conv
      (fun {id; format; variables; sendTelemetry; showUser; url; urlLabel} ->
        (id, format, variables, sendTelemetry, showUser, url, urlLabel))
      (fun (id, format, variables, sendTelemetry, showUser, url, urlLabel) ->
        {id; format; variables; sendTelemetry; showUser; url; urlLabel})
      (obj7
         (req "id" int31)
         (req "format" string)
         (opt "variables" json)
         (opt "sendTelemetry" bool)
         (opt "showUser" bool)
         (opt "url" string)
         (opt "urlLabel" string))

  let make ~id ~format ?variables ?sendTelemetry ?showUser ?url ?urlLabel () =
    {id; format; variables; sendTelemetry; showUser; url; urlLabel}
end

module ErrorResponse_body = struct
  type t = {error : Message.t option}

  let enc =
    let open Data_encoding in
    (* ErrorResponse_body.t *)
    conv
      (fun {error} -> error)
      (fun error -> {error})
      (obj1 (opt "error" Message.enc))

  let make ?error () = {error}
end


module CancelArguments = struct
  type t = {requestId : int option; progressId : string option}

  let enc =
    let open Data_encoding in
    (* CancelArguments.t *)
    conv
      (fun {requestId; progressId} -> (requestId, progressId))
      (fun (requestId, progressId) -> {requestId; progressId})
      (obj2 (opt "requestId" int31) (opt "progressId" string))

  let make ?requestId ?progressId () = {requestId; progressId}
end

module StoppedEvent_body_reason = struct
  type t =
    | Step
    | Breakpoint
    | Exception
    | Pause
    | Entry
    | Goto
    | Function_breakpoint
    | Data_breakpoint
    | Instruction_breakpoint
    | Other of string

  let enc =
    let open Data_encoding in
    conv
      (function
        | Step -> "step"
        | Breakpoint -> "breakpoint"
        | Exception -> "exception"
        | Pause -> "pause"
        | Entry -> "entry"
        | Goto -> "goto"
        | Function_breakpoint -> "function breakpoint"
        | Data_breakpoint -> "data breakpoint"
        | Instruction_breakpoint -> "instruction breakpoint"
        | Other s -> s)
      (function
        | "step" -> Step
        | "breakpoint" -> Breakpoint
        | "exception" -> Exception
        | "pause" -> Pause
        | "entry" -> Entry
        | "goto" -> Goto
        | "function breakpoint" -> Function_breakpoint
        | "data breakpoint" -> Data_breakpoint
        | "instruction breakpoint" -> Instruction_breakpoint
        | _ as s -> Other s)
      string
end

module StoppedEvent_body = struct
  type t = {
    reason : StoppedEvent_body_reason.t;
    description : string option;
    threadId : int option;
    preserveFocusHint : bool option;
    text : string option;
    allThreadsStopped : bool option;
    hitBreakpointIds : int list option;
  }

  let enc =
    let open Data_encoding in
    (* StoppedEvent_body.t *)
    conv
      (fun {
             reason;
             description;
             threadId;
             preserveFocusHint;
             text;
             allThreadsStopped;
             hitBreakpointIds;
           } ->
        ( reason,
          description,
          threadId,
          preserveFocusHint,
          text,
          allThreadsStopped,
          hitBreakpointIds ))
      (fun ( reason,
             description,
             threadId,
             preserveFocusHint,
             text,
             allThreadsStopped,
             hitBreakpointIds ) ->
        {
          reason;
          description;
          threadId;
          preserveFocusHint;
          text;
          allThreadsStopped;
          hitBreakpointIds;
        })
      (obj7
         (req "reason" StoppedEvent_body_reason.enc)
         (opt "description" string)
         (opt "threadId" int31)
         (opt "preserveFocusHint" bool)
         (opt "text" string)
         (opt "allThreadsStopped" bool)
         (opt "hitBreakpointIds" (list int31)))

  let make ~reason ?description ?threadId ?preserveFocusHint ?text
      ?allThreadsStopped ?hitBreakpointIds () =
    {
      reason;
      description;
      threadId;
      preserveFocusHint;
      text;
      allThreadsStopped;
      hitBreakpointIds;
    }
end

module ContinuedEvent_body = struct
  type t = {threadId : int; allThreadsContinued : bool option}

  let enc =
    let open Data_encoding in
    (* ContinuedEvent_body.t *)
    conv
      (fun {threadId; allThreadsContinued} -> (threadId, allThreadsContinued))
      (fun (threadId, allThreadsContinued) -> {threadId; allThreadsContinued})
      (obj2 (req "threadId" int31) (opt "allThreadsContinued" bool))

  let make ~threadId ?allThreadsContinued () = {threadId; allThreadsContinued}
end

module ExitedEvent_body = struct
  type t = {exitCode : int}

  let enc =
    let open Data_encoding in
    (* ExitedEvent_body.t *)
    conv
      (fun {exitCode} -> exitCode)
      (fun exitCode -> {exitCode})
      (obj1 (req "exitCode" int31))

  let make ~exitCode () = {exitCode}
end

module TerminatedEvent_body = struct
  type t = {restart : Data_encoding.json option}

  let enc =
    let open Data_encoding in
    (* TerminatedEvent_body.t *)
    conv
      (fun {restart} -> restart)
      (fun restart -> {restart})
      (obj1 (opt "restart" json))

  let make ?restart () = {restart}
end

module ThreadEvent_body_reason = struct
  type t = Started | Exited | Other of string

  let enc =
    let open Data_encoding in
    conv
      (function Started -> "started" | Exited -> "exited" | Other s -> s)
      (function "started" -> Started | "exited" -> Exited | _ as s -> Other s)
      string
end

module ThreadEvent_body = struct
  type t = {reason : ThreadEvent_body_reason.t; threadId : int}

  let enc =
    let open Data_encoding in
    (* ThreadEvent_body.t *)
    conv
      (fun {reason; threadId} -> (reason, threadId))
      (fun (reason, threadId) -> {reason; threadId})
      (obj2 (req "reason" ThreadEvent_body_reason.enc) (req "threadId" int31))

  let make ~reason ~threadId () = {reason; threadId}
end


module OutputEvent_body_category = struct
  type t = Console | Important | Stdout | Stderr | Telemetry | Other of string

  let enc =
    let open Data_encoding in
    conv
      (function
        | Console -> "console"
        | Important -> "important"
        | Stdout -> "stdout"
        | Stderr -> "stderr"
        | Telemetry -> "telemetry"
        | Other s -> s)
      (function
        | "console" -> Console
        | "important" -> Important
        | "stdout" -> Stdout
        | "stderr" -> Stderr
        | "telemetry" -> Telemetry
        | _ as s -> Other s)
      string
end

module OutputEvent_body_group = struct
  type t = Start | StartCollapsed | End

  let enc =
    let open Data_encoding in
    conv
      (function
        | Start -> "start" | StartCollapsed -> "startCollapsed" | End -> "end")
      (function
        | "start" -> Start
        | "startCollapsed" -> StartCollapsed
        | "end" -> End
        | _ -> failwith "OutputEvent_body_group")
      string
end

module Source_presentationHint = struct
  type t = Normal | Emphasize | Deemphasize

  let enc =
    let open Data_encoding in
    conv
      (function
        | Normal -> "normal"
        | Emphasize -> "emphasize"
        | Deemphasize -> "deemphasize")
      (function
        | "normal" -> Normal
        | "emphasize" -> Emphasize
        | "deemphasize" -> Deemphasize
        | _ -> failwith "Source_presentationHint")
      string
end

module ChecksumAlgorithm = struct
  type t = MD5 | SHA1 | SHA256 | Timestamp

  let enc =
    let open Data_encoding in
    conv
      (function
        | MD5 -> "MD5"
        | SHA1 -> "SHA1"
        | SHA256 -> "SHA256"
        | Timestamp -> "timestamp")
      (function
        | "MD5" -> MD5
        | "SHA1" -> SHA1
        | "SHA256" -> SHA256
        | "timestamp" -> Timestamp
        | _ -> failwith "ChecksumAlgorithm")
      string
end

module Checksum = struct
  type t = {algorithm : ChecksumAlgorithm.t; checksum : string}

  let enc =
    let open Data_encoding in
    (* Checksum.t *)
    conv
      (fun {algorithm; checksum} -> (algorithm, checksum))
      (fun (algorithm, checksum) -> {algorithm; checksum})
      (obj2 (req "algorithm" ChecksumAlgorithm.enc) (req "checksum" string))

  let make ~algorithm ~checksum () = {algorithm; checksum}
end

module Source = struct
  type t = {
    name : string option;
    path : string option;
    sourceReference : int option;
    presentationHint : Source_presentationHint.t option;
    origin : string option;
    sources : t list option;
    adapterData : Data_encoding.json option;
    checksums : Checksum.t list option;
  }

  let enc =
    let open Data_encoding in
    mu "Source.t" (fun e ->
        conv
          (fun {
                 name;
                 path;
                 sourceReference;
                 presentationHint;
                 origin;
                 sources;
                 adapterData;
                 checksums;
               } ->
            ( name,
              path,
              sourceReference,
              presentationHint,
              origin,
              sources,
              adapterData,
              checksums ))
          (fun ( name,
                 path,
                 sourceReference,
                 presentationHint,
                 origin,
                 sources,
                 adapterData,
                 checksums ) ->
            {
              name;
              path;
              sourceReference;
              presentationHint;
              origin;
              sources;
              adapterData;
              checksums;
            })
          (obj8
             (opt "name" string)
             (opt "path" string)
             (opt "sourceReference" int31)
             (opt "presentationHint" Source_presentationHint.enc)
             (opt "origin" string)
             (opt "sources" (list e))
             (opt "adapterData" json)
             (opt "checksums" (list Checksum.enc))))

  let make ?name ?path ?sourceReference ?presentationHint ?origin ?sources
      ?adapterData ?checksums () =
    {
      name;
      path;
      sourceReference;
      presentationHint;
      origin;
      sources;
      adapterData;
      checksums;
    }
end

module OutputEvent_body = struct
  type t = {
    category : OutputEvent_body_category.t option;
    output : string;
    group : OutputEvent_body_group.t option;
    variablesReference : int option;
    source : Source.t option;
    line : int option;
    column : int option;
    data : Data_encoding.json option;
  }

  let enc =
    let open Data_encoding in
    (* OutputEvent_body.t *)
    conv
      (fun {
             category;
             output;
             group;
             variablesReference;
             source;
             line;
             column;
             data;
           } ->
        (category, output, group, variablesReference, source, line, column, data))
      (fun ( category,
             output,
             group,
             variablesReference,
             source,
             line,
             column,
             data ) ->
        {
          category;
          output;
          group;
          variablesReference;
          source;
          line;
          column;
          data;
        })
      (obj8
         (opt "category" OutputEvent_body_category.enc)
         (req "output" string)
         (opt "group" OutputEvent_body_group.enc)
         (opt "variablesReference" int31)
         (opt "source" Source.enc)
         (opt "line" int31)
         (opt "column" int31)
         (opt "data" json))

  let make ?category ~output ?group ?variablesReference ?source ?line ?column
      ?data () =
    {category; output; group; variablesReference; source; line; column; data}
end

module BreakpointEvent_body_reason = struct
  type t = Changed | New | Removed | Other of string

  let enc =
    let open Data_encoding in
    conv
      (function
        | Changed -> "changed"
        | New -> "new"
        | Removed -> "removed"
        | Other s -> s)
      (function
        | "changed" -> Changed
        | "new" -> New
        | "removed" -> Removed
        | _ as s -> Other s)
      string
end

module Breakpoint = struct
  type t = {
    id : int option;
    verified : bool;
    message : string option;
    source : Source.t option;
    line : int option;
    column : int option;
    endLine : int option;
    endColumn : int option;
    instructionReference : string option;
    offset : int option;
  }

  let enc =
    let open Data_encoding in
    (* Breakpoint.t *)
    conv
      (fun {
             id;
             verified;
             message;
             source;
             line;
             column;
             endLine;
             endColumn;
             instructionReference;
             offset;
           } ->
        ( id,
          verified,
          message,
          source,
          line,
          column,
          endLine,
          endColumn,
          instructionReference,
          offset ))
      (fun ( id,
             verified,
             message,
             source,
             line,
             column,
             endLine,
             endColumn,
             instructionReference,
             offset ) ->
        {
          id;
          verified;
          message;
          source;
          line;
          column;
          endLine;
          endColumn;
          instructionReference;
          offset;
        })
      (obj10
         (opt "id" int31)
         (req "verified" bool)
         (opt "message" string)
         (opt "source" Source.enc)
         (opt "line" int31)
         (opt "column" int31)
         (opt "endLine" int31)
         (opt "endColumn" int31)
         (opt "instructionReference" string)
         (opt "offset" int31))

  let make ?id ~verified ?message ?source ?line ?column ?endLine ?endColumn
      ?instructionReference ?offset () =
    {
      id;
      verified;
      message;
      source;
      line;
      column;
      endLine;
      endColumn;
      instructionReference;
      offset;
    }
end

module BreakpointEvent_body = struct
  type t = {reason : BreakpointEvent_body_reason.t; breakpoint : Breakpoint.t}

  let enc =
    let open Data_encoding in
    (* BreakpointEvent_body.t *)
    conv
      (fun {reason; breakpoint} -> (reason, breakpoint))
      (fun (reason, breakpoint) -> {reason; breakpoint})
      (obj2
         (req "reason" BreakpointEvent_body_reason.enc)
         (req "breakpoint" Breakpoint.enc))

  let make ~reason ~breakpoint () = {reason; breakpoint}
end

module ModuleEvent_body_reason = struct
  type t = New | Changed | Removed

  let enc =
    let open Data_encoding in
    conv
      (function New -> "new" | Changed -> "changed" | Removed -> "removed")
      (function
        | "new" -> New
        | "changed" -> Changed
        | "removed" -> Removed
        | _ -> failwith "ModuleEvent_body_reason")
      string
end

module Module_ = struct
  type t = {
    id : IntString.t;
    name : string;
    path : string option;
    isOptimized : bool option;
    isUserCode : bool option;
    version : string option;
    symbolStatus : string option;
    symbolFilePath : string option;
    dateTimeStamp : string option;
    addressRange : string option;
  }

  let enc =
    let open Data_encoding in
    (* Module_.t *)
    conv
      (fun {
             id;
             name;
             path;
             isOptimized;
             isUserCode;
             version;
             symbolStatus;
             symbolFilePath;
             dateTimeStamp;
             addressRange;
           } ->
        ( id,
          name,
          path,
          isOptimized,
          isUserCode,
          version,
          symbolStatus,
          symbolFilePath,
          dateTimeStamp,
          addressRange ))
      (fun ( id,
             name,
             path,
             isOptimized,
             isUserCode,
             version,
             symbolStatus,
             symbolFilePath,
             dateTimeStamp,
             addressRange ) ->
        {
          id;
          name;
          path;
          isOptimized;
          isUserCode;
          version;
          symbolStatus;
          symbolFilePath;
          dateTimeStamp;
          addressRange;
        })
      (obj10
         (req "id" IntString.enc)
         (req "name" string)
         (opt "path" string)
         (opt "isOptimized" bool)
         (opt "isUserCode" bool)
         (opt "version" string)
         (opt "symbolStatus" string)
         (opt "symbolFilePath" string)
         (opt "dateTimeStamp" string)
         (opt "addressRange" string))

  let make ~id ~name ?path ?isOptimized ?isUserCode ?version ?symbolStatus
      ?symbolFilePath ?dateTimeStamp ?addressRange () =
    {
      id;
      name;
      path;
      isOptimized;
      isUserCode;
      version;
      symbolStatus;
      symbolFilePath;
      dateTimeStamp;
      addressRange;
    }
end

module ModuleEvent_body = struct
  type t = {reason : ModuleEvent_body_reason.t; module_ : Module_.t}

  let enc =
    let open Data_encoding in
    (* ModuleEvent_body.t *)
    conv
      (fun {reason; module_} -> (reason, module_))
      (fun (reason, module_) -> {reason; module_})
      (obj2
         (req "reason" ModuleEvent_body_reason.enc)
         (req "module" Module_.enc))

  let make ~reason ~module_ () = {reason; module_}
end

module LoadedSourceEvent_body_reason = struct
  type t = New | Changed | Removed

  let enc =
    let open Data_encoding in
    conv
      (function New -> "new" | Changed -> "changed" | Removed -> "removed")
      (function
        | "new" -> New
        | "changed" -> Changed
        | "removed" -> Removed
        | _ -> failwith "LoadedSourceEvent_body_reason")
      string
end

module LoadedSourceEvent_body = struct
  type t = {reason : LoadedSourceEvent_body_reason.t; source : Source.t}

  let enc =
    let open Data_encoding in
    (* LoadedSourceEvent_body.t *)
    conv
      (fun {reason; source} -> (reason, source))
      (fun (reason, source) -> {reason; source})
      (obj2
         (req "reason" LoadedSourceEvent_body_reason.enc)
         (req "source" Source.enc))

  let make ~reason ~source () = {reason; source}
end

module ProcessEvent_body_startMethod = struct
  type t = Launch | Attach | AttachForSuspendedLaunch

  let enc =
    let open Data_encoding in
    conv
      (function
        | Launch -> "launch"
        | Attach -> "attach"
        | AttachForSuspendedLaunch -> "attachForSuspendedLaunch")
      (function
        | "launch" -> Launch
        | "attach" -> Attach
        | "attachForSuspendedLaunch" -> AttachForSuspendedLaunch
        | _ -> failwith "ProcessEvent_body_startMethod")
      string
end

module ProcessEvent_body = struct
  type t = {
    name : string;
    systemProcessId : int option;
    isLocalProcess : bool option;
    startMethod : ProcessEvent_body_startMethod.t option;
    pointerSize : int option;
  }

  let enc =
    let open Data_encoding in
    (* ProcessEvent_body.t *)
    conv
      (fun {name; systemProcessId; isLocalProcess; startMethod; pointerSize} ->
        (name, systemProcessId, isLocalProcess, startMethod, pointerSize))
      (fun (name, systemProcessId, isLocalProcess, startMethod, pointerSize) ->
        {name; systemProcessId; isLocalProcess; startMethod; pointerSize})
      (obj5
         (req "name" string)
         (opt "systemProcessId" int31)
         (opt "isLocalProcess" bool)
         (opt "startMethod" ProcessEvent_body_startMethod.enc)
         (opt "pointerSize" int31))

  let make ~name ?systemProcessId ?isLocalProcess ?startMethod ?pointerSize () =
    {name; systemProcessId; isLocalProcess; startMethod; pointerSize}
end


module ExceptionBreakpointsFilter = struct
  type t = {
    filter : string;
    label : string;
    description : string option;
    default : bool option;
    supportsCondition : bool option;
    conditionDescription : string option;
  }

  let enc =
    let open Data_encoding in
    (* ExceptionBreakpointsFilter.t *)
    conv
      (fun {
             filter;
             label;
             description;
             default;
             supportsCondition;
             conditionDescription;
           } ->
        ( filter,
          label,
          description,
          default,
          supportsCondition,
          conditionDescription ))
      (fun ( filter,
             label,
             description,
             default,
             supportsCondition,
             conditionDescription ) ->
        {
          filter;
          label;
          description;
          default;
          supportsCondition;
          conditionDescription;
        })
      (obj6
         (req "filter" string)
         (req "label" string)
         (opt "description" string)
         (opt "default" bool)
         (opt "supportsCondition" bool)
         (opt "conditionDescription" string))

  let make ~filter ~label ?description ?default ?supportsCondition
      ?conditionDescription () =
    {
      filter;
      label;
      description;
      default;
      supportsCondition;
      conditionDescription;
    }
end

module ColumnDescriptor_type_ = struct
  type t = String | Number | Boolean | UnixTimestampUTC

  let enc =
    let open Data_encoding in
    conv
      (function
        | String -> "string"
        | Number -> "number"
        | Boolean -> "boolean"
        | UnixTimestampUTC -> "unixTimestampUTC")
      (function
        | "string" -> String
        | "number" -> Number
        | "boolean" -> Boolean
        | "unixTimestampUTC" -> UnixTimestampUTC
        | _ -> failwith "ColumnDescriptor_type_")
      string
end

module ColumnDescriptor = struct
  type t = {
    attributeName : string;
    label : string;
    format : string option;
    type_ : ColumnDescriptor_type_.t option;
    width : int option;
  }

  let enc =
    let open Data_encoding in
    (* ColumnDescriptor.t *)
    conv
      (fun {attributeName; label; format; type_; width} ->
        (attributeName, label, format, type_, width))
      (fun (attributeName, label, format, type_, width) ->
        {attributeName; label; format; type_; width})
      (obj5
         (req "attributeName" string)
         (req "label" string)
         (opt "format" string)
         (opt "type" ColumnDescriptor_type_.enc)
         (opt "width" int31))

  let make ~attributeName ~label ?format ?type_ ?width () =
    {attributeName; label; format; type_; width}
end

module Capabilities = struct
  module Capabilities_0 = struct
    type t = {
      supportsConfigurationDoneRequest : bool option;
      supportsFunctionBreakpoints : bool option;
      supportsConditionalBreakpoints : bool option;
      supportsHitConditionalBreakpoints : bool option;
      supportsEvaluateForHovers : bool option;
      exceptionBreakpointFilters : ExceptionBreakpointsFilter.t list option;
      supportsStepBack : bool option;
      supportsSetVariable : bool option;
      supportsRestartFrame : bool option;
      supportsGotoTargetsRequest : bool option;
    }

    let enc =
      let open Data_encoding in
      (* Capabilities_0.t *)
      conv
        (fun {
               supportsConfigurationDoneRequest;
               supportsFunctionBreakpoints;
               supportsConditionalBreakpoints;
               supportsHitConditionalBreakpoints;
               supportsEvaluateForHovers;
               exceptionBreakpointFilters;
               supportsStepBack;
               supportsSetVariable;
               supportsRestartFrame;
               supportsGotoTargetsRequest;
             } ->
          ( supportsConfigurationDoneRequest,
            supportsFunctionBreakpoints,
            supportsConditionalBreakpoints,
            supportsHitConditionalBreakpoints,
            supportsEvaluateForHovers,
            exceptionBreakpointFilters,
            supportsStepBack,
            supportsSetVariable,
            supportsRestartFrame,
            supportsGotoTargetsRequest ))
        (fun ( supportsConfigurationDoneRequest,
               supportsFunctionBreakpoints,
               supportsConditionalBreakpoints,
               supportsHitConditionalBreakpoints,
               supportsEvaluateForHovers,
               exceptionBreakpointFilters,
               supportsStepBack,
               supportsSetVariable,
               supportsRestartFrame,
               supportsGotoTargetsRequest ) ->
          {
            supportsConfigurationDoneRequest;
            supportsFunctionBreakpoints;
            supportsConditionalBreakpoints;
            supportsHitConditionalBreakpoints;
            supportsEvaluateForHovers;
            exceptionBreakpointFilters;
            supportsStepBack;
            supportsSetVariable;
            supportsRestartFrame;
            supportsGotoTargetsRequest;
          })
        (obj10
           (opt "supportsConfigurationDoneRequest" bool)
           (opt "supportsFunctionBreakpoints" bool)
           (opt "supportsConditionalBreakpoints" bool)
           (opt "supportsHitConditionalBreakpoints" bool)
           (opt "supportsEvaluateForHovers" bool)
           (opt
              "exceptionBreakpointFilters"
              (list ExceptionBreakpointsFilter.enc))
           (opt "supportsStepBack" bool)
           (opt "supportsSetVariable" bool)
           (opt "supportsRestartFrame" bool)
           (opt "supportsGotoTargetsRequest" bool))

    let make ?supportsConfigurationDoneRequest ?supportsFunctionBreakpoints
        ?supportsConditionalBreakpoints ?supportsHitConditionalBreakpoints
        ?supportsEvaluateForHovers ?exceptionBreakpointFilters ?supportsStepBack
        ?supportsSetVariable ?supportsRestartFrame ?supportsGotoTargetsRequest
        () =
      {
        supportsConfigurationDoneRequest;
        supportsFunctionBreakpoints;
        supportsConditionalBreakpoints;
        supportsHitConditionalBreakpoints;
        supportsEvaluateForHovers;
        exceptionBreakpointFilters;
        supportsStepBack;
        supportsSetVariable;
        supportsRestartFrame;
        supportsGotoTargetsRequest;
      }
  end

  module Capabilities_10 = struct
    type t = {
      supportsStepInTargetsRequest : bool option;
      supportsCompletionsRequest : bool option;
      completionTriggerCharacters : string list option;
      supportsModulesRequest : bool option;
      additionalModuleColumns : ColumnDescriptor.t list option;
      supportedChecksumAlgorithms : ChecksumAlgorithm.t list option;
      supportsRestartRequest : bool option;
      supportsExceptionOptions : bool option;
      supportsValueFormattingOptions : bool option;
      supportsExceptionInfoRequest : bool option;
    }

    let enc =
      let open Data_encoding in
      (* Capabilities_10.t *)
      conv
        (fun {
               supportsStepInTargetsRequest;
               supportsCompletionsRequest;
               completionTriggerCharacters;
               supportsModulesRequest;
               additionalModuleColumns;
               supportedChecksumAlgorithms;
               supportsRestartRequest;
               supportsExceptionOptions;
               supportsValueFormattingOptions;
               supportsExceptionInfoRequest;
             } ->
          ( supportsStepInTargetsRequest,
            supportsCompletionsRequest,
            completionTriggerCharacters,
            supportsModulesRequest,
            additionalModuleColumns,
            supportedChecksumAlgorithms,
            supportsRestartRequest,
            supportsExceptionOptions,
            supportsValueFormattingOptions,
            supportsExceptionInfoRequest ))
        (fun ( supportsStepInTargetsRequest,
               supportsCompletionsRequest,
               completionTriggerCharacters,
               supportsModulesRequest,
               additionalModuleColumns,
               supportedChecksumAlgorithms,
               supportsRestartRequest,
               supportsExceptionOptions,
               supportsValueFormattingOptions,
               supportsExceptionInfoRequest ) ->
          {
            supportsStepInTargetsRequest;
            supportsCompletionsRequest;
            completionTriggerCharacters;
            supportsModulesRequest;
            additionalModuleColumns;
            supportedChecksumAlgorithms;
            supportsRestartRequest;
            supportsExceptionOptions;
            supportsValueFormattingOptions;
            supportsExceptionInfoRequest;
          })
        (obj10
           (opt "supportsStepInTargetsRequest" bool)
           (opt "supportsCompletionsRequest" bool)
           (opt "completionTriggerCharacters" (list string))
           (opt "supportsModulesRequest" bool)
           (opt "additionalModuleColumns" (list ColumnDescriptor.enc))
           (opt "supportedChecksumAlgorithms" (list ChecksumAlgorithm.enc))
           (opt "supportsRestartRequest" bool)
           (opt "supportsExceptionOptions" bool)
           (opt "supportsValueFormattingOptions" bool)
           (opt "supportsExceptionInfoRequest" bool))

    let make ?supportsStepInTargetsRequest ?supportsCompletionsRequest
        ?completionTriggerCharacters ?supportsModulesRequest
        ?additionalModuleColumns ?supportedChecksumAlgorithms
        ?supportsRestartRequest ?supportsExceptionOptions
        ?supportsValueFormattingOptions ?supportsExceptionInfoRequest () =
      {
        supportsStepInTargetsRequest;
        supportsCompletionsRequest;
        completionTriggerCharacters;
        supportsModulesRequest;
        additionalModuleColumns;
        supportedChecksumAlgorithms;
        supportsRestartRequest;
        supportsExceptionOptions;
        supportsValueFormattingOptions;
        supportsExceptionInfoRequest;
      }
  end

  module Capabilities_20 = struct
    type t = {
      supportTerminateDebuggee : bool option;
      supportSuspendDebuggee : bool option;
      supportsDelayedStackTraceLoading : bool option;
      supportsLoadedSourcesRequest : bool option;
      supportsLogPoints : bool option;
      supportsTerminateThreadsRequest : bool option;
      supportsSetExpression : bool option;
      supportsTerminateRequest : bool option;
      supportsDataBreakpoints : bool option;
      supportsReadMemoryRequest : bool option;
    }

    let enc =
      let open Data_encoding in
      (* Capabilities_20.t *)
      conv
        (fun {
               supportTerminateDebuggee;
               supportSuspendDebuggee;
               supportsDelayedStackTraceLoading;
               supportsLoadedSourcesRequest;
               supportsLogPoints;
               supportsTerminateThreadsRequest;
               supportsSetExpression;
               supportsTerminateRequest;
               supportsDataBreakpoints;
               supportsReadMemoryRequest;
             } ->
          ( supportTerminateDebuggee,
            supportSuspendDebuggee,
            supportsDelayedStackTraceLoading,
            supportsLoadedSourcesRequest,
            supportsLogPoints,
            supportsTerminateThreadsRequest,
            supportsSetExpression,
            supportsTerminateRequest,
            supportsDataBreakpoints,
            supportsReadMemoryRequest ))
        (fun ( supportTerminateDebuggee,
               supportSuspendDebuggee,
               supportsDelayedStackTraceLoading,
               supportsLoadedSourcesRequest,
               supportsLogPoints,
               supportsTerminateThreadsRequest,
               supportsSetExpression,
               supportsTerminateRequest,
               supportsDataBreakpoints,
               supportsReadMemoryRequest ) ->
          {
            supportTerminateDebuggee;
            supportSuspendDebuggee;
            supportsDelayedStackTraceLoading;
            supportsLoadedSourcesRequest;
            supportsLogPoints;
            supportsTerminateThreadsRequest;
            supportsSetExpression;
            supportsTerminateRequest;
            supportsDataBreakpoints;
            supportsReadMemoryRequest;
          })
        (obj10
           (opt "supportTerminateDebuggee" bool)
           (opt "supportSuspendDebuggee" bool)
           (opt "supportsDelayedStackTraceLoading" bool)
           (opt "supportsLoadedSourcesRequest" bool)
           (opt "supportsLogPoints" bool)
           (opt "supportsTerminateThreadsRequest" bool)
           (opt "supportsSetExpression" bool)
           (opt "supportsTerminateRequest" bool)
           (opt "supportsDataBreakpoints" bool)
           (opt "supportsReadMemoryRequest" bool))

    let make ?supportTerminateDebuggee ?supportSuspendDebuggee
        ?supportsDelayedStackTraceLoading ?supportsLoadedSourcesRequest
        ?supportsLogPoints ?supportsTerminateThreadsRequest
        ?supportsSetExpression ?supportsTerminateRequest
        ?supportsDataBreakpoints ?supportsReadMemoryRequest () =
      {
        supportTerminateDebuggee;
        supportSuspendDebuggee;
        supportsDelayedStackTraceLoading;
        supportsLoadedSourcesRequest;
        supportsLogPoints;
        supportsTerminateThreadsRequest;
        supportsSetExpression;
        supportsTerminateRequest;
        supportsDataBreakpoints;
        supportsReadMemoryRequest;
      }
  end

  module Capabilities_30 = struct
    type t = {
      supportsWriteMemoryRequest : bool option;
      supportsDisassembleRequest : bool option;
      supportsCancelRequest : bool option;
      supportsBreakpointLocationsRequest : bool option;
      supportsClipboardContext : bool option;
      supportsSteppingGranularity : bool option;
      supportsInstructionBreakpoints : bool option;
      supportsExceptionFilterOptions : bool option;
      supportsSingleThreadExecutionRequests : bool option;
    }

    let enc =
      let open Data_encoding in
      (* Capabilities_30.t *)
      conv
        (fun {
               supportsWriteMemoryRequest;
               supportsDisassembleRequest;
               supportsCancelRequest;
               supportsBreakpointLocationsRequest;
               supportsClipboardContext;
               supportsSteppingGranularity;
               supportsInstructionBreakpoints;
               supportsExceptionFilterOptions;
               supportsSingleThreadExecutionRequests;
             } ->
          ( supportsWriteMemoryRequest,
            supportsDisassembleRequest,
            supportsCancelRequest,
            supportsBreakpointLocationsRequest,
            supportsClipboardContext,
            supportsSteppingGranularity,
            supportsInstructionBreakpoints,
            supportsExceptionFilterOptions,
            supportsSingleThreadExecutionRequests ))
        (fun ( supportsWriteMemoryRequest,
               supportsDisassembleRequest,
               supportsCancelRequest,
               supportsBreakpointLocationsRequest,
               supportsClipboardContext,
               supportsSteppingGranularity,
               supportsInstructionBreakpoints,
               supportsExceptionFilterOptions,
               supportsSingleThreadExecutionRequests ) ->
          {
            supportsWriteMemoryRequest;
            supportsDisassembleRequest;
            supportsCancelRequest;
            supportsBreakpointLocationsRequest;
            supportsClipboardContext;
            supportsSteppingGranularity;
            supportsInstructionBreakpoints;
            supportsExceptionFilterOptions;
            supportsSingleThreadExecutionRequests;
          })
        (obj9
           (opt "supportsWriteMemoryRequest" bool)
           (opt "supportsDisassembleRequest" bool)
           (opt "supportsCancelRequest" bool)
           (opt "supportsBreakpointLocationsRequest" bool)
           (opt "supportsClipboardContext" bool)
           (opt "supportsSteppingGranularity" bool)
           (opt "supportsInstructionBreakpoints" bool)
           (opt "supportsExceptionFilterOptions" bool)
           (opt "supportsSingleThreadExecutionRequests" bool))

    let make ?supportsWriteMemoryRequest ?supportsDisassembleRequest
        ?supportsCancelRequest ?supportsBreakpointLocationsRequest
        ?supportsClipboardContext ?supportsSteppingGranularity
        ?supportsInstructionBreakpoints ?supportsExceptionFilterOptions
        ?supportsSingleThreadExecutionRequests () =
      {
        supportsWriteMemoryRequest;
        supportsDisassembleRequest;
        supportsCancelRequest;
        supportsBreakpointLocationsRequest;
        supportsClipboardContext;
        supportsSteppingGranularity;
        supportsInstructionBreakpoints;
        supportsExceptionFilterOptions;
        supportsSingleThreadExecutionRequests;
      }
  end

  type t =
    Capabilities_0.t
    * (Capabilities_10.t * (Capabilities_20.t * Capabilities_30.t))

  let enc =
    let open Data_encoding in
    merge_objs Capabilities_0.enc
    @@ merge_objs Capabilities_10.enc
    @@ merge_objs Capabilities_20.enc Capabilities_30.enc

  let make ?supportsConfigurationDoneRequest ?supportsFunctionBreakpoints
      ?supportsConditionalBreakpoints ?supportsHitConditionalBreakpoints
      ?supportsEvaluateForHovers ?exceptionBreakpointFilters ?supportsStepBack
      ?supportsSetVariable ?supportsRestartFrame ?supportsGotoTargetsRequest
      ?supportsStepInTargetsRequest ?supportsCompletionsRequest
      ?completionTriggerCharacters ?supportsModulesRequest
      ?additionalModuleColumns ?supportedChecksumAlgorithms
      ?supportsRestartRequest ?supportsExceptionOptions
      ?supportsValueFormattingOptions ?supportsExceptionInfoRequest
      ?supportTerminateDebuggee ?supportSuspendDebuggee
      ?supportsDelayedStackTraceLoading ?supportsLoadedSourcesRequest
      ?supportsLogPoints ?supportsTerminateThreadsRequest ?supportsSetExpression
      ?supportsTerminateRequest ?supportsDataBreakpoints
      ?supportsReadMemoryRequest ?supportsWriteMemoryRequest
      ?supportsDisassembleRequest ?supportsCancelRequest
      ?supportsBreakpointLocationsRequest ?supportsClipboardContext
      ?supportsSteppingGranularity ?supportsInstructionBreakpoints
      ?supportsExceptionFilterOptions ?supportsSingleThreadExecutionRequests ()
      =
    let t0 =
      Capabilities_0.make
        ?supportsConfigurationDoneRequest
        ?supportsFunctionBreakpoints
        ?supportsConditionalBreakpoints
        ?supportsHitConditionalBreakpoints
        ?supportsEvaluateForHovers
        ?exceptionBreakpointFilters
        ?supportsStepBack
        ?supportsSetVariable
        ?supportsRestartFrame
        ?supportsGotoTargetsRequest
        ()
    in

    let t1 =
      Capabilities_10.make
        ?supportsStepInTargetsRequest
        ?supportsCompletionsRequest
        ?completionTriggerCharacters
        ?supportsModulesRequest
        ?additionalModuleColumns
        ?supportedChecksumAlgorithms
        ?supportsRestartRequest
        ?supportsExceptionOptions
        ?supportsValueFormattingOptions
        ?supportsExceptionInfoRequest
        ()
    in

    let t2 =
      Capabilities_20.make
        ?supportTerminateDebuggee
        ?supportSuspendDebuggee
        ?supportsDelayedStackTraceLoading
        ?supportsLoadedSourcesRequest
        ?supportsLogPoints
        ?supportsTerminateThreadsRequest
        ?supportsSetExpression
        ?supportsTerminateRequest
        ?supportsDataBreakpoints
        ?supportsReadMemoryRequest
        ()
    in

    let t3 =
      Capabilities_30.make
        ?supportsWriteMemoryRequest
        ?supportsDisassembleRequest
        ?supportsCancelRequest
        ?supportsBreakpointLocationsRequest
        ?supportsClipboardContext
        ?supportsSteppingGranularity
        ?supportsInstructionBreakpoints
        ?supportsExceptionFilterOptions
        ?supportsSingleThreadExecutionRequests
        ()
    in

    (t0, (t1, (t2, t3)))
end

module CapabilitiesEvent_body = struct
  type t = {capabilities : Capabilities.t}

  let enc =
    let open Data_encoding in
    (* CapabilitiesEvent_body.t *)
    conv
      (fun {capabilities} -> capabilities)
      (fun capabilities -> {capabilities})
      (obj1 (req "capabilities" Capabilities.enc))

  let make ~capabilities () = {capabilities}
end

module ProgressStartEvent_body = struct
  type t = {
    progressId : string;
    title : string;
    requestId : int option;
    cancellable : bool option;
    message : string option;
    percentage : int option;
  }

  let enc =
    let open Data_encoding in
    (* ProgressStartEvent_body.t *)
    conv
      (fun {progressId; title; requestId; cancellable; message; percentage} ->
        (progressId, title, requestId, cancellable, message, percentage))
      (fun (progressId, title, requestId, cancellable, message, percentage) ->
        {progressId; title; requestId; cancellable; message; percentage})
      (obj6
         (req "progressId" string)
         (req "title" string)
         (opt "requestId" int31)
         (opt "cancellable" bool)
         (opt "message" string)
         (opt "percentage" int31))

  let make ~progressId ~title ?requestId ?cancellable ?message ?percentage () =
    {progressId; title; requestId; cancellable; message; percentage}
end

module ProgressUpdateEvent_body = struct
  type t = {
    progressId : string;
    message : string option;
    percentage : int option;
  }

  let enc =
    let open Data_encoding in
    (* ProgressUpdateEvent_body.t *)
    conv
      (fun {progressId; message; percentage} ->
        (progressId, message, percentage))
      (fun (progressId, message, percentage) ->
        {progressId; message; percentage})
      (obj3
         (req "progressId" string)
         (opt "message" string)
         (opt "percentage" int31))

  let make ~progressId ?message ?percentage () =
    {progressId; message; percentage}
end

module ProgressEndEvent_body = struct
  type t = {progressId : string; message : string option}

  let enc =
    let open Data_encoding in
    (* ProgressEndEvent_body.t *)
    conv
      (fun {progressId; message} -> (progressId, message))
      (fun (progressId, message) -> {progressId; message})
      (obj2 (req "progressId" string) (opt "message" string))

  let make ~progressId ?message () = {progressId; message}
end

module InvalidatedAreas = struct
  type t = All | Stacks | Threads | Variables | Other of string

  let enc =
    let open Data_encoding in
    conv
      (function
        | All -> "all"
        | Stacks -> "stacks"
        | Threads -> "threads"
        | Variables -> "variables"
        | Other s -> s)
      (function
        | "all" -> All
        | "stacks" -> Stacks
        | "threads" -> Threads
        | "variables" -> Variables
        | _ as s -> Other s)
      string
end

module InvalidatedEvent_body = struct
  type t = {
    areas : InvalidatedAreas.t list option;
    threadId : int option;
    stackFrameId : int option;
  }

  let enc =
    let open Data_encoding in
    (* InvalidatedEvent_body.t *)
    conv
      (fun {areas; threadId; stackFrameId} -> (areas, threadId, stackFrameId))
      (fun (areas, threadId, stackFrameId) -> {areas; threadId; stackFrameId})
      (obj3
         (opt "areas" (list InvalidatedAreas.enc))
         (opt "threadId" int31)
         (opt "stackFrameId" int31))

  let make ?areas ?threadId ?stackFrameId () = {areas; threadId; stackFrameId}
end

module MemoryEvent_body = struct
  type t = {memoryReference : string; offset : int; count : int}

  let enc =
    let open Data_encoding in
    (* MemoryEvent_body.t *)
    conv
      (fun {memoryReference; offset; count} -> (memoryReference, offset, count))
      (fun (memoryReference, offset, count) -> {memoryReference; offset; count})
      (obj3
         (req "memoryReference" string)
         (req "offset" int31)
         (req "count" int31))

  let make ~memoryReference ~offset ~count () = {memoryReference; offset; count}
end

module RunInTerminalRequestArguments_kind = struct
  type t = Integrated | External

  let enc =
    let open Data_encoding in
    conv
      (function Integrated -> "integrated" | External -> "external")
      (function
        | "integrated" -> Integrated
        | "external" -> External
        | _ -> failwith "RunInTerminalRequestArguments_kind")
      string
end

module RunInTerminalRequestArguments = struct
  type t = {
    kind : RunInTerminalRequestArguments_kind.t option;
    title : string option;
    cwd : string;
    args : string list;
    env : Data_encoding.json option;
  }

  let enc =
    let open Data_encoding in
    (* RunInTerminalRequestArguments.t *)
    conv
      (fun {kind; title; cwd; args; env} -> (kind, title, cwd, args, env))
      (fun (kind, title, cwd, args, env) -> {kind; title; cwd; args; env})
      (obj5
         (opt "kind" RunInTerminalRequestArguments_kind.enc)
         (opt "title" string)
         (req "cwd" string)
         (req "args" (list string))
         (opt "env" json))

  let make ?kind ?title ~cwd ~args ?env () = {kind; title; cwd; args; env}
end

module RunInTerminalResponse_body = struct
  type t = {processId : int option; shellProcessId : int option}

  let enc =
    let open Data_encoding in
    (* RunInTerminalResponse_body.t *)
    conv
      (fun {processId; shellProcessId} -> (processId, shellProcessId))
      (fun (processId, shellProcessId) -> {processId; shellProcessId})
      (obj2 (opt "processId" int31) (opt "shellProcessId" int31))

  let make ?processId ?shellProcessId () = {processId; shellProcessId}
end

module InitializeRequestArguments_pathFormat = struct
  type t = Path | Uri | Other of string

  let enc =
    let open Data_encoding in
    conv
      (function Path -> "path" | Uri -> "uri" | Other s -> s)
      (function "path" -> Path | "uri" -> Uri | _ as s -> Other s)
      string
end

module InitializeRequestArguments = struct
  module InitializeRequestArguments_0 = struct
    type t = {
      clientID : string option;
      clientName : string option;
      adapterID : string;
      locale : string option;
      linesStartAt1 : bool option;
      columnsStartAt1 : bool option;
      pathFormat : InitializeRequestArguments_pathFormat.t option;
      supportsVariableType : bool option;
      supportsVariablePaging : bool option;
      supportsRunInTerminalRequest : bool option;
    }

    let enc =
      let open Data_encoding in
      (* InitializeRequestArguments_0.t *)
      conv
        (fun {
               clientID;
               clientName;
               adapterID;
               locale;
               linesStartAt1;
               columnsStartAt1;
               pathFormat;
               supportsVariableType;
               supportsVariablePaging;
               supportsRunInTerminalRequest;
             } ->
          ( clientID,
            clientName,
            adapterID,
            locale,
            linesStartAt1,
            columnsStartAt1,
            pathFormat,
            supportsVariableType,
            supportsVariablePaging,
            supportsRunInTerminalRequest ))
        (fun ( clientID,
               clientName,
               adapterID,
               locale,
               linesStartAt1,
               columnsStartAt1,
               pathFormat,
               supportsVariableType,
               supportsVariablePaging,
               supportsRunInTerminalRequest ) ->
          {
            clientID;
            clientName;
            adapterID;
            locale;
            linesStartAt1;
            columnsStartAt1;
            pathFormat;
            supportsVariableType;
            supportsVariablePaging;
            supportsRunInTerminalRequest;
          })
        (obj10
           (opt "clientID" string)
           (opt "clientName" string)
           (req "adapterID" string)
           (opt "locale" string)
           (opt "linesStartAt1" bool)
           (opt "columnsStartAt1" bool)
           (opt "pathFormat" InitializeRequestArguments_pathFormat.enc)
           (opt "supportsVariableType" bool)
           (opt "supportsVariablePaging" bool)
           (opt "supportsRunInTerminalRequest" bool))

    let make ?clientID ?clientName ~adapterID ?locale ?linesStartAt1
        ?columnsStartAt1 ?pathFormat ?supportsVariableType
        ?supportsVariablePaging ?supportsRunInTerminalRequest () =
      {
        clientID;
        clientName;
        adapterID;
        locale;
        linesStartAt1;
        columnsStartAt1;
        pathFormat;
        supportsVariableType;
        supportsVariablePaging;
        supportsRunInTerminalRequest;
      }
  end

  module InitializeRequestArguments_10 = struct
    type t = {
      supportsMemoryReferences : bool option;
      supportsProgressReporting : bool option;
      supportsInvalidatedEvent : bool option;
      supportsMemoryEvent : bool option;
    }

    let enc =
      let open Data_encoding in
      (* InitializeRequestArguments_10.t *)
      conv
        (fun {
               supportsMemoryReferences;
               supportsProgressReporting;
               supportsInvalidatedEvent;
               supportsMemoryEvent;
             } ->
          ( supportsMemoryReferences,
            supportsProgressReporting,
            supportsInvalidatedEvent,
            supportsMemoryEvent ))
        (fun ( supportsMemoryReferences,
               supportsProgressReporting,
               supportsInvalidatedEvent,
               supportsMemoryEvent ) ->
          {
            supportsMemoryReferences;
            supportsProgressReporting;
            supportsInvalidatedEvent;
            supportsMemoryEvent;
          })
        (obj4
           (opt "supportsMemoryReferences" bool)
           (opt "supportsProgressReporting" bool)
           (opt "supportsInvalidatedEvent" bool)
           (opt "supportsMemoryEvent" bool))

    let make ?supportsMemoryReferences ?supportsProgressReporting
        ?supportsInvalidatedEvent ?supportsMemoryEvent () =
      {
        supportsMemoryReferences;
        supportsProgressReporting;
        supportsInvalidatedEvent;
        supportsMemoryEvent;
      }
  end

  type t = InitializeRequestArguments_0.t * InitializeRequestArguments_10.t

  let enc =
    let open Data_encoding in
    merge_objs
      InitializeRequestArguments_0.enc
      InitializeRequestArguments_10.enc

  let make ?clientID ?clientName ~adapterID ?locale ?linesStartAt1
      ?columnsStartAt1 ?pathFormat ?supportsVariableType ?supportsVariablePaging
      ?supportsRunInTerminalRequest ?supportsMemoryReferences
      ?supportsProgressReporting ?supportsInvalidatedEvent ?supportsMemoryEvent
      () =
    let t0 =
      InitializeRequestArguments_0.make
        ?clientID
        ?clientName
        ~adapterID
        ?locale
        ?linesStartAt1
        ?columnsStartAt1
        ?pathFormat
        ?supportsVariableType
        ?supportsVariablePaging
        ?supportsRunInTerminalRequest
        ()
    in

    let t1 =
      InitializeRequestArguments_10.make
        ?supportsMemoryReferences
        ?supportsProgressReporting
        ?supportsInvalidatedEvent
        ?supportsMemoryEvent
        ()
    in

    (t0, t1)
end

module ConfigurationDoneArguments = struct
  type t = unit

  let enc = Data_encoding.empty

  let make () = ()
end

module DisconnectArguments = struct
  type t = {
    restart : bool option;
    terminateDebuggee : bool option;
    suspendDebuggee : bool option;
  }

  let enc =
    let open Data_encoding in
    (* DisconnectArguments.t *)
    conv
      (fun {restart; terminateDebuggee; suspendDebuggee} ->
        (restart, terminateDebuggee, suspendDebuggee))
      (fun (restart, terminateDebuggee, suspendDebuggee) ->
        {restart; terminateDebuggee; suspendDebuggee})
      (obj3
         (opt "restart" bool)
         (opt "terminateDebuggee" bool)
         (opt "suspendDebuggee" bool))

  let make ?restart ?terminateDebuggee ?suspendDebuggee () =
    {restart; terminateDebuggee; suspendDebuggee}
end

module TerminateArguments = struct
  type t = {restart : bool option}

  let enc =
    let open Data_encoding in
    (* TerminateArguments.t *)
    conv
      (fun {restart} -> restart)
      (fun restart -> {restart})
      (obj1 (opt "restart" bool))

  let make ?restart () = {restart}
end


module BreakpointLocationsArguments = struct
  type t = {
    source : Source.t;
    line : int;
    column : int option;
    endLine : int option;
    endColumn : int option;
  }

  let enc =
    let open Data_encoding in
    (* BreakpointLocationsArguments.t *)
    conv
      (fun {source; line; column; endLine; endColumn} ->
        (source, line, column, endLine, endColumn))
      (fun (source, line, column, endLine, endColumn) ->
        {source; line; column; endLine; endColumn})
      (obj5
         (req "source" Source.enc)
         (req "line" int31)
         (opt "column" int31)
         (opt "endLine" int31)
         (opt "endColumn" int31))

  let make ~source ~line ?column ?endLine ?endColumn () =
    {source; line; column; endLine; endColumn}
end
module BreakpointLocation = struct
  type t = {
    line : int;
    column : int option;
    endLine : int option;
    endColumn : int option;
  }

  let enc =
    let open Data_encoding in
    (* BreakpointLocation.t *)
    conv
      (fun {line; column; endLine; endColumn} ->
        (line, column, endLine, endColumn))
      (fun (line, column, endLine, endColumn) ->
        {line; column; endLine; endColumn})
      (obj4
         (req "line" int31)
         (opt "column" int31)
         (opt "endLine" int31)
         (opt "endColumn" int31))

  let make ~line ?column ?endLine ?endColumn () =
    {line; column; endLine; endColumn}
end

module BreakpointLocationsResponse_body = struct
  type t = {breakpoints : BreakpointLocation.t list}

  let enc =
    let open Data_encoding in
    (* BreakpointLocationsResponse_body.t *)
    conv
      (fun {breakpoints} -> breakpoints)
      (fun breakpoints -> {breakpoints})
      (obj1 (req "breakpoints" (list BreakpointLocation.enc)))

  let make ~breakpoints () = {breakpoints}
end

module SourceBreakpoint = struct
  type t = {
    line : int;
    column : int option;
    condition : string option;
    hitCondition : string option;
    logMessage : string option;
  }

  let enc =
    let open Data_encoding in
    (* SourceBreakpoint.t *)
    conv
      (fun {line; column; condition; hitCondition; logMessage} ->
        (line, column, condition, hitCondition, logMessage))
      (fun (line, column, condition, hitCondition, logMessage) ->
        {line; column; condition; hitCondition; logMessage})
      (obj5
         (req "line" int31)
         (opt "column" int31)
         (opt "condition" string)
         (opt "hitCondition" string)
         (opt "logMessage" string))

  let make ~line ?column ?condition ?hitCondition ?logMessage () =
    {line; column; condition; hitCondition; logMessage}
end

module SetBreakpointsArguments = struct
  type t = {
    source : Source.t;
    breakpoints : SourceBreakpoint.t list option;
    lines : int list option;
    sourceModified : bool option;
  }

  let enc =
    let open Data_encoding in
    (* SetBreakpointsArguments.t *)
    conv
      (fun {source; breakpoints; lines; sourceModified} ->
        (source, breakpoints, lines, sourceModified))
      (fun (source, breakpoints, lines, sourceModified) ->
        {source; breakpoints; lines; sourceModified})
      (obj4
         (req "source" Source.enc)
         (opt "breakpoints" (list SourceBreakpoint.enc))
         (opt "lines" (list int31))
         (opt "sourceModified" bool))

  let make ~source ?breakpoints ?lines ?sourceModified () =
    {source; breakpoints; lines; sourceModified}
end

module SetBreakpointsResponse_body = struct
  type t = {breakpoints : Breakpoint.t list}

  let enc =
    let open Data_encoding in
    (* SetBreakpointsResponse_body.t *)
    conv
      (fun {breakpoints} -> breakpoints)
      (fun breakpoints -> {breakpoints})
      (obj1 (req "breakpoints" (list Breakpoint.enc)))

  let make ~breakpoints () = {breakpoints}
end

module FunctionBreakpoint = struct
  type t = {
    name : string;
    condition : string option;
    hitCondition : string option;
  }

  let enc =
    let open Data_encoding in
    (* FunctionBreakpoint.t *)
    conv
      (fun {name; condition; hitCondition} -> (name, condition, hitCondition))
      (fun (name, condition, hitCondition) -> {name; condition; hitCondition})
      (obj3
         (req "name" string)
         (opt "condition" string)
         (opt "hitCondition" string))

  let make ~name ?condition ?hitCondition () = {name; condition; hitCondition}
end

module SetFunctionBreakpointsArguments = struct
  type t = {breakpoints : FunctionBreakpoint.t list}

  let enc =
    let open Data_encoding in
    (* SetFunctionBreakpointsArguments.t *)
    conv
      (fun {breakpoints} -> breakpoints)
      (fun breakpoints -> {breakpoints})
      (obj1 (req "breakpoints" (list FunctionBreakpoint.enc)))

  let make ~breakpoints () = {breakpoints}
end


module SetFunctionBreakpointsResponse_body = struct
  type t = {breakpoints : Breakpoint.t list}

  let enc =
    let open Data_encoding in
    (* SetFunctionBreakpointsResponse_body.t *)
    conv
      (fun {breakpoints} -> breakpoints)
      (fun breakpoints -> {breakpoints})
      (obj1 (req "breakpoints" (list Breakpoint.enc)))

  let make ~breakpoints () = {breakpoints}
end

module ExceptionFilterOptions = struct
  type t = {filterId : string; condition : string option}

  let enc =
    let open Data_encoding in
    (* ExceptionFilterOptions.t *)
    conv
      (fun {filterId; condition} -> (filterId, condition))
      (fun (filterId, condition) -> {filterId; condition})
      (obj2 (req "filterId" string) (opt "condition" string))

  let make ~filterId ?condition () = {filterId; condition}
end

module ExceptionPathSegment = struct
  type t = {negate : bool option; names : string list}

  let enc =
    let open Data_encoding in
    (* ExceptionPathSegment.t *)
    conv
      (fun {negate; names} -> (negate, names))
      (fun (negate, names) -> {negate; names})
      (obj2 (opt "negate" bool) (req "names" (list string)))

  let make ?negate ~names () = {negate; names}
end

module ExceptionBreakMode = struct
  type t = Never | Always | Unhandled | UserUnhandled

  let enc =
    let open Data_encoding in
    conv
      (function
        | Never -> "never"
        | Always -> "always"
        | Unhandled -> "unhandled"
        | UserUnhandled -> "userUnhandled")
      (function
        | "never" -> Never
        | "always" -> Always
        | "unhandled" -> Unhandled
        | "userUnhandled" -> UserUnhandled
        | _ -> failwith "ExceptionBreakMode")
      string
end

module ExceptionOptions = struct
  type t = {
    path : ExceptionPathSegment.t list option;
    breakMode : ExceptionBreakMode.t;
  }

  let enc =
    let open Data_encoding in
    (* ExceptionOptions.t *)
    conv
      (fun {path; breakMode} -> (path, breakMode))
      (fun (path, breakMode) -> {path; breakMode})
      (obj2
         (opt "path" (list ExceptionPathSegment.enc))
         (req "breakMode" ExceptionBreakMode.enc))

  let make ?path ~breakMode () = {path; breakMode}
end

module SetExceptionBreakpointsArguments = struct
  type t = {
    filters : string list;
    filterOptions : ExceptionFilterOptions.t list option;
    exceptionOptions : ExceptionOptions.t list option;
  }

  let enc =
    let open Data_encoding in
    (* SetExceptionBreakpointsArguments.t *)
    conv
      (fun {filters; filterOptions; exceptionOptions} ->
        (filters, filterOptions, exceptionOptions))
      (fun (filters, filterOptions, exceptionOptions) ->
        {filters; filterOptions; exceptionOptions})
      (obj3
         (req "filters" (list string))
         (opt "filterOptions" (list ExceptionFilterOptions.enc))
         (opt "exceptionOptions" (list ExceptionOptions.enc)))

  let make ~filters ?filterOptions ?exceptionOptions () =
    {filters; filterOptions; exceptionOptions}
end

module SetExceptionBreakpointsResponse_body = struct
  type t = {breakpoints : Breakpoint.t list option}

  let enc =
    let open Data_encoding in
    (* SetExceptionBreakpointsResponse_body.t *)
    conv
      (fun {breakpoints} -> breakpoints)
      (fun breakpoints -> {breakpoints})
      (obj1 (opt "breakpoints" (list Breakpoint.enc)))

  let make ?breakpoints () = {breakpoints}
end


module DataBreakpointInfoArguments = struct
  type t = {variablesReference : int option; name : string}

  let enc =
    let open Data_encoding in
    (* DataBreakpointInfoArguments.t *)
    conv
      (fun {variablesReference; name} -> (variablesReference, name))
      (fun (variablesReference, name) -> {variablesReference; name})
      (obj2 (opt "variablesReference" int31) (req "name" string))

  let make ?variablesReference ~name () = {variablesReference; name}
end

module DataBreakpointAccessType = struct
  type t = Read | Write | ReadWrite

  let enc =
    let open Data_encoding in
    conv
      (function Read -> "read" | Write -> "write" | ReadWrite -> "readWrite")
      (function
        | "read" -> Read
        | "write" -> Write
        | "readWrite" -> ReadWrite
        | _ -> failwith "DataBreakpointAccessType")
      string
end

module DataBreakpointInfoResponse_body = struct
  type t = {
    dataId : string option;
    description : string;
    accessTypes : DataBreakpointAccessType.t list option;
    canPersist : bool option;
  }

  let enc =
    let open Data_encoding in
    (* DataBreakpointInfoResponse_body.t *)
    conv
      (fun {dataId; description; accessTypes; canPersist} ->
        (dataId, description, accessTypes, canPersist))
      (fun (dataId, description, accessTypes, canPersist) ->
        {dataId; description; accessTypes; canPersist})
      (obj4
         (req "dataId" (option string))
         (req "description" string)
         (opt "accessTypes" (list DataBreakpointAccessType.enc))
         (opt "canPersist" bool))

  let make ~dataId ~description ?accessTypes ?canPersist () =
    {dataId; description; accessTypes; canPersist}
end


module DataBreakpoint = struct
  type t = {
    dataId : string;
    accessType : DataBreakpointAccessType.t option;
    condition : string option;
    hitCondition : string option;
  }

  let enc =
    let open Data_encoding in
    (* DataBreakpoint.t *)
    conv
      (fun {dataId; accessType; condition; hitCondition} ->
        (dataId, accessType, condition, hitCondition))
      (fun (dataId, accessType, condition, hitCondition) ->
        {dataId; accessType; condition; hitCondition})
      (obj4
         (req "dataId" string)
         (opt "accessType" DataBreakpointAccessType.enc)
         (opt "condition" string)
         (opt "hitCondition" string))

  let make ~dataId ?accessType ?condition ?hitCondition () =
    {dataId; accessType; condition; hitCondition}
end

module SetDataBreakpointsArguments = struct
  type t = {breakpoints : DataBreakpoint.t list}

  let enc =
    let open Data_encoding in
    (* SetDataBreakpointsArguments.t *)
    conv
      (fun {breakpoints} -> breakpoints)
      (fun breakpoints -> {breakpoints})
      (obj1 (req "breakpoints" (list DataBreakpoint.enc)))

  let make ~breakpoints () = {breakpoints}
end

module SetDataBreakpointsResponse_body = struct
  type t = {breakpoints : Breakpoint.t list}

  let enc =
    let open Data_encoding in
    (* SetDataBreakpointsResponse_body.t *)
    conv
      (fun {breakpoints} -> breakpoints)
      (fun breakpoints -> {breakpoints})
      (obj1 (req "breakpoints" (list Breakpoint.enc)))

  let make ~breakpoints () = {breakpoints}
end

module InstructionBreakpoint = struct
  type t = {
    instructionReference : string;
    offset : int option;
    condition : string option;
    hitCondition : string option;
  }

  let enc =
    let open Data_encoding in
    (* InstructionBreakpoint.t *)
    conv
      (fun {instructionReference; offset; condition; hitCondition} ->
        (instructionReference, offset, condition, hitCondition))
      (fun (instructionReference, offset, condition, hitCondition) ->
        {instructionReference; offset; condition; hitCondition})
      (obj4
         (req "instructionReference" string)
         (opt "offset" int31)
         (opt "condition" string)
         (opt "hitCondition" string))

  let make ~instructionReference ?offset ?condition ?hitCondition () =
    {instructionReference; offset; condition; hitCondition}
end

module SetInstructionBreakpointsArguments = struct
  type t = {breakpoints : InstructionBreakpoint.t list}

  let enc =
    let open Data_encoding in
    (* SetInstructionBreakpointsArguments.t *)
    conv
      (fun {breakpoints} -> breakpoints)
      (fun breakpoints -> {breakpoints})
      (obj1 (req "breakpoints" (list InstructionBreakpoint.enc)))

  let make ~breakpoints () = {breakpoints}
end

module SetInstructionBreakpointsResponse_body = struct
  type t = {breakpoints : Breakpoint.t list}

  let enc =
    let open Data_encoding in
    (* SetInstructionBreakpointsResponse_body.t *)
    conv
      (fun {breakpoints} -> breakpoints)
      (fun breakpoints -> {breakpoints})
      (obj1 (req "breakpoints" (list Breakpoint.enc)))

  let make ~breakpoints () = {breakpoints}
end

module ContinueArguments = struct
  type t = {threadId : int; singleThread : bool option}

  let enc =
    let open Data_encoding in
    (* ContinueArguments.t *)
    conv
      (fun {threadId; singleThread} -> (threadId, singleThread))
      (fun (threadId, singleThread) -> {threadId; singleThread})
      (obj2 (req "threadId" int31) (opt "singleThread" bool))

  let make ~threadId ?singleThread () = {threadId; singleThread}
end

module ContinueResponse_body = struct
  type t = {allThreadsContinued : bool option}

  let enc =
    let open Data_encoding in
    (* ContinueResponse_body.t *)
    conv
      (fun {allThreadsContinued} -> allThreadsContinued)
      (fun allThreadsContinued -> {allThreadsContinued})
      (obj1 (opt "allThreadsContinued" bool))

  let make ?allThreadsContinued () = {allThreadsContinued}
end

module SteppingGranularity = struct
  type t = Statement | Line | Instruction

  let enc =
    let open Data_encoding in
    conv
      (function
        | Statement -> "statement"
        | Line -> "line"
        | Instruction -> "instruction")
      (function
        | "statement" -> Statement
        | "line" -> Line
        | "instruction" -> Instruction
        | _ -> failwith "SteppingGranularity")
      string
end

module NextArguments = struct
  type t = {
    threadId : int;
    singleThread : bool option;
    granularity : SteppingGranularity.t option;
  }

  let enc =
    let open Data_encoding in
    (* NextArguments.t *)
    conv
      (fun {threadId; singleThread; granularity} ->
        (threadId, singleThread, granularity))
      (fun (threadId, singleThread, granularity) ->
        {threadId; singleThread; granularity})
      (obj3
         (req "threadId" int31)
         (opt "singleThread" bool)
         (opt "granularity" SteppingGranularity.enc))

  let make ~threadId ?singleThread ?granularity () =
    {threadId; singleThread; granularity}
end

module StepInArguments = struct
  type t = {
    threadId : int;
    singleThread : bool option;
    targetId : int option;
    granularity : SteppingGranularity.t option;
  }

  let enc =
    let open Data_encoding in
    (* StepInArguments.t *)
    conv
      (fun {threadId; singleThread; targetId; granularity} ->
        (threadId, singleThread, targetId, granularity))
      (fun (threadId, singleThread, targetId, granularity) ->
        {threadId; singleThread; targetId; granularity})
      (obj4
         (req "threadId" int31)
         (opt "singleThread" bool)
         (opt "targetId" int31)
         (opt "granularity" SteppingGranularity.enc))

  let make ~threadId ?singleThread ?targetId ?granularity () =
    {threadId; singleThread; targetId; granularity}
end


(* type request = *)
(*   | CancelRequest of (Command.cancel, CancelArguments.t) Request.t *)
(*   | InitializeRequest of (Command.initialize, InitializeRequestArguments.t) Request.t *)
(*   | ConfigurationDoneRequest of (Command.configurationdone, ConfigurationDoneArguments.t) Request.t *)

(* type response = *)
(*   | ErrorResponse of (Command.error, ErrorResponse_body.t) Response.t *)
(*   | CancelResponse of (Command.cancel, EmptyObject.t) Response.t *)
(*   | InitializeResponse of (Command.initialize, Capabilities.t) Response.t *)
(*   | ConfigurationDoneResponse of (Command.configurationdone, EmptyObject.t) Response.t *)
