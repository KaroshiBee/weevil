open Dap_render

let%expect_test "Check phantoms (command and event) example" =
  let schema_js = Ezjsonm.from_channel @@ open_in "data/phantoms.json" in
  let dfs = Dfs.make ~schema_js in
  let actual = render dfs @@ Commands ML in
  Printf.printf "%s" actual;
  [%expect {|
    (* NOTE autogenerating Dap_command, do not manually edit *)
     type v = Cancel | Error

     type 'a t = v

    type cancel
    type error

    let cancel : cancel t = Cancel
    let error : error t = Error

    let f : type a. a t -> string = function | (Cancel : _ t) -> "cancel"
    | (Error : _ t) -> "error"

    let g : type a. string -> a t = function | "cancel" -> (Cancel : _ t)
    | "error" -> (Error : _ t)| _ -> failwith "Dap_command"


    let enc = Data_encoding.conv f g Data_encoding.string |}];

  let actual = render dfs @@ Commands MLI in
  Printf.printf "%s" actual;
  [%expect {|
    (* NOTE autogenerating Dap_command, do not manually edit *)
     type 'a t
    type cancel
    type error

    val cancel : cancel t
    val error : error t

    val enc : 'a t Data_encoding.t |}];

  let actual = render dfs @@ Events ML in
  Printf.printf "%s" actual;
  [%expect {|
    (* NOTE autogenerating Dap_event, do not manually edit *)
     type v = Terminated | Exited | Continued | Stopped | Initialized

     type 'a t = v

    type terminated
    type exited
    type continued
    type stopped
    type initialized

    let terminated : terminated t = Terminated
    let exited : exited t = Exited
    let continued : continued t = Continued
    let stopped : stopped t = Stopped
    let initialized : initialized t = Initialized

    let f : type a. a t -> string = function | (Terminated : _ t) -> "terminated"
    | (Exited : _ t) -> "exited"
    | (Continued : _ t) -> "continued"
    | (Stopped : _ t) -> "stopped"
    | (Initialized : _ t) -> "initialized"

    let g : type a. string -> a t = function | "terminated" -> (Terminated : _ t)
    | "exited" -> (Exited : _ t)
    | "continued" -> (Continued : _ t)
    | "stopped" -> (Stopped : _ t)
    | "initialized" -> (Initialized : _ t)| _ -> failwith "Dap_event"


    let enc = Data_encoding.conv f g Data_encoding.string |}];

  let actual = render dfs @@ Events MLI in
  Printf.printf "%s" actual;
  [%expect {|
    (* NOTE autogenerating Dap_event, do not manually edit *)
     type 'a t
    type terminated
    type exited
    type continued
    type stopped
    type initialized

    val terminated : terminated t
    val exited : exited t
    val continued : continued t
    val stopped : stopped t
    val initialized : initialized t

    val enc : 'a t Data_encoding.t |}]

let%expect_test "Check ErrorResponse example" =
  let schema_js = Ezjsonm.from_channel @@ open_in "data/errorResponse.json" in
  let dfs = Dfs.make ~schema_js in
  let actual = render dfs Messages in
  Printf.printf "%s" actual;
  [%expect {|
    (* NOTE this file was autogenerated - do not modify by hand *)

     open Dap_t

     module Message = struct
     type t = { id: int;
    format: string;
    variables: Data_encoding.json option;
    sendTelemetry: bool option;
    showUser: bool option;
    url: string option;
    urlLabel: string option;
    lines: int list option; }

     let enc =
     let open Data_encoding in
     (* Message.t *)
             conv
     (fun {id; format; variables; sendTelemetry; showUser; url; urlLabel; lines} -> (id, format, variables, sendTelemetry, showUser, url, urlLabel, lines))
     (fun (id, format, variables, sendTelemetry, showUser, url, urlLabel, lines) -> {id; format; variables; sendTelemetry; showUser; url; urlLabel; lines})
     (obj8
    (req "id" int31)
    (req "format" string)
    (opt "variables" json)
    (opt "sendTelemetry" bool)
    (opt "showUser" bool)
    (opt "url" string)
    (opt "urlLabel" string)
    (opt "lines" (list int31)))


     let make ~id ~format ?variables ?sendTelemetry ?showUser ?url ?urlLabel ?lines () =
    {id; format; variables; sendTelemetry; showUser; url; urlLabel; lines}

     end


    module ErrorResponse_body = struct
     type t = { error: Message.t option; }

     let enc =
     let open Data_encoding in
     (* ErrorResponse_body.t *)
             conv
     (fun {error} -> error)
     (fun error -> {error})
     (obj1
    (opt "error" Message.enc))


     let make ?error () =
    {error}

     end




     type (_,_,_) request =


     type (_,_,_) response =
    | ErrorResponse : (Dap_command.error, ErrorResponse_body.t, ResponseMessage.req) ResponseMessage.t -> (Dap_command.error, ErrorResponse_body.t, ResponseMessage.req) response

     type (_,_,_) event = |}]


let%expect_test "Check CancelRequest example" =
  let schema_js = Ezjsonm.from_channel @@ open_in "data/cancelRequest.json" in
  let dfs = Dfs.make ~schema_js in
  let actual = render dfs Messages in
  Printf.printf "%s" actual;
  [%expect {|
    (* NOTE this file was autogenerated - do not modify by hand *)

     open Dap_t

     module CancelArguments = struct
     type t = { requestId: int option;
    progressId: string option; }

     let enc =
     let open Data_encoding in
     (* CancelArguments.t *)
             conv
     (fun {requestId; progressId} -> (requestId, progressId))
     (fun (requestId, progressId) -> {requestId; progressId})
     (obj2
    (opt "requestId" int31)
    (opt "progressId" string))


     let make ?requestId ?progressId () =
    {requestId; progressId}

     end




     type (_,_,_) request =
    | CancelRequest : (Dap_command.cancel, CancelArguments.t option, RequestMessage.opt) RequestMessage.t -> (Dap_command.cancel, CancelArguments.t option, RequestMessage.opt) request

     type (_,_,_) response =


     type (_,_,_) event = |}]


let%expect_test "Check StoppedEvent example" =
  let schema_js = Ezjsonm.from_channel @@ open_in "data/stoppedEvent.json" in
  let dfs = Dfs.make ~schema_js in
  let actual = render dfs Messages in
  Printf.printf "%s" actual;
  [%expect {|
    (* NOTE this file was autogenerated - do not modify by hand *)

     open Dap_t

     module StoppedEvent_body_reason = struct
     type t = Step | Breakpoint | Exception | Pause | Entry | Goto | Function_breakpoint | Data_breakpoint | Instruction_breakpoint | Other of string

     let enc =
     let open Data_encoding in
     conv
     (function Step -> "step" | Breakpoint -> "breakpoint" | Exception -> "exception" | Pause -> "pause" | Entry -> "entry" | Goto -> "goto" | Function_breakpoint -> "function breakpoint" | Data_breakpoint -> "data breakpoint" | Instruction_breakpoint -> "instruction breakpoint" | Other s -> s)
     (function "step" -> Step | "breakpoint" -> Breakpoint | "exception" -> Exception | "pause" -> Pause | "entry" -> Entry | "goto" -> Goto | "function breakpoint" -> Function_breakpoint | "data breakpoint" -> Data_breakpoint | "instruction breakpoint" -> Instruction_breakpoint | _ as s -> Other s)
     string

     end


    module StoppedEvent_body = struct
     type t = { reason: StoppedEvent_body_reason.t;
    description: string option;
    threadId: int option;
    preserveFocusHint: bool option;
    text: string option;
    allThreadsStopped: bool option;
    hitBreakpointIds: int list option; }

     let enc =
     let open Data_encoding in
     (* StoppedEvent_body.t *)
             conv
     (fun {reason; description; threadId; preserveFocusHint; text; allThreadsStopped; hitBreakpointIds} -> (reason, description, threadId, preserveFocusHint, text, allThreadsStopped, hitBreakpointIds))
     (fun (reason, description, threadId, preserveFocusHint, text, allThreadsStopped, hitBreakpointIds) -> {reason; description; threadId; preserveFocusHint; text; allThreadsStopped; hitBreakpointIds})
     (obj7
    (req "reason" StoppedEvent_body_reason.enc)
    (opt "description" string)
    (opt "threadId" int31)
    (opt "preserveFocusHint" bool)
    (opt "text" string)
    (opt "allThreadsStopped" bool)
    (opt "hitBreakpointIds" (list int31)))


     let make ~reason ?description ?threadId ?preserveFocusHint ?text ?allThreadsStopped ?hitBreakpointIds () =
    {reason; description; threadId; preserveFocusHint; text; allThreadsStopped; hitBreakpointIds}

     end




     type (_,_,_) request =


     type (_,_,_) response =


     type (_,_,_) event =
    | StoppedEvent : (Dap_event.stopped, StoppedEvent_body.t, EventMessage.req) EventMessage.t -> (Dap_event.stopped, StoppedEvent_body.t, EventMessage.req) event |}]


let%expect_test "Check cyclic example" =
  let schema_js = Ezjsonm.from_channel @@ open_in "data/cyclic.json" in
  let dfs = Dfs.make ~schema_js in
  let actual = render dfs Messages in
  Printf.printf "%s" actual;
  [%expect {|
    (* NOTE this file was autogenerated - do not modify by hand *)

     open Dap_t

     module ExceptionDetails = struct
     type t = { message: string option;
    typeName: string option;
    fullTypeName: string option;
    evaluateName: string option;
    stackTrace: string option;
    innerException: t list option; }

     let enc =
     let open Data_encoding in
     mu "ExceptionDetails.t"
     ( fun e ->
     conv
     (fun {message; typeName; fullTypeName; evaluateName; stackTrace; innerException} -> (message, typeName, fullTypeName, evaluateName, stackTrace, innerException))
     (fun (message, typeName, fullTypeName, evaluateName, stackTrace, innerException) -> {message; typeName; fullTypeName; evaluateName; stackTrace; innerException})
     (obj6
    (opt "message" string)
    (opt "typeName" string)
    (opt "fullTypeName" string)
    (opt "evaluateName" string)
    (opt "stackTrace" string)
    (opt "innerException" (list e)))
    )

     let make ?message ?typeName ?fullTypeName ?evaluateName ?stackTrace ?innerException () =
    {message; typeName; fullTypeName; evaluateName; stackTrace; innerException}

     end


     type (_,_,_) request =


     type (_,_,_) response =


     type (_,_,_) event = |}]

let%expect_test "Check large example" =
  let schema_js = Ezjsonm.from_channel @@ open_in "data/largeObject.json" in
  let dfs = Dfs.make ~schema_js in
  let actual = render dfs Messages in
  Printf.printf "%s" actual;
  [%expect {|
    (* NOTE this file was autogenerated - do not modify by hand *)

     open Dap_t

     module Capabilities = struct
     module Capabilities_0 = struct
     type t = { supportsConfigurationDoneRequest: bool option;
    supportsFunctionBreakpoints: bool option;
    supportsConditionalBreakpoints: bool option;
    supportsHitConditionalBreakpoints: bool option;
    supportsEvaluateForHovers: bool option;
    supportsStepBack: bool option;
    supportsSetVariable: bool option;
    supportsRestartFrame: bool option;
    supportsGotoTargetsRequest: bool option;
    supportsStepInTargetsRequest: bool option; }

     let enc =
     let open Data_encoding in
     (* Capabilities_0.t *)
             conv
     (fun {supportsConfigurationDoneRequest; supportsFunctionBreakpoints; supportsConditionalBreakpoints; supportsHitConditionalBreakpoints; supportsEvaluateForHovers; supportsStepBack; supportsSetVariable; supportsRestartFrame; supportsGotoTargetsRequest; supportsStepInTargetsRequest} -> (supportsConfigurationDoneRequest, supportsFunctionBreakpoints, supportsConditionalBreakpoints, supportsHitConditionalBreakpoints, supportsEvaluateForHovers, supportsStepBack, supportsSetVariable, supportsRestartFrame, supportsGotoTargetsRequest, supportsStepInTargetsRequest))
     (fun (supportsConfigurationDoneRequest, supportsFunctionBreakpoints, supportsConditionalBreakpoints, supportsHitConditionalBreakpoints, supportsEvaluateForHovers, supportsStepBack, supportsSetVariable, supportsRestartFrame, supportsGotoTargetsRequest, supportsStepInTargetsRequest) -> {supportsConfigurationDoneRequest; supportsFunctionBreakpoints; supportsConditionalBreakpoints; supportsHitConditionalBreakpoints; supportsEvaluateForHovers; supportsStepBack; supportsSetVariable; supportsRestartFrame; supportsGotoTargetsRequest; supportsStepInTargetsRequest})
     (obj10
    (opt "supportsConfigurationDoneRequest" bool)
    (opt "supportsFunctionBreakpoints" bool)
    (opt "supportsConditionalBreakpoints" bool)
    (opt "supportsHitConditionalBreakpoints" bool)
    (opt "supportsEvaluateForHovers" bool)
    (opt "supportsStepBack" bool)
    (opt "supportsSetVariable" bool)
    (opt "supportsRestartFrame" bool)
    (opt "supportsGotoTargetsRequest" bool)
    (opt "supportsStepInTargetsRequest" bool))


     let make ?supportsConfigurationDoneRequest ?supportsFunctionBreakpoints ?supportsConditionalBreakpoints ?supportsHitConditionalBreakpoints ?supportsEvaluateForHovers ?supportsStepBack ?supportsSetVariable ?supportsRestartFrame ?supportsGotoTargetsRequest ?supportsStepInTargetsRequest () =
    {supportsConfigurationDoneRequest; supportsFunctionBreakpoints; supportsConditionalBreakpoints; supportsHitConditionalBreakpoints; supportsEvaluateForHovers; supportsStepBack; supportsSetVariable; supportsRestartFrame; supportsGotoTargetsRequest; supportsStepInTargetsRequest}

     end


    module Capabilities_10 = struct
     type t = { supportsCompletionsRequest: bool option;
    completionTriggerCharacters: string list option;
    supportsModulesRequest: bool option;
    supportsRestartRequest: bool option;
    supportsExceptionOptions: bool option;
    supportsValueFormattingOptions: bool option;
    supportsExceptionInfoRequest: bool option;
    supportTerminateDebuggee: bool option;
    supportSuspendDebuggee: bool option;
    supportsDelayedStackTraceLoading: bool option; }

     let enc =
     let open Data_encoding in
     (* Capabilities_10.t *)
             conv
     (fun {supportsCompletionsRequest; completionTriggerCharacters; supportsModulesRequest; supportsRestartRequest; supportsExceptionOptions; supportsValueFormattingOptions; supportsExceptionInfoRequest; supportTerminateDebuggee; supportSuspendDebuggee; supportsDelayedStackTraceLoading} -> (supportsCompletionsRequest, completionTriggerCharacters, supportsModulesRequest, supportsRestartRequest, supportsExceptionOptions, supportsValueFormattingOptions, supportsExceptionInfoRequest, supportTerminateDebuggee, supportSuspendDebuggee, supportsDelayedStackTraceLoading))
     (fun (supportsCompletionsRequest, completionTriggerCharacters, supportsModulesRequest, supportsRestartRequest, supportsExceptionOptions, supportsValueFormattingOptions, supportsExceptionInfoRequest, supportTerminateDebuggee, supportSuspendDebuggee, supportsDelayedStackTraceLoading) -> {supportsCompletionsRequest; completionTriggerCharacters; supportsModulesRequest; supportsRestartRequest; supportsExceptionOptions; supportsValueFormattingOptions; supportsExceptionInfoRequest; supportTerminateDebuggee; supportSuspendDebuggee; supportsDelayedStackTraceLoading})
     (obj10
    (opt "supportsCompletionsRequest" bool)
    (opt "completionTriggerCharacters" (list string))
    (opt "supportsModulesRequest" bool)
    (opt "supportsRestartRequest" bool)
    (opt "supportsExceptionOptions" bool)
    (opt "supportsValueFormattingOptions" bool)
    (opt "supportsExceptionInfoRequest" bool)
    (opt "supportTerminateDebuggee" bool)
    (opt "supportSuspendDebuggee" bool)
    (opt "supportsDelayedStackTraceLoading" bool))


     let make ?supportsCompletionsRequest ?completionTriggerCharacters ?supportsModulesRequest ?supportsRestartRequest ?supportsExceptionOptions ?supportsValueFormattingOptions ?supportsExceptionInfoRequest ?supportTerminateDebuggee ?supportSuspendDebuggee ?supportsDelayedStackTraceLoading () =
    {supportsCompletionsRequest; completionTriggerCharacters; supportsModulesRequest; supportsRestartRequest; supportsExceptionOptions; supportsValueFormattingOptions; supportsExceptionInfoRequest; supportTerminateDebuggee; supportSuspendDebuggee; supportsDelayedStackTraceLoading}

     end


    module Capabilities_20 = struct
     type t = { supportsLoadedSourcesRequest: bool option;
    supportsLogPoints: bool option;
    supportsTerminateThreadsRequest: bool option;
    supportsSetExpression: bool option;
    supportsTerminateRequest: bool option;
    supportsDataBreakpoints: bool option;
    supportsReadMemoryRequest: bool option;
    supportsWriteMemoryRequest: bool option;
    supportsDisassembleRequest: bool option;
    supportsCancelRequest: bool option; }

     let enc =
     let open Data_encoding in
     (* Capabilities_20.t *)
             conv
     (fun {supportsLoadedSourcesRequest; supportsLogPoints; supportsTerminateThreadsRequest; supportsSetExpression; supportsTerminateRequest; supportsDataBreakpoints; supportsReadMemoryRequest; supportsWriteMemoryRequest; supportsDisassembleRequest; supportsCancelRequest} -> (supportsLoadedSourcesRequest, supportsLogPoints, supportsTerminateThreadsRequest, supportsSetExpression, supportsTerminateRequest, supportsDataBreakpoints, supportsReadMemoryRequest, supportsWriteMemoryRequest, supportsDisassembleRequest, supportsCancelRequest))
     (fun (supportsLoadedSourcesRequest, supportsLogPoints, supportsTerminateThreadsRequest, supportsSetExpression, supportsTerminateRequest, supportsDataBreakpoints, supportsReadMemoryRequest, supportsWriteMemoryRequest, supportsDisassembleRequest, supportsCancelRequest) -> {supportsLoadedSourcesRequest; supportsLogPoints; supportsTerminateThreadsRequest; supportsSetExpression; supportsTerminateRequest; supportsDataBreakpoints; supportsReadMemoryRequest; supportsWriteMemoryRequest; supportsDisassembleRequest; supportsCancelRequest})
     (obj10
    (opt "supportsLoadedSourcesRequest" bool)
    (opt "supportsLogPoints" bool)
    (opt "supportsTerminateThreadsRequest" bool)
    (opt "supportsSetExpression" bool)
    (opt "supportsTerminateRequest" bool)
    (opt "supportsDataBreakpoints" bool)
    (opt "supportsReadMemoryRequest" bool)
    (opt "supportsWriteMemoryRequest" bool)
    (opt "supportsDisassembleRequest" bool)
    (opt "supportsCancelRequest" bool))


     let make ?supportsLoadedSourcesRequest ?supportsLogPoints ?supportsTerminateThreadsRequest ?supportsSetExpression ?supportsTerminateRequest ?supportsDataBreakpoints ?supportsReadMemoryRequest ?supportsWriteMemoryRequest ?supportsDisassembleRequest ?supportsCancelRequest () =
    {supportsLoadedSourcesRequest; supportsLogPoints; supportsTerminateThreadsRequest; supportsSetExpression; supportsTerminateRequest; supportsDataBreakpoints; supportsReadMemoryRequest; supportsWriteMemoryRequest; supportsDisassembleRequest; supportsCancelRequest}

     end


    module Capabilities_30 = struct
     type t = { supportsBreakpointLocationsRequest: bool option;
    supportsClipboardContext: bool option;
    supportsSteppingGranularity: bool option;
    supportsInstructionBreakpoints: bool option;
    supportsExceptionFilterOptions: bool option;
    supportsSingleThreadExecutionRequests: bool option; }

     let enc =
     let open Data_encoding in
     (* Capabilities_30.t *)
             conv
     (fun {supportsBreakpointLocationsRequest; supportsClipboardContext; supportsSteppingGranularity; supportsInstructionBreakpoints; supportsExceptionFilterOptions; supportsSingleThreadExecutionRequests} -> (supportsBreakpointLocationsRequest, supportsClipboardContext, supportsSteppingGranularity, supportsInstructionBreakpoints, supportsExceptionFilterOptions, supportsSingleThreadExecutionRequests))
     (fun (supportsBreakpointLocationsRequest, supportsClipboardContext, supportsSteppingGranularity, supportsInstructionBreakpoints, supportsExceptionFilterOptions, supportsSingleThreadExecutionRequests) -> {supportsBreakpointLocationsRequest; supportsClipboardContext; supportsSteppingGranularity; supportsInstructionBreakpoints; supportsExceptionFilterOptions; supportsSingleThreadExecutionRequests})
     (obj6
    (opt "supportsBreakpointLocationsRequest" bool)
    (opt "supportsClipboardContext" bool)
    (opt "supportsSteppingGranularity" bool)
    (opt "supportsInstructionBreakpoints" bool)
    (opt "supportsExceptionFilterOptions" bool)
    (opt "supportsSingleThreadExecutionRequests" bool))


     let make ?supportsBreakpointLocationsRequest ?supportsClipboardContext ?supportsSteppingGranularity ?supportsInstructionBreakpoints ?supportsExceptionFilterOptions ?supportsSingleThreadExecutionRequests () =
    {supportsBreakpointLocationsRequest; supportsClipboardContext; supportsSteppingGranularity; supportsInstructionBreakpoints; supportsExceptionFilterOptions; supportsSingleThreadExecutionRequests}

     end


     type t = (Capabilities_0.t * (Capabilities_10.t * (Capabilities_20.t * Capabilities_30.t)))

     let enc =
     let open Data_encoding in
     merge_objs Capabilities_0.enc @@ merge_objs Capabilities_10.enc @@ merge_objs Capabilities_20.enc Capabilities_30.enc

     let make ?supportsConfigurationDoneRequest ?supportsFunctionBreakpoints ?supportsConditionalBreakpoints ?supportsHitConditionalBreakpoints ?supportsEvaluateForHovers ?supportsStepBack ?supportsSetVariable ?supportsRestartFrame ?supportsGotoTargetsRequest ?supportsStepInTargetsRequest ?supportsCompletionsRequest ?completionTriggerCharacters ?supportsModulesRequest ?supportsRestartRequest ?supportsExceptionOptions ?supportsValueFormattingOptions ?supportsExceptionInfoRequest ?supportTerminateDebuggee ?supportSuspendDebuggee ?supportsDelayedStackTraceLoading ?supportsLoadedSourcesRequest ?supportsLogPoints ?supportsTerminateThreadsRequest ?supportsSetExpression ?supportsTerminateRequest ?supportsDataBreakpoints ?supportsReadMemoryRequest ?supportsWriteMemoryRequest ?supportsDisassembleRequest ?supportsCancelRequest ?supportsBreakpointLocationsRequest ?supportsClipboardContext ?supportsSteppingGranularity ?supportsInstructionBreakpoints ?supportsExceptionFilterOptions ?supportsSingleThreadExecutionRequests () =
    let t0 = Capabilities_0.make ?supportsConfigurationDoneRequest ?supportsFunctionBreakpoints ?supportsConditionalBreakpoints ?supportsHitConditionalBreakpoints ?supportsEvaluateForHovers ?supportsStepBack ?supportsSetVariable ?supportsRestartFrame ?supportsGotoTargetsRequest ?supportsStepInTargetsRequest () in

    let t1 = Capabilities_10.make ?supportsCompletionsRequest ?completionTriggerCharacters ?supportsModulesRequest ?supportsRestartRequest ?supportsExceptionOptions ?supportsValueFormattingOptions ?supportsExceptionInfoRequest ?supportTerminateDebuggee ?supportSuspendDebuggee ?supportsDelayedStackTraceLoading () in

    let t2 = Capabilities_20.make ?supportsLoadedSourcesRequest ?supportsLogPoints ?supportsTerminateThreadsRequest ?supportsSetExpression ?supportsTerminateRequest ?supportsDataBreakpoints ?supportsReadMemoryRequest ?supportsWriteMemoryRequest ?supportsDisassembleRequest ?supportsCancelRequest () in

    let t3 = Capabilities_30.make ?supportsBreakpointLocationsRequest ?supportsClipboardContext ?supportsSteppingGranularity ?supportsInstructionBreakpoints ?supportsExceptionFilterOptions ?supportsSingleThreadExecutionRequests () in

    (t0 , (t1 , (t2 , t3)))

     end


     type (_,_,_) request =


     type (_,_,_) response =


     type (_,_,_) event = |}]


let%expect_test "Check anyOf example" =
  let schema_js = Ezjsonm.from_channel @@ open_in "data/anyof.json" in
  let dfs = Dfs.make ~schema_js in
  let actual = render dfs Messages in
  Printf.printf "%s" actual;
  [%expect {|
    (* NOTE this file was autogenerated - do not modify by hand *)

     open Dap_t

     module SomeExample = struct
     type t = { moduleId: IntString.t option;
    adapterData: Data_encoding.json option; }

     let enc =
     let open Data_encoding in
     (* SomeExample.t *)
             conv
     (fun {moduleId; adapterData} -> (moduleId, adapterData))
     (fun (moduleId, adapterData) -> {moduleId; adapterData})
     (obj2
    (opt "moduleId" IntString.enc)
    (opt "adapterData" json))


     let make ?moduleId ?adapterData () =
    {moduleId; adapterData}

     end


     type (_,_,_) request =


     type (_,_,_) response =


     type (_,_,_) event = |}]

let%expect_test "Check oneOf example" =
  let schema_js = Ezjsonm.from_channel @@ open_in "data/restartRequest.json" in
  let dfs = Dfs.make ~schema_js in
  let actual = render dfs Messages in
  Printf.printf "%s" actual;
  [%expect {|
    (* NOTE this file was autogenerated - do not modify by hand *)

     open Dap_t



     type (_,_,_) request =
    | RestartRequest : (Dap_command.restart, RestartArguments.t option, RequestMessage.opt) RequestMessage.t -> (Dap_command.restart, RestartArguments.t option, RequestMessage.opt) request

     type (_,_,_) response =


     type (_,_,_) event = |}]


let%expect_test "Check nullable example" =
  let schema_js = Ezjsonm.from_channel @@ open_in "data/nullableString.json" in
  let dfs = Dfs.make ~schema_js in
  let actual = render dfs Messages in
  Printf.printf "%s" actual;
  [%expect {|
    (* NOTE this file was autogenerated - do not modify by hand *)

     open Dap_t

     module ExceptionDetails = struct
     type t = { message: string option;
    typeName: string option; }

     let enc =
     let open Data_encoding in
     (* ExceptionDetails.t *)
             conv
     (fun {message; typeName} -> (message, typeName))
     (fun (message, typeName) -> {message; typeName})
     (obj2
    (opt "message" string)
    (req "typeName" (option string)))


     let make ?message ~typeName () =
    {message; typeName}

     end


     type (_,_,_) request =


     type (_,_,_) response =


     type (_,_,_) event = |}]


let%expect_test "Check valueFormat example" =
  let schema_js = Ezjsonm.from_channel @@ open_in "data/valueFormatExample.json" in
  let dfs = Dfs.make ~schema_js in
  let actual = render dfs Messages in
  Printf.printf "%s" actual;
  [%expect {|
    (* NOTE this file was autogenerated - do not modify by hand *)

     open Dap_t

     module ValueFormat = struct
     type t = { hex: bool option; }

     let enc =
     let open Data_encoding in
     (* ValueFormat.t *)
             conv
     (fun {hex} -> hex)
     (fun hex -> {hex})
     (obj1
    (opt "hex" bool))


     let make ?hex () =
    {hex}

     end


    module StackFrameFormat = struct
     type t = { hex: bool option;
    parameters: bool option;
    parameterTypes: bool option;
    parameterNames: bool option;
    parameterValues: bool option;
    line: bool option;
    module_: bool option;
    includeAll: bool option; }

     let enc =
     let open Data_encoding in
     (* StackFrameFormat.t *)
             conv
     (fun {hex; parameters; parameterTypes; parameterNames; parameterValues; line; module_; includeAll} -> (hex, parameters, parameterTypes, parameterNames, parameterValues, line, module_, includeAll))
     (fun (hex, parameters, parameterTypes, parameterNames, parameterValues, line, module_, includeAll) -> {hex; parameters; parameterTypes; parameterNames; parameterValues; line; module_; includeAll})
     (obj8
    (opt "hex" bool)
    (opt "parameters" bool)
    (opt "parameterTypes" bool)
    (opt "parameterNames" bool)
    (opt "parameterValues" bool)
    (opt "line" bool)
    (opt "module" bool)
    (opt "includeAll" bool))


     let make ?hex ?parameters ?parameterTypes ?parameterNames ?parameterValues ?line ?module_ ?includeAll () =
    {hex; parameters; parameterTypes; parameterNames; parameterValues; line; module_; includeAll}

     end


     type (_,_,_) request =


     type (_,_,_) response =


     type (_,_,_) event = |}]

let%expect_test "Check empty example" =
  let schema_js = Ezjsonm.from_channel @@ open_in "data/emptyObject.json" in
  let dfs = Dfs.make ~schema_js in
  let actual = render dfs Messages in
  Printf.printf "%s" actual;
  [%expect {|
    (* NOTE this file was autogenerated - do not modify by hand *)

     open Dap_t

     module ConfigurationDoneArguments = struct
     type t = unit

     let enc = Data_encoding.empty

     let make () = ()

     end




     type (_,_,_) request =
    | ConfigurationDoneRequest : (Dap_command.configurationDone, ConfigurationDoneArguments.t option, RequestMessage.opt) RequestMessage.t -> (Dap_command.configurationDone, ConfigurationDoneArguments.t option, RequestMessage.opt) request

     type (_,_,_) response =


     type (_,_,_) event = |}]


let%expect_test "Check LaunchResponse empty body  example" =
  let schema_js = Ezjsonm.from_channel @@ open_in "data/launchResponseEmptyExample.json" in
  let dfs = Dfs.make ~schema_js in
  let actual = render dfs Messages in
  Printf.printf "%s" actual;
  [%expect {|
    (* NOTE this file was autogenerated - do not modify by hand *)

     open Dap_t



     type (_,_,_) request =


     type (_,_,_) response =
    | LaunchResponse : (Dap_command.launch, EmptyObject.t option, ResponseMessage.opt) ResponseMessage.t -> (Dap_command.launch, EmptyObject.t option, ResponseMessage.opt) response

     type (_,_,_) event = |}]
