(* NOTE this file was autogenerated - do not modify by hand *)

include Dap_base
module RequestMessage = Dap_request
module ResponseMessage = Dap_response
module EventMessage = Dap_event

module Message : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    id:int ->
    format:string ->
    ?variables:Data_encoding.json ->
    ?sendTelemetry:bool ->
    ?showUser:bool ->
    ?url:string ->
    ?urlLabel:string ->
    unit ->
    t

  val id : t -> int

  val format : t -> string

  val variables : t -> Data_encoding.json option

  val sendTelemetry : t -> bool option

  val showUser : t -> bool option

  val url : t -> string option

  val urlLabel : t -> string option
end = struct
  type t = {
    id : (int[@gen gen_int31]);
    format : (string[@gen gen_utf8_str]);
    variables : (Data_encoding.json option[@gen gen_json_opt]);
    sendTelemetry : bool option;
    showUser : bool option;
    url : (string option[@gen gen_utf8_str_opt]);
    urlLabel : (string option[@gen gen_utf8_str_opt]);
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* Message.t *)
    conv
      (fun {id; format; variables; sendTelemetry; showUser; url; urlLabel} ->
        (id, format, variables, sendTelemetry, showUser, url, urlLabel))
      (fun (id, format, variables, sendTelemetry, showUser, url, urlLabel) ->
        {id; format; variables; sendTelemetry; showUser; url; urlLabel})
      (obj7
         (req "id" int31)
         (req "format" string)
         (opt "variables" json)
         (opt "sendTelemetry" bool)
         (opt "showUser" bool)
         (opt "url" string)
         (opt "urlLabel" string))

  let make ~id ~format ?variables ?sendTelemetry ?showUser ?url ?urlLabel () =
    {id; format; variables; sendTelemetry; showUser; url; urlLabel}

  let id t = t.id

  let format t = t.format

  let variables t = t.variables

  let sendTelemetry t = t.sendTelemetry

  let showUser t = t.showUser

  let url t = t.url

  let urlLabel t = t.urlLabel
end

module ErrorResponse_body : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : ?error:Message.t -> unit -> t

  val error : t -> Message.t option
end = struct
  type t = {error : Message.t option} [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* ErrorResponse_body.t *)
    conv
      (fun {error} -> error)
      (fun error -> {error})
      (obj1 (opt "error" Message.enc))

  let make ?error () = {error}

  let error t = t.error
end

module CancelArguments : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : ?requestId:int -> ?progressId:string -> unit -> t

  val requestId : t -> int option

  val progressId : t -> string option
end = struct
  type t = {
    requestId : (int option[@gen gen_int31_opt]);
    progressId : (string option[@gen gen_utf8_str_opt]);
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* CancelArguments.t *)
    conv
      (fun {requestId; progressId} -> (requestId, progressId))
      (fun (requestId, progressId) -> {requestId; progressId})
      (obj2 (opt "requestId" int31) (opt "progressId" string))

  let make ?requestId ?progressId () = {requestId; progressId}

  let requestId t = t.requestId

  let progressId t = t.progressId
end

(* dont bother with a sig for enums, the inferred one is fine *)
module StoppedEvent_body_reason = struct
  type t =
    | Step
    | Breakpoint
    | Exception
    | Pause
    | Entry
    | Goto
    | Function_breakpoint
    | Data_breakpoint
    | Instruction_breakpoint
    | Other of (string [@gen gen_utf8_str])
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    conv_with_guard
      (function
        | Step -> "step"
        | Breakpoint -> "breakpoint"
        | Exception -> "exception"
        | Pause -> "pause"
        | Entry -> "entry"
        | Goto -> "goto"
        | Function_breakpoint -> "function breakpoint"
        | Data_breakpoint -> "data breakpoint"
        | Instruction_breakpoint -> "instruction breakpoint"
        | Other s -> s)
      (function
        | "step" -> Ok Step
        | "breakpoint" -> Ok Breakpoint
        | "exception" -> Ok Exception
        | "pause" -> Ok Pause
        | "entry" -> Ok Entry
        | "goto" -> Ok Goto
        | "function breakpoint" -> Ok Function_breakpoint
        | "data breakpoint" -> Ok Data_breakpoint
        | "instruction breakpoint" -> Ok Instruction_breakpoint
        | _ as s -> Ok (Other s))
      string
end

module StoppedEvent_body : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    reason:StoppedEvent_body_reason.t ->
    ?description:string ->
    ?threadId:int ->
    ?preserveFocusHint:bool ->
    ?text:string ->
    ?allThreadsStopped:bool ->
    ?hitBreakpointIds:int list ->
    unit ->
    t

  val reason : t -> StoppedEvent_body_reason.t

  val description : t -> string option

  val threadId : t -> int option

  val preserveFocusHint : t -> bool option

  val text : t -> string option

  val allThreadsStopped : t -> bool option

  val hitBreakpointIds : t -> int list option
end = struct
  type t = {
    reason : StoppedEvent_body_reason.t;
    description : (string option[@gen gen_utf8_str_opt]);
    threadId : (int option[@gen gen_int31_opt]);
    preserveFocusHint : bool option;
    text : (string option[@gen gen_utf8_str_opt]);
    allThreadsStopped : bool option;
    hitBreakpointIds : (int list option[@gen gen_int31_list_opt]);
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* StoppedEvent_body.t *)
    conv
      (fun {
             reason;
             description;
             threadId;
             preserveFocusHint;
             text;
             allThreadsStopped;
             hitBreakpointIds;
           } ->
        ( reason,
          description,
          threadId,
          preserveFocusHint,
          text,
          allThreadsStopped,
          hitBreakpointIds ))
      (fun ( reason,
             description,
             threadId,
             preserveFocusHint,
             text,
             allThreadsStopped,
             hitBreakpointIds ) ->
        {
          reason;
          description;
          threadId;
          preserveFocusHint;
          text;
          allThreadsStopped;
          hitBreakpointIds;
        })
      (obj7
         (req "reason" StoppedEvent_body_reason.enc)
         (opt "description" string)
         (opt "threadId" int31)
         (opt "preserveFocusHint" bool)
         (opt "text" string)
         (opt "allThreadsStopped" bool)
         (opt "hitBreakpointIds" (list int31)))

  let make ~reason ?description ?threadId ?preserveFocusHint ?text
      ?allThreadsStopped ?hitBreakpointIds () =
    {
      reason;
      description;
      threadId;
      preserveFocusHint;
      text;
      allThreadsStopped;
      hitBreakpointIds;
    }

  let reason t = t.reason

  let description t = t.description

  let threadId t = t.threadId

  let preserveFocusHint t = t.preserveFocusHint

  let text t = t.text

  let allThreadsStopped t = t.allThreadsStopped

  let hitBreakpointIds t = t.hitBreakpointIds
end

module ContinuedEvent_body : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : threadId:int -> ?allThreadsContinued:bool -> unit -> t

  val threadId : t -> int

  val allThreadsContinued : t -> bool option
end = struct
  type t = {threadId : (int[@gen gen_int31]); allThreadsContinued : bool option}
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* ContinuedEvent_body.t *)
    conv
      (fun {threadId; allThreadsContinued} -> (threadId, allThreadsContinued))
      (fun (threadId, allThreadsContinued) -> {threadId; allThreadsContinued})
      (obj2 (req "threadId" int31) (opt "allThreadsContinued" bool))

  let make ~threadId ?allThreadsContinued () = {threadId; allThreadsContinued}

  let threadId t = t.threadId

  let allThreadsContinued t = t.allThreadsContinued
end

module ExitedEvent_body : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : exitCode:int -> unit -> t

  val exitCode : t -> int
end = struct
  type t = {exitCode : int} [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* ExitedEvent_body.t *)
    conv
      (fun {exitCode} -> exitCode)
      (fun exitCode -> {exitCode})
      (obj1 (req "exitCode" int31))

  let make ~exitCode () = {exitCode}

  let exitCode t = t.exitCode
end

module TerminatedEvent_body : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : ?restart:Data_encoding.json -> unit -> t

  val restart : t -> Data_encoding.json option
end = struct
  type t = {restart : (Data_encoding.json option[@gen gen_json_opt])}
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* TerminatedEvent_body.t *)
    conv
      (fun {restart} -> restart)
      (fun restart -> {restart})
      (obj1 (opt "restart" json))

  let make ?restart () = {restart}

  let restart t = t.restart
end

(* dont bother with a sig for enums, the inferred one is fine *)
module ThreadEvent_body_reason = struct
  type t = Started | Exited | Other of (string [@gen gen_utf8_str]) [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    conv_with_guard
      (function Started -> "started" | Exited -> "exited" | Other s -> s)
      (function
        | "started" -> Ok Started
        | "exited" -> Ok Exited
        | _ as s -> Ok (Other s))
      string
end

module ThreadEvent_body : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : reason:ThreadEvent_body_reason.t -> threadId:int -> unit -> t

  val reason : t -> ThreadEvent_body_reason.t

  val threadId : t -> int
end = struct
  type t = {reason : ThreadEvent_body_reason.t; threadId : int}
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* ThreadEvent_body.t *)
    conv
      (fun {reason; threadId} -> (reason, threadId))
      (fun (reason, threadId) -> {reason; threadId})
      (obj2 (req "reason" ThreadEvent_body_reason.enc) (req "threadId" int31))

  let make ~reason ~threadId () = {reason; threadId}

  let reason t = t.reason

  let threadId t = t.threadId
end

(* dont bother with a sig for enums, the inferred one is fine *)
module OutputEvent_body_category = struct
  type t = Console | Important | Stdout | Stderr | Telemetry | Other of (string [@gen gen_utf8_str])
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    conv_with_guard
      (function
        | Console -> "console"
        | Important -> "important"
        | Stdout -> "stdout"
        | Stderr -> "stderr"
        | Telemetry -> "telemetry"
        | Other s -> s)
      (function
        | "console" -> Ok Console
        | "important" -> Ok Important
        | "stdout" -> Ok Stdout
        | "stderr" -> Ok Stderr
        | "telemetry" -> Ok Telemetry
        | _ as s -> Ok (Other s))
      string
end

(* dont bother with a sig for enums, the inferred one is fine *)
module OutputEvent_body_group = struct
  type t = Start | StartCollapsed | End [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    conv_with_guard
      (function
        | Start -> "start" | StartCollapsed -> "startCollapsed" | End -> "end")
      (function
        | "start" -> Ok Start
        | "startCollapsed" -> Ok StartCollapsed
        | "end" -> Ok End
        | _ -> Error "OutputEvent_body_group")
      string
end

(* dont bother with a sig for enums, the inferred one is fine *)
module Source_presentationHint = struct
  type t = Normal | Emphasize | Deemphasize [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    conv_with_guard
      (function
        | Normal -> "normal"
        | Emphasize -> "emphasize"
        | Deemphasize -> "deemphasize")
      (function
        | "normal" -> Ok Normal
        | "emphasize" -> Ok Emphasize
        | "deemphasize" -> Ok Deemphasize
        | _ -> Error "Source_presentationHint")
      string
end

(* dont bother with a sig for enums, the inferred one is fine *)
module ChecksumAlgorithm = struct
  type t = MD5 | SHA1 | SHA256 | Timestamp [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    conv_with_guard
      (function
        | MD5 -> "MD5"
        | SHA1 -> "SHA1"
        | SHA256 -> "SHA256"
        | Timestamp -> "timestamp")
      (function
        | "MD5" -> Ok MD5
        | "SHA1" -> Ok SHA1
        | "SHA256" -> Ok SHA256
        | "timestamp" -> Ok Timestamp
        | _ -> Error "ChecksumAlgorithm")
      string
end

module Checksum : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : algorithm:ChecksumAlgorithm.t -> checksum:string -> unit -> t

  val algorithm : t -> ChecksumAlgorithm.t

  val checksum : t -> string
end = struct
  type t = {
    algorithm : ChecksumAlgorithm.t;
    checksum : (string[@gen gen_utf8_str]);
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* Checksum.t *)
    conv
      (fun {algorithm; checksum} -> (algorithm, checksum))
      (fun (algorithm, checksum) -> {algorithm; checksum})
      (obj2 (req "algorithm" ChecksumAlgorithm.enc) (req "checksum" string))

  let make ~algorithm ~checksum () = {algorithm; checksum}

  let algorithm t = t.algorithm

  let checksum t = t.checksum
end

module Source : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    ?name:string ->
    ?path:string ->
    ?sourceReference:int ->
    ?presentationHint:Source_presentationHint.t ->
    ?origin:string ->
    ?sources:t list ->
    ?adapterData:Data_encoding.json ->
    ?checksums:Checksum.t list ->
    unit ->
    t

  val name : t -> string option

  val path : t -> string option

  val sourceReference : t -> int option

  val presentationHint : t -> Source_presentationHint.t option

  val origin : t -> string option

  val sources : t -> t list option

  val adapterData : t -> Data_encoding.json option

  val checksums : t -> Checksum.t list option
end = struct
  type t = {
    name : (string option[@gen gen_utf8_str_opt]);
    path : (string option[@gen gen_utf8_str_opt]);
    sourceReference : (int option[@gen gen_int31_opt]);
    presentationHint : Source_presentationHint.t option;
    origin : (string option[@gen gen_utf8_str_opt]);
    sources : (t list option[@gen QCheck.Gen.pure None]);
    adapterData : (Data_encoding.json option[@gen gen_json_opt]);
    checksums : Checksum.t list option;
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    mu "Source.t" (fun e ->
        conv
          (fun {
                 name;
                 path;
                 sourceReference;
                 presentationHint;
                 origin;
                 sources;
                 adapterData;
                 checksums;
               } ->
            ( name,
              path,
              sourceReference,
              presentationHint,
              origin,
              sources,
              adapterData,
              checksums ))
          (fun ( name,
                 path,
                 sourceReference,
                 presentationHint,
                 origin,
                 sources,
                 adapterData,
                 checksums ) ->
            {
              name;
              path;
              sourceReference;
              presentationHint;
              origin;
              sources;
              adapterData;
              checksums;
            })
          (obj8
             (opt "name" string)
             (opt "path" string)
             (opt "sourceReference" int31)
             (opt "presentationHint" Source_presentationHint.enc)
             (opt "origin" string)
             (opt "sources" (list e))
             (opt "adapterData" json)
             (opt "checksums" (list Checksum.enc))))

  let make ?name ?path ?sourceReference ?presentationHint ?origin ?sources
      ?adapterData ?checksums () =
    {
      name;
      path;
      sourceReference;
      presentationHint;
      origin;
      sources;
      adapterData;
      checksums;
    }

  let name t = t.name

  let path t = t.path

  let sourceReference t = t.sourceReference

  let presentationHint t = t.presentationHint

  let origin t = t.origin

  let sources t = t.sources

  let adapterData t = t.adapterData

  let checksums t = t.checksums
end

module OutputEvent_body : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    ?category:OutputEvent_body_category.t ->
    output:string ->
    ?group:OutputEvent_body_group.t ->
    ?variablesReference:int ->
    ?source:Source.t ->
    ?line:int ->
    ?column:int ->
    ?data:Data_encoding.json ->
    unit ->
    t

  val category : t -> OutputEvent_body_category.t option

  val output : t -> string

  val group : t -> OutputEvent_body_group.t option

  val variablesReference : t -> int option

  val source : t -> Source.t option

  val line : t -> int option

  val column : t -> int option

  val data : t -> Data_encoding.json option
end = struct
  type t = {
    category : OutputEvent_body_category.t option;
    output : (string[@gen gen_utf8_str]);
    group : OutputEvent_body_group.t option;
    variablesReference : (int option[@gen gen_int31_opt]);
    source : Source.t option;
    line : (int option[@gen gen_int31_opt]);
    column : (int option[@gen gen_int31_opt]);
    data : (Data_encoding.json option[@gen gen_json_opt]);
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* OutputEvent_body.t *)
    conv
      (fun {
             category;
             output;
             group;
             variablesReference;
             source;
             line;
             column;
             data;
           } ->
        (category, output, group, variablesReference, source, line, column, data))
      (fun ( category,
             output,
             group,
             variablesReference,
             source,
             line,
             column,
             data ) ->
        {
          category;
          output;
          group;
          variablesReference;
          source;
          line;
          column;
          data;
        })
      (obj8
         (opt "category" OutputEvent_body_category.enc)
         (req "output" string)
         (opt "group" OutputEvent_body_group.enc)
         (opt "variablesReference" int31)
         (opt "source" Source.enc)
         (opt "line" int31)
         (opt "column" int31)
         (opt "data" json))

  let make ?category ~output ?group ?variablesReference ?source ?line ?column
      ?data () =
    {category; output; group; variablesReference; source; line; column; data}

  let category t = t.category

  let output t = t.output

  let group t = t.group

  let variablesReference t = t.variablesReference

  let source t = t.source

  let line t = t.line

  let column t = t.column

  let data t = t.data
end

(* dont bother with a sig for enums, the inferred one is fine *)
module BreakpointEvent_body_reason = struct
  type t = Changed | New | Removed | Other of (string [@gen gen_utf8_str]) [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    conv_with_guard
      (function
        | Changed -> "changed"
        | New -> "new"
        | Removed -> "removed"
        | Other s -> s)
      (function
        | "changed" -> Ok Changed
        | "new" -> Ok New
        | "removed" -> Ok Removed
        | _ as s -> Ok (Other s))
      string
end

module Breakpoint : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    ?id:int ->
    verified:bool ->
    ?message:string ->
    ?source:Source.t ->
    ?line:int ->
    ?column:int ->
    ?endLine:int ->
    ?endColumn:int ->
    ?instructionReference:string ->
    ?offset:int ->
    unit ->
    t

  val id : t -> int option

  val verified : t -> bool

  val message : t -> string option

  val source : t -> Source.t option

  val line : t -> int option

  val column : t -> int option

  val endLine : t -> int option

  val endColumn : t -> int option

  val instructionReference : t -> string option

  val offset : t -> int option
end = struct
  type t = {
    id : (int option[@gen gen_int31_opt]);
    verified : bool;
    message : (string option[@gen gen_utf8_str_opt]);
    source : Source.t option;
    line : (int option[@gen gen_int31_opt]);
    column : (int option[@gen gen_int31_opt]);
    endLine : (int option[@gen gen_int31_opt]);
    endColumn : (int option[@gen gen_int31_opt]);
    instructionReference : (string option[@gen gen_utf8_str_opt]);
    offset : (int option[@gen gen_int31_opt]);
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* Breakpoint.t *)
    conv
      (fun {
             id;
             verified;
             message;
             source;
             line;
             column;
             endLine;
             endColumn;
             instructionReference;
             offset;
           } ->
        ( id,
          verified,
          message,
          source,
          line,
          column,
          endLine,
          endColumn,
          instructionReference,
          offset ))
      (fun ( id,
             verified,
             message,
             source,
             line,
             column,
             endLine,
             endColumn,
             instructionReference,
             offset ) ->
        {
          id;
          verified;
          message;
          source;
          line;
          column;
          endLine;
          endColumn;
          instructionReference;
          offset;
        })
      (obj10
         (opt "id" int31)
         (req "verified" bool)
         (opt "message" string)
         (opt "source" Source.enc)
         (opt "line" int31)
         (opt "column" int31)
         (opt "endLine" int31)
         (opt "endColumn" int31)
         (opt "instructionReference" string)
         (opt "offset" int31))

  let make ?id ~verified ?message ?source ?line ?column ?endLine ?endColumn
      ?instructionReference ?offset () =
    {
      id;
      verified;
      message;
      source;
      line;
      column;
      endLine;
      endColumn;
      instructionReference;
      offset;
    }

  let id t = t.id

  let verified t = t.verified

  let message t = t.message

  let source t = t.source

  let line t = t.line

  let column t = t.column

  let endLine t = t.endLine

  let endColumn t = t.endColumn

  let instructionReference t = t.instructionReference

  let offset t = t.offset
end

module BreakpointEvent_body : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    reason:BreakpointEvent_body_reason.t -> breakpoint:Breakpoint.t -> unit -> t

  val reason : t -> BreakpointEvent_body_reason.t

  val breakpoint : t -> Breakpoint.t
end = struct
  type t = {reason : BreakpointEvent_body_reason.t; breakpoint : Breakpoint.t}
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* BreakpointEvent_body.t *)
    conv
      (fun {reason; breakpoint} -> (reason, breakpoint))
      (fun (reason, breakpoint) -> {reason; breakpoint})
      (obj2
         (req "reason" BreakpointEvent_body_reason.enc)
         (req "breakpoint" Breakpoint.enc))

  let make ~reason ~breakpoint () = {reason; breakpoint}

  let reason t = t.reason

  let breakpoint t = t.breakpoint
end

(* dont bother with a sig for enums, the inferred one is fine *)
module ModuleEvent_body_reason = struct
  type t = New | Changed | Removed [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    conv_with_guard
      (function New -> "new" | Changed -> "changed" | Removed -> "removed")
      (function
        | "new" -> Ok New
        | "changed" -> Ok Changed
        | "removed" -> Ok Removed
        | _ -> Error "ModuleEvent_body_reason")
      string
end

module Module_ : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    id:IntString.t ->
    name:string ->
    ?path:string ->
    ?isOptimized:bool ->
    ?isUserCode:bool ->
    ?version:string ->
    ?symbolStatus:string ->
    ?symbolFilePath:string ->
    ?dateTimeStamp:string ->
    ?addressRange:string ->
    unit ->
    t

  val id : t -> IntString.t

  val name : t -> string

  val path : t -> string option

  val isOptimized : t -> bool option

  val isUserCode : t -> bool option

  val version : t -> string option

  val symbolStatus : t -> string option

  val symbolFilePath : t -> string option

  val dateTimeStamp : t -> string option

  val addressRange : t -> string option
end = struct
  type t = {
    id : IntString.t;
    name : (string[@gen gen_utf8_str]);
    path : (string option[@gen gen_utf8_str_opt]);
    isOptimized : bool option;
    isUserCode : bool option;
    version : (string option[@gen gen_utf8_str_opt]);
    symbolStatus : (string option[@gen gen_utf8_str_opt]);
    symbolFilePath : (string option[@gen gen_utf8_str_opt]);
    dateTimeStamp : (string option[@gen gen_utf8_str_opt]);
    addressRange : (string option[@gen gen_utf8_str_opt]);
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* Module_.t *)
    conv
      (fun {
             id;
             name;
             path;
             isOptimized;
             isUserCode;
             version;
             symbolStatus;
             symbolFilePath;
             dateTimeStamp;
             addressRange;
           } ->
        ( id,
          name,
          path,
          isOptimized,
          isUserCode,
          version,
          symbolStatus,
          symbolFilePath,
          dateTimeStamp,
          addressRange ))
      (fun ( id,
             name,
             path,
             isOptimized,
             isUserCode,
             version,
             symbolStatus,
             symbolFilePath,
             dateTimeStamp,
             addressRange ) ->
        {
          id;
          name;
          path;
          isOptimized;
          isUserCode;
          version;
          symbolStatus;
          symbolFilePath;
          dateTimeStamp;
          addressRange;
        })
      (obj10
         (req "id" IntString.enc)
         (req "name" string)
         (opt "path" string)
         (opt "isOptimized" bool)
         (opt "isUserCode" bool)
         (opt "version" string)
         (opt "symbolStatus" string)
         (opt "symbolFilePath" string)
         (opt "dateTimeStamp" string)
         (opt "addressRange" string))

  let make ~id ~name ?path ?isOptimized ?isUserCode ?version ?symbolStatus
      ?symbolFilePath ?dateTimeStamp ?addressRange () =
    {
      id;
      name;
      path;
      isOptimized;
      isUserCode;
      version;
      symbolStatus;
      symbolFilePath;
      dateTimeStamp;
      addressRange;
    }

  let id t = t.id

  let name t = t.name

  let path t = t.path

  let isOptimized t = t.isOptimized

  let isUserCode t = t.isUserCode

  let version t = t.version

  let symbolStatus t = t.symbolStatus

  let symbolFilePath t = t.symbolFilePath

  let dateTimeStamp t = t.dateTimeStamp

  let addressRange t = t.addressRange
end

module ModuleEvent_body : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : reason:ModuleEvent_body_reason.t -> module_:Module_.t -> unit -> t

  val reason : t -> ModuleEvent_body_reason.t

  val module_ : t -> Module_.t
end = struct
  type t = {reason : ModuleEvent_body_reason.t; module_ : Module_.t}
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* ModuleEvent_body.t *)
    conv
      (fun {reason; module_} -> (reason, module_))
      (fun (reason, module_) -> {reason; module_})
      (obj2
         (req "reason" ModuleEvent_body_reason.enc)
         (req "module" Module_.enc))

  let make ~reason ~module_ () = {reason; module_}

  let reason t = t.reason

  let module_ t = t.module_
end

(* dont bother with a sig for enums, the inferred one is fine *)
module LoadedSourceEvent_body_reason = struct
  type t = New | Changed | Removed [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    conv_with_guard
      (function New -> "new" | Changed -> "changed" | Removed -> "removed")
      (function
        | "new" -> Ok New
        | "changed" -> Ok Changed
        | "removed" -> Ok Removed
        | _ -> Error "LoadedSourceEvent_body_reason")
      string
end

module LoadedSourceEvent_body : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    reason:LoadedSourceEvent_body_reason.t -> source:Source.t -> unit -> t

  val reason : t -> LoadedSourceEvent_body_reason.t

  val source : t -> Source.t
end = struct
  type t = {reason : LoadedSourceEvent_body_reason.t; source : Source.t}
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* LoadedSourceEvent_body.t *)
    conv
      (fun {reason; source} -> (reason, source))
      (fun (reason, source) -> {reason; source})
      (obj2
         (req "reason" LoadedSourceEvent_body_reason.enc)
         (req "source" Source.enc))

  let make ~reason ~source () = {reason; source}

  let reason t = t.reason

  let source t = t.source
end

(* dont bother with a sig for enums, the inferred one is fine *)
module ProcessEvent_body_startMethod = struct
  type t = Launch | Attach | AttachForSuspendedLaunch [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    conv_with_guard
      (function
        | Launch -> "launch"
        | Attach -> "attach"
        | AttachForSuspendedLaunch -> "attachForSuspendedLaunch")
      (function
        | "launch" -> Ok Launch
        | "attach" -> Ok Attach
        | "attachForSuspendedLaunch" -> Ok AttachForSuspendedLaunch
        | _ -> Error "ProcessEvent_body_startMethod")
      string
end

module ProcessEvent_body : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    name:string ->
    ?systemProcessId:int ->
    ?isLocalProcess:bool ->
    ?startMethod:ProcessEvent_body_startMethod.t ->
    ?pointerSize:int ->
    unit ->
    t

  val name : t -> string

  val systemProcessId : t -> int option

  val isLocalProcess : t -> bool option

  val startMethod : t -> ProcessEvent_body_startMethod.t option

  val pointerSize : t -> int option
end = struct
  type t = {
    name : (string[@gen gen_utf8_str]);
    systemProcessId : (int option[@gen gen_int31_opt]);
    isLocalProcess : bool option;
    startMethod : ProcessEvent_body_startMethod.t option;
    pointerSize : (int option[@gen gen_int31_opt]);
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* ProcessEvent_body.t *)
    conv
      (fun {name; systemProcessId; isLocalProcess; startMethod; pointerSize} ->
        (name, systemProcessId, isLocalProcess, startMethod, pointerSize))
      (fun (name, systemProcessId, isLocalProcess, startMethod, pointerSize) ->
        {name; systemProcessId; isLocalProcess; startMethod; pointerSize})
      (obj5
         (req "name" string)
         (opt "systemProcessId" int31)
         (opt "isLocalProcess" bool)
         (opt "startMethod" ProcessEvent_body_startMethod.enc)
         (opt "pointerSize" int31))

  let make ~name ?systemProcessId ?isLocalProcess ?startMethod ?pointerSize () =
    {name; systemProcessId; isLocalProcess; startMethod; pointerSize}

  let name t = t.name

  let systemProcessId t = t.systemProcessId

  let isLocalProcess t = t.isLocalProcess

  let startMethod t = t.startMethod

  let pointerSize t = t.pointerSize
end

module ExceptionBreakpointsFilter : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    filter:string ->
    label:string ->
    ?description:string ->
    ?default:bool ->
    ?supportsCondition:bool ->
    ?conditionDescription:string ->
    unit ->
    t

  val filter : t -> string

  val label : t -> string

  val description : t -> string option

  val default : t -> bool option

  val supportsCondition : t -> bool option

  val conditionDescription : t -> string option
end = struct
  type t = {
    filter : (string[@gen gen_utf8_str]);
    label : (string[@gen gen_utf8_str]);
    description : (string option[@gen gen_utf8_str_opt]);
    default : bool option;
    supportsCondition : bool option;
    conditionDescription : (string option[@gen gen_utf8_str_opt]);
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* ExceptionBreakpointsFilter.t *)
    conv
      (fun {
             filter;
             label;
             description;
             default;
             supportsCondition;
             conditionDescription;
           } ->
        ( filter,
          label,
          description,
          default,
          supportsCondition,
          conditionDescription ))
      (fun ( filter,
             label,
             description,
             default,
             supportsCondition,
             conditionDescription ) ->
        {
          filter;
          label;
          description;
          default;
          supportsCondition;
          conditionDescription;
        })
      (obj6
         (req "filter" string)
         (req "label" string)
         (opt "description" string)
         (opt "default" bool)
         (opt "supportsCondition" bool)
         (opt "conditionDescription" string))

  let make ~filter ~label ?description ?default ?supportsCondition
      ?conditionDescription () =
    {
      filter;
      label;
      description;
      default;
      supportsCondition;
      conditionDescription;
    }

  let filter t = t.filter

  let label t = t.label

  let description t = t.description

  let default t = t.default

  let supportsCondition t = t.supportsCondition

  let conditionDescription t = t.conditionDescription
end

(* dont bother with a sig for enums, the inferred one is fine *)
module ColumnDescriptor_type_ = struct
  type t = String | Number | Boolean | UnixTimestampUTC [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    conv_with_guard
      (function
        | String -> "string"
        | Number -> "number"
        | Boolean -> "boolean"
        | UnixTimestampUTC -> "unixTimestampUTC")
      (function
        | "string" -> Ok String
        | "number" -> Ok Number
        | "boolean" -> Ok Boolean
        | "unixTimestampUTC" -> Ok UnixTimestampUTC
        | _ -> Error "ColumnDescriptor_type_")
      string
end

module ColumnDescriptor : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    attributeName:string ->
    label:string ->
    ?format:string ->
    ?type_:ColumnDescriptor_type_.t ->
    ?width:int ->
    unit ->
    t

  val attributeName : t -> string

  val label : t -> string

  val format : t -> string option

  val type_ : t -> ColumnDescriptor_type_.t option

  val width : t -> int option
end = struct
  type t = {
    attributeName : (string[@gen gen_utf8_str]);
    label : (string[@gen gen_utf8_str]);
    format : (string option[@gen gen_utf8_str_opt]);
    type_ : ColumnDescriptor_type_.t option;
    width : (int option[@gen gen_int31_opt]);
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* ColumnDescriptor.t *)
    conv
      (fun {attributeName; label; format; type_; width} ->
        (attributeName, label, format, type_, width))
      (fun (attributeName, label, format, type_, width) ->
        {attributeName; label; format; type_; width})
      (obj5
         (req "attributeName" string)
         (req "label" string)
         (opt "format" string)
         (opt "type" ColumnDescriptor_type_.enc)
         (opt "width" int31))

  let make ~attributeName ~label ?format ?type_ ?width () =
    {attributeName; label; format; type_; width}

  let attributeName t = t.attributeName

  let label t = t.label

  let format t = t.format

  let type_ t = t.type_

  let width t = t.width
end

module Capabilities : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    ?supportsConfigurationDoneRequest:bool ->
    ?supportsFunctionBreakpoints:bool ->
    ?supportsConditionalBreakpoints:bool ->
    ?supportsHitConditionalBreakpoints:bool ->
    ?supportsEvaluateForHovers:bool ->
    ?exceptionBreakpointFilters:ExceptionBreakpointsFilter.t list ->
    ?supportsStepBack:bool ->
    ?supportsSetVariable:bool ->
    ?supportsRestartFrame:bool ->
    ?supportsGotoTargetsRequest:bool ->
    ?supportsStepInTargetsRequest:bool ->
    ?supportsCompletionsRequest:bool ->
    ?completionTriggerCharacters:string list ->
    ?supportsModulesRequest:bool ->
    ?additionalModuleColumns:ColumnDescriptor.t list ->
    ?supportedChecksumAlgorithms:ChecksumAlgorithm.t list ->
    ?supportsRestartRequest:bool ->
    ?supportsExceptionOptions:bool ->
    ?supportsValueFormattingOptions:bool ->
    ?supportsExceptionInfoRequest:bool ->
    ?supportTerminateDebuggee:bool ->
    ?supportSuspendDebuggee:bool ->
    ?supportsDelayedStackTraceLoading:bool ->
    ?supportsLoadedSourcesRequest:bool ->
    ?supportsLogPoints:bool ->
    ?supportsTerminateThreadsRequest:bool ->
    ?supportsSetExpression:bool ->
    ?supportsTerminateRequest:bool ->
    ?supportsDataBreakpoints:bool ->
    ?supportsReadMemoryRequest:bool ->
    ?supportsWriteMemoryRequest:bool ->
    ?supportsDisassembleRequest:bool ->
    ?supportsCancelRequest:bool ->
    ?supportsBreakpointLocationsRequest:bool ->
    ?supportsClipboardContext:bool ->
    ?supportsSteppingGranularity:bool ->
    ?supportsInstructionBreakpoints:bool ->
    ?supportsExceptionFilterOptions:bool ->
    ?supportsSingleThreadExecutionRequests:bool ->
    unit ->
    t

  val supportsConfigurationDoneRequest : t -> bool option

  val supportsFunctionBreakpoints : t -> bool option

  val supportsConditionalBreakpoints : t -> bool option

  val supportsHitConditionalBreakpoints : t -> bool option

  val supportsEvaluateForHovers : t -> bool option

  val exceptionBreakpointFilters : t -> ExceptionBreakpointsFilter.t list option

  val supportsStepBack : t -> bool option

  val supportsSetVariable : t -> bool option

  val supportsRestartFrame : t -> bool option

  val supportsGotoTargetsRequest : t -> bool option

  val supportsStepInTargetsRequest : t -> bool option

  val supportsCompletionsRequest : t -> bool option

  val completionTriggerCharacters : t -> string list option

  val supportsModulesRequest : t -> bool option

  val additionalModuleColumns : t -> ColumnDescriptor.t list option

  val supportedChecksumAlgorithms : t -> ChecksumAlgorithm.t list option

  val supportsRestartRequest : t -> bool option

  val supportsExceptionOptions : t -> bool option

  val supportsValueFormattingOptions : t -> bool option

  val supportsExceptionInfoRequest : t -> bool option

  val supportTerminateDebuggee : t -> bool option

  val supportSuspendDebuggee : t -> bool option

  val supportsDelayedStackTraceLoading : t -> bool option

  val supportsLoadedSourcesRequest : t -> bool option

  val supportsLogPoints : t -> bool option

  val supportsTerminateThreadsRequest : t -> bool option

  val supportsSetExpression : t -> bool option

  val supportsTerminateRequest : t -> bool option

  val supportsDataBreakpoints : t -> bool option

  val supportsReadMemoryRequest : t -> bool option

  val supportsWriteMemoryRequest : t -> bool option

  val supportsDisassembleRequest : t -> bool option

  val supportsCancelRequest : t -> bool option

  val supportsBreakpointLocationsRequest : t -> bool option

  val supportsClipboardContext : t -> bool option

  val supportsSteppingGranularity : t -> bool option

  val supportsInstructionBreakpoints : t -> bool option

  val supportsExceptionFilterOptions : t -> bool option

  val supportsSingleThreadExecutionRequests : t -> bool option
end = struct
  module Capabilities_0 : sig
    type t

    val enc : t Data_encoding.t

    val gen : t QCheck.Gen.t

    val make :
      ?supportsConfigurationDoneRequest:bool ->
      ?supportsFunctionBreakpoints:bool ->
      ?supportsConditionalBreakpoints:bool ->
      ?supportsHitConditionalBreakpoints:bool ->
      ?supportsEvaluateForHovers:bool ->
      ?exceptionBreakpointFilters:ExceptionBreakpointsFilter.t list ->
      ?supportsStepBack:bool ->
      ?supportsSetVariable:bool ->
      ?supportsRestartFrame:bool ->
      ?supportsGotoTargetsRequest:bool ->
      unit ->
      t

    val supportsConfigurationDoneRequest : t -> bool option

    val supportsFunctionBreakpoints : t -> bool option

    val supportsConditionalBreakpoints : t -> bool option

    val supportsHitConditionalBreakpoints : t -> bool option

    val supportsEvaluateForHovers : t -> bool option

    val exceptionBreakpointFilters :
      t -> ExceptionBreakpointsFilter.t list option

    val supportsStepBack : t -> bool option

    val supportsSetVariable : t -> bool option

    val supportsRestartFrame : t -> bool option

    val supportsGotoTargetsRequest : t -> bool option
  end = struct
    type t = {
      supportsConfigurationDoneRequest : bool option;
      supportsFunctionBreakpoints : bool option;
      supportsConditionalBreakpoints : bool option;
      supportsHitConditionalBreakpoints : bool option;
      supportsEvaluateForHovers : bool option;
      exceptionBreakpointFilters : ExceptionBreakpointsFilter.t list option;
      supportsStepBack : bool option;
      supportsSetVariable : bool option;
      supportsRestartFrame : bool option;
      supportsGotoTargetsRequest : bool option;
    }
    [@@deriving qcheck]

    let enc =
      let open Data_encoding in
      (* Capabilities_0.t *)
      conv
        (fun {
               supportsConfigurationDoneRequest;
               supportsFunctionBreakpoints;
               supportsConditionalBreakpoints;
               supportsHitConditionalBreakpoints;
               supportsEvaluateForHovers;
               exceptionBreakpointFilters;
               supportsStepBack;
               supportsSetVariable;
               supportsRestartFrame;
               supportsGotoTargetsRequest;
             } ->
          ( supportsConfigurationDoneRequest,
            supportsFunctionBreakpoints,
            supportsConditionalBreakpoints,
            supportsHitConditionalBreakpoints,
            supportsEvaluateForHovers,
            exceptionBreakpointFilters,
            supportsStepBack,
            supportsSetVariable,
            supportsRestartFrame,
            supportsGotoTargetsRequest ))
        (fun ( supportsConfigurationDoneRequest,
               supportsFunctionBreakpoints,
               supportsConditionalBreakpoints,
               supportsHitConditionalBreakpoints,
               supportsEvaluateForHovers,
               exceptionBreakpointFilters,
               supportsStepBack,
               supportsSetVariable,
               supportsRestartFrame,
               supportsGotoTargetsRequest ) ->
          {
            supportsConfigurationDoneRequest;
            supportsFunctionBreakpoints;
            supportsConditionalBreakpoints;
            supportsHitConditionalBreakpoints;
            supportsEvaluateForHovers;
            exceptionBreakpointFilters;
            supportsStepBack;
            supportsSetVariable;
            supportsRestartFrame;
            supportsGotoTargetsRequest;
          })
        (obj10
           (opt "supportsConfigurationDoneRequest" bool)
           (opt "supportsFunctionBreakpoints" bool)
           (opt "supportsConditionalBreakpoints" bool)
           (opt "supportsHitConditionalBreakpoints" bool)
           (opt "supportsEvaluateForHovers" bool)
           (opt
              "exceptionBreakpointFilters"
              (list ExceptionBreakpointsFilter.enc))
           (opt "supportsStepBack" bool)
           (opt "supportsSetVariable" bool)
           (opt "supportsRestartFrame" bool)
           (opt "supportsGotoTargetsRequest" bool))

    let make ?supportsConfigurationDoneRequest ?supportsFunctionBreakpoints
        ?supportsConditionalBreakpoints ?supportsHitConditionalBreakpoints
        ?supportsEvaluateForHovers ?exceptionBreakpointFilters ?supportsStepBack
        ?supportsSetVariable ?supportsRestartFrame ?supportsGotoTargetsRequest
        () =
      {
        supportsConfigurationDoneRequest;
        supportsFunctionBreakpoints;
        supportsConditionalBreakpoints;
        supportsHitConditionalBreakpoints;
        supportsEvaluateForHovers;
        exceptionBreakpointFilters;
        supportsStepBack;
        supportsSetVariable;
        supportsRestartFrame;
        supportsGotoTargetsRequest;
      }

    let supportsConfigurationDoneRequest t = t.supportsConfigurationDoneRequest

    let supportsFunctionBreakpoints t = t.supportsFunctionBreakpoints

    let supportsConditionalBreakpoints t = t.supportsConditionalBreakpoints

    let supportsHitConditionalBreakpoints t =
      t.supportsHitConditionalBreakpoints

    let supportsEvaluateForHovers t = t.supportsEvaluateForHovers

    let exceptionBreakpointFilters t = t.exceptionBreakpointFilters

    let supportsStepBack t = t.supportsStepBack

    let supportsSetVariable t = t.supportsSetVariable

    let supportsRestartFrame t = t.supportsRestartFrame

    let supportsGotoTargetsRequest t = t.supportsGotoTargetsRequest
  end

  module Capabilities_10 : sig
    type t

    val enc : t Data_encoding.t

    val gen : t QCheck.Gen.t

    val make :
      ?supportsStepInTargetsRequest:bool ->
      ?supportsCompletionsRequest:bool ->
      ?completionTriggerCharacters:string list ->
      ?supportsModulesRequest:bool ->
      ?additionalModuleColumns:ColumnDescriptor.t list ->
      ?supportedChecksumAlgorithms:ChecksumAlgorithm.t list ->
      ?supportsRestartRequest:bool ->
      ?supportsExceptionOptions:bool ->
      ?supportsValueFormattingOptions:bool ->
      ?supportsExceptionInfoRequest:bool ->
      unit ->
      t

    val supportsStepInTargetsRequest : t -> bool option

    val supportsCompletionsRequest : t -> bool option

    val completionTriggerCharacters : t -> string list option

    val supportsModulesRequest : t -> bool option

    val additionalModuleColumns : t -> ColumnDescriptor.t list option

    val supportedChecksumAlgorithms : t -> ChecksumAlgorithm.t list option

    val supportsRestartRequest : t -> bool option

    val supportsExceptionOptions : t -> bool option

    val supportsValueFormattingOptions : t -> bool option

    val supportsExceptionInfoRequest : t -> bool option
  end = struct
    type t = {
      supportsStepInTargetsRequest : bool option;
      supportsCompletionsRequest : bool option;
      completionTriggerCharacters :
        (string list option[@gen gen_utf8_str_list_opt]);
      supportsModulesRequest : bool option;
      additionalModuleColumns : ColumnDescriptor.t list option;
      supportedChecksumAlgorithms : ChecksumAlgorithm.t list option;
      supportsRestartRequest : bool option;
      supportsExceptionOptions : bool option;
      supportsValueFormattingOptions : bool option;
      supportsExceptionInfoRequest : bool option;
    }
    [@@deriving qcheck]

    let enc =
      let open Data_encoding in
      (* Capabilities_10.t *)
      conv
        (fun {
               supportsStepInTargetsRequest;
               supportsCompletionsRequest;
               completionTriggerCharacters;
               supportsModulesRequest;
               additionalModuleColumns;
               supportedChecksumAlgorithms;
               supportsRestartRequest;
               supportsExceptionOptions;
               supportsValueFormattingOptions;
               supportsExceptionInfoRequest;
             } ->
          ( supportsStepInTargetsRequest,
            supportsCompletionsRequest,
            completionTriggerCharacters,
            supportsModulesRequest,
            additionalModuleColumns,
            supportedChecksumAlgorithms,
            supportsRestartRequest,
            supportsExceptionOptions,
            supportsValueFormattingOptions,
            supportsExceptionInfoRequest ))
        (fun ( supportsStepInTargetsRequest,
               supportsCompletionsRequest,
               completionTriggerCharacters,
               supportsModulesRequest,
               additionalModuleColumns,
               supportedChecksumAlgorithms,
               supportsRestartRequest,
               supportsExceptionOptions,
               supportsValueFormattingOptions,
               supportsExceptionInfoRequest ) ->
          {
            supportsStepInTargetsRequest;
            supportsCompletionsRequest;
            completionTriggerCharacters;
            supportsModulesRequest;
            additionalModuleColumns;
            supportedChecksumAlgorithms;
            supportsRestartRequest;
            supportsExceptionOptions;
            supportsValueFormattingOptions;
            supportsExceptionInfoRequest;
          })
        (obj10
           (opt "supportsStepInTargetsRequest" bool)
           (opt "supportsCompletionsRequest" bool)
           (opt "completionTriggerCharacters" (list string))
           (opt "supportsModulesRequest" bool)
           (opt "additionalModuleColumns" (list ColumnDescriptor.enc))
           (opt "supportedChecksumAlgorithms" (list ChecksumAlgorithm.enc))
           (opt "supportsRestartRequest" bool)
           (opt "supportsExceptionOptions" bool)
           (opt "supportsValueFormattingOptions" bool)
           (opt "supportsExceptionInfoRequest" bool))

    let make ?supportsStepInTargetsRequest ?supportsCompletionsRequest
        ?completionTriggerCharacters ?supportsModulesRequest
        ?additionalModuleColumns ?supportedChecksumAlgorithms
        ?supportsRestartRequest ?supportsExceptionOptions
        ?supportsValueFormattingOptions ?supportsExceptionInfoRequest () =
      {
        supportsStepInTargetsRequest;
        supportsCompletionsRequest;
        completionTriggerCharacters;
        supportsModulesRequest;
        additionalModuleColumns;
        supportedChecksumAlgorithms;
        supportsRestartRequest;
        supportsExceptionOptions;
        supportsValueFormattingOptions;
        supportsExceptionInfoRequest;
      }

    let supportsStepInTargetsRequest t = t.supportsStepInTargetsRequest

    let supportsCompletionsRequest t = t.supportsCompletionsRequest

    let completionTriggerCharacters t = t.completionTriggerCharacters

    let supportsModulesRequest t = t.supportsModulesRequest

    let additionalModuleColumns t = t.additionalModuleColumns

    let supportedChecksumAlgorithms t = t.supportedChecksumAlgorithms

    let supportsRestartRequest t = t.supportsRestartRequest

    let supportsExceptionOptions t = t.supportsExceptionOptions

    let supportsValueFormattingOptions t = t.supportsValueFormattingOptions

    let supportsExceptionInfoRequest t = t.supportsExceptionInfoRequest
  end

  module Capabilities_20 : sig
    type t

    val enc : t Data_encoding.t

    val gen : t QCheck.Gen.t

    val make :
      ?supportTerminateDebuggee:bool ->
      ?supportSuspendDebuggee:bool ->
      ?supportsDelayedStackTraceLoading:bool ->
      ?supportsLoadedSourcesRequest:bool ->
      ?supportsLogPoints:bool ->
      ?supportsTerminateThreadsRequest:bool ->
      ?supportsSetExpression:bool ->
      ?supportsTerminateRequest:bool ->
      ?supportsDataBreakpoints:bool ->
      ?supportsReadMemoryRequest:bool ->
      unit ->
      t

    val supportTerminateDebuggee : t -> bool option

    val supportSuspendDebuggee : t -> bool option

    val supportsDelayedStackTraceLoading : t -> bool option

    val supportsLoadedSourcesRequest : t -> bool option

    val supportsLogPoints : t -> bool option

    val supportsTerminateThreadsRequest : t -> bool option

    val supportsSetExpression : t -> bool option

    val supportsTerminateRequest : t -> bool option

    val supportsDataBreakpoints : t -> bool option

    val supportsReadMemoryRequest : t -> bool option
  end = struct
    type t = {
      supportTerminateDebuggee : bool option;
      supportSuspendDebuggee : bool option;
      supportsDelayedStackTraceLoading : bool option;
      supportsLoadedSourcesRequest : bool option;
      supportsLogPoints : bool option;
      supportsTerminateThreadsRequest : bool option;
      supportsSetExpression : bool option;
      supportsTerminateRequest : bool option;
      supportsDataBreakpoints : bool option;
      supportsReadMemoryRequest : bool option;
    }
    [@@deriving qcheck]

    let enc =
      let open Data_encoding in
      (* Capabilities_20.t *)
      conv
        (fun {
               supportTerminateDebuggee;
               supportSuspendDebuggee;
               supportsDelayedStackTraceLoading;
               supportsLoadedSourcesRequest;
               supportsLogPoints;
               supportsTerminateThreadsRequest;
               supportsSetExpression;
               supportsTerminateRequest;
               supportsDataBreakpoints;
               supportsReadMemoryRequest;
             } ->
          ( supportTerminateDebuggee,
            supportSuspendDebuggee,
            supportsDelayedStackTraceLoading,
            supportsLoadedSourcesRequest,
            supportsLogPoints,
            supportsTerminateThreadsRequest,
            supportsSetExpression,
            supportsTerminateRequest,
            supportsDataBreakpoints,
            supportsReadMemoryRequest ))
        (fun ( supportTerminateDebuggee,
               supportSuspendDebuggee,
               supportsDelayedStackTraceLoading,
               supportsLoadedSourcesRequest,
               supportsLogPoints,
               supportsTerminateThreadsRequest,
               supportsSetExpression,
               supportsTerminateRequest,
               supportsDataBreakpoints,
               supportsReadMemoryRequest ) ->
          {
            supportTerminateDebuggee;
            supportSuspendDebuggee;
            supportsDelayedStackTraceLoading;
            supportsLoadedSourcesRequest;
            supportsLogPoints;
            supportsTerminateThreadsRequest;
            supportsSetExpression;
            supportsTerminateRequest;
            supportsDataBreakpoints;
            supportsReadMemoryRequest;
          })
        (obj10
           (opt "supportTerminateDebuggee" bool)
           (opt "supportSuspendDebuggee" bool)
           (opt "supportsDelayedStackTraceLoading" bool)
           (opt "supportsLoadedSourcesRequest" bool)
           (opt "supportsLogPoints" bool)
           (opt "supportsTerminateThreadsRequest" bool)
           (opt "supportsSetExpression" bool)
           (opt "supportsTerminateRequest" bool)
           (opt "supportsDataBreakpoints" bool)
           (opt "supportsReadMemoryRequest" bool))

    let make ?supportTerminateDebuggee ?supportSuspendDebuggee
        ?supportsDelayedStackTraceLoading ?supportsLoadedSourcesRequest
        ?supportsLogPoints ?supportsTerminateThreadsRequest
        ?supportsSetExpression ?supportsTerminateRequest
        ?supportsDataBreakpoints ?supportsReadMemoryRequest () =
      {
        supportTerminateDebuggee;
        supportSuspendDebuggee;
        supportsDelayedStackTraceLoading;
        supportsLoadedSourcesRequest;
        supportsLogPoints;
        supportsTerminateThreadsRequest;
        supportsSetExpression;
        supportsTerminateRequest;
        supportsDataBreakpoints;
        supportsReadMemoryRequest;
      }

    let supportTerminateDebuggee t = t.supportTerminateDebuggee

    let supportSuspendDebuggee t = t.supportSuspendDebuggee

    let supportsDelayedStackTraceLoading t = t.supportsDelayedStackTraceLoading

    let supportsLoadedSourcesRequest t = t.supportsLoadedSourcesRequest

    let supportsLogPoints t = t.supportsLogPoints

    let supportsTerminateThreadsRequest t = t.supportsTerminateThreadsRequest

    let supportsSetExpression t = t.supportsSetExpression

    let supportsTerminateRequest t = t.supportsTerminateRequest

    let supportsDataBreakpoints t = t.supportsDataBreakpoints

    let supportsReadMemoryRequest t = t.supportsReadMemoryRequest
  end

  module Capabilities_30 : sig
    type t

    val enc : t Data_encoding.t

    val gen : t QCheck.Gen.t

    val make :
      ?supportsWriteMemoryRequest:bool ->
      ?supportsDisassembleRequest:bool ->
      ?supportsCancelRequest:bool ->
      ?supportsBreakpointLocationsRequest:bool ->
      ?supportsClipboardContext:bool ->
      ?supportsSteppingGranularity:bool ->
      ?supportsInstructionBreakpoints:bool ->
      ?supportsExceptionFilterOptions:bool ->
      ?supportsSingleThreadExecutionRequests:bool ->
      unit ->
      t

    val supportsWriteMemoryRequest : t -> bool option

    val supportsDisassembleRequest : t -> bool option

    val supportsCancelRequest : t -> bool option

    val supportsBreakpointLocationsRequest : t -> bool option

    val supportsClipboardContext : t -> bool option

    val supportsSteppingGranularity : t -> bool option

    val supportsInstructionBreakpoints : t -> bool option

    val supportsExceptionFilterOptions : t -> bool option

    val supportsSingleThreadExecutionRequests : t -> bool option
  end = struct
    type t = {
      supportsWriteMemoryRequest : bool option;
      supportsDisassembleRequest : bool option;
      supportsCancelRequest : bool option;
      supportsBreakpointLocationsRequest : bool option;
      supportsClipboardContext : bool option;
      supportsSteppingGranularity : bool option;
      supportsInstructionBreakpoints : bool option;
      supportsExceptionFilterOptions : bool option;
      supportsSingleThreadExecutionRequests : bool option;
    }
    [@@deriving qcheck]

    let enc =
      let open Data_encoding in
      (* Capabilities_30.t *)
      conv
        (fun {
               supportsWriteMemoryRequest;
               supportsDisassembleRequest;
               supportsCancelRequest;
               supportsBreakpointLocationsRequest;
               supportsClipboardContext;
               supportsSteppingGranularity;
               supportsInstructionBreakpoints;
               supportsExceptionFilterOptions;
               supportsSingleThreadExecutionRequests;
             } ->
          ( supportsWriteMemoryRequest,
            supportsDisassembleRequest,
            supportsCancelRequest,
            supportsBreakpointLocationsRequest,
            supportsClipboardContext,
            supportsSteppingGranularity,
            supportsInstructionBreakpoints,
            supportsExceptionFilterOptions,
            supportsSingleThreadExecutionRequests ))
        (fun ( supportsWriteMemoryRequest,
               supportsDisassembleRequest,
               supportsCancelRequest,
               supportsBreakpointLocationsRequest,
               supportsClipboardContext,
               supportsSteppingGranularity,
               supportsInstructionBreakpoints,
               supportsExceptionFilterOptions,
               supportsSingleThreadExecutionRequests ) ->
          {
            supportsWriteMemoryRequest;
            supportsDisassembleRequest;
            supportsCancelRequest;
            supportsBreakpointLocationsRequest;
            supportsClipboardContext;
            supportsSteppingGranularity;
            supportsInstructionBreakpoints;
            supportsExceptionFilterOptions;
            supportsSingleThreadExecutionRequests;
          })
        (obj9
           (opt "supportsWriteMemoryRequest" bool)
           (opt "supportsDisassembleRequest" bool)
           (opt "supportsCancelRequest" bool)
           (opt "supportsBreakpointLocationsRequest" bool)
           (opt "supportsClipboardContext" bool)
           (opt "supportsSteppingGranularity" bool)
           (opt "supportsInstructionBreakpoints" bool)
           (opt "supportsExceptionFilterOptions" bool)
           (opt "supportsSingleThreadExecutionRequests" bool))

    let make ?supportsWriteMemoryRequest ?supportsDisassembleRequest
        ?supportsCancelRequest ?supportsBreakpointLocationsRequest
        ?supportsClipboardContext ?supportsSteppingGranularity
        ?supportsInstructionBreakpoints ?supportsExceptionFilterOptions
        ?supportsSingleThreadExecutionRequests () =
      {
        supportsWriteMemoryRequest;
        supportsDisassembleRequest;
        supportsCancelRequest;
        supportsBreakpointLocationsRequest;
        supportsClipboardContext;
        supportsSteppingGranularity;
        supportsInstructionBreakpoints;
        supportsExceptionFilterOptions;
        supportsSingleThreadExecutionRequests;
      }

    let supportsWriteMemoryRequest t = t.supportsWriteMemoryRequest

    let supportsDisassembleRequest t = t.supportsDisassembleRequest

    let supportsCancelRequest t = t.supportsCancelRequest

    let supportsBreakpointLocationsRequest t =
      t.supportsBreakpointLocationsRequest

    let supportsClipboardContext t = t.supportsClipboardContext

    let supportsSteppingGranularity t = t.supportsSteppingGranularity

    let supportsInstructionBreakpoints t = t.supportsInstructionBreakpoints

    let supportsExceptionFilterOptions t = t.supportsExceptionFilterOptions

    let supportsSingleThreadExecutionRequests t =
      t.supportsSingleThreadExecutionRequests
  end

  type t =
    Capabilities_0.t
    * (Capabilities_10.t * (Capabilities_20.t * Capabilities_30.t))
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    merge_objs Capabilities_0.enc
    @@ merge_objs Capabilities_10.enc
    @@ merge_objs Capabilities_20.enc Capabilities_30.enc

  let make ?supportsConfigurationDoneRequest ?supportsFunctionBreakpoints
      ?supportsConditionalBreakpoints ?supportsHitConditionalBreakpoints
      ?supportsEvaluateForHovers ?exceptionBreakpointFilters ?supportsStepBack
      ?supportsSetVariable ?supportsRestartFrame ?supportsGotoTargetsRequest
      ?supportsStepInTargetsRequest ?supportsCompletionsRequest
      ?completionTriggerCharacters ?supportsModulesRequest
      ?additionalModuleColumns ?supportedChecksumAlgorithms
      ?supportsRestartRequest ?supportsExceptionOptions
      ?supportsValueFormattingOptions ?supportsExceptionInfoRequest
      ?supportTerminateDebuggee ?supportSuspendDebuggee
      ?supportsDelayedStackTraceLoading ?supportsLoadedSourcesRequest
      ?supportsLogPoints ?supportsTerminateThreadsRequest ?supportsSetExpression
      ?supportsTerminateRequest ?supportsDataBreakpoints
      ?supportsReadMemoryRequest ?supportsWriteMemoryRequest
      ?supportsDisassembleRequest ?supportsCancelRequest
      ?supportsBreakpointLocationsRequest ?supportsClipboardContext
      ?supportsSteppingGranularity ?supportsInstructionBreakpoints
      ?supportsExceptionFilterOptions ?supportsSingleThreadExecutionRequests ()
      =
    let t0 =
      Capabilities_0.make
        ?supportsConfigurationDoneRequest
        ?supportsFunctionBreakpoints
        ?supportsConditionalBreakpoints
        ?supportsHitConditionalBreakpoints
        ?supportsEvaluateForHovers
        ?exceptionBreakpointFilters
        ?supportsStepBack
        ?supportsSetVariable
        ?supportsRestartFrame
        ?supportsGotoTargetsRequest
        ()
    in

    let t1 =
      Capabilities_10.make
        ?supportsStepInTargetsRequest
        ?supportsCompletionsRequest
        ?completionTriggerCharacters
        ?supportsModulesRequest
        ?additionalModuleColumns
        ?supportedChecksumAlgorithms
        ?supportsRestartRequest
        ?supportsExceptionOptions
        ?supportsValueFormattingOptions
        ?supportsExceptionInfoRequest
        ()
    in

    let t2 =
      Capabilities_20.make
        ?supportTerminateDebuggee
        ?supportSuspendDebuggee
        ?supportsDelayedStackTraceLoading
        ?supportsLoadedSourcesRequest
        ?supportsLogPoints
        ?supportsTerminateThreadsRequest
        ?supportsSetExpression
        ?supportsTerminateRequest
        ?supportsDataBreakpoints
        ?supportsReadMemoryRequest
        ()
    in

    let t3 =
      Capabilities_30.make
        ?supportsWriteMemoryRequest
        ?supportsDisassembleRequest
        ?supportsCancelRequest
        ?supportsBreakpointLocationsRequest
        ?supportsClipboardContext
        ?supportsSteppingGranularity
        ?supportsInstructionBreakpoints
        ?supportsExceptionFilterOptions
        ?supportsSingleThreadExecutionRequests
        ()
    in

    (t0, (t1, (t2, t3)))

  let supportsConfigurationDoneRequest (_t0, (_t1, (_t2, _t3))) =
    Capabilities_0.supportsConfigurationDoneRequest _t0

  let supportsFunctionBreakpoints (_t0, (_t1, (_t2, _t3))) =
    Capabilities_0.supportsFunctionBreakpoints _t0

  let supportsConditionalBreakpoints (_t0, (_t1, (_t2, _t3))) =
    Capabilities_0.supportsConditionalBreakpoints _t0

  let supportsHitConditionalBreakpoints (_t0, (_t1, (_t2, _t3))) =
    Capabilities_0.supportsHitConditionalBreakpoints _t0

  let supportsEvaluateForHovers (_t0, (_t1, (_t2, _t3))) =
    Capabilities_0.supportsEvaluateForHovers _t0

  let exceptionBreakpointFilters (_t0, (_t1, (_t2, _t3))) =
    Capabilities_0.exceptionBreakpointFilters _t0

  let supportsStepBack (_t0, (_t1, (_t2, _t3))) =
    Capabilities_0.supportsStepBack _t0

  let supportsSetVariable (_t0, (_t1, (_t2, _t3))) =
    Capabilities_0.supportsSetVariable _t0

  let supportsRestartFrame (_t0, (_t1, (_t2, _t3))) =
    Capabilities_0.supportsRestartFrame _t0

  let supportsGotoTargetsRequest (_t0, (_t1, (_t2, _t3))) =
    Capabilities_0.supportsGotoTargetsRequest _t0

  let supportsStepInTargetsRequest (_t0, (_t1, (_t2, _t3))) =
    Capabilities_10.supportsStepInTargetsRequest _t1

  let supportsCompletionsRequest (_t0, (_t1, (_t2, _t3))) =
    Capabilities_10.supportsCompletionsRequest _t1

  let completionTriggerCharacters (_t0, (_t1, (_t2, _t3))) =
    Capabilities_10.completionTriggerCharacters _t1

  let supportsModulesRequest (_t0, (_t1, (_t2, _t3))) =
    Capabilities_10.supportsModulesRequest _t1

  let additionalModuleColumns (_t0, (_t1, (_t2, _t3))) =
    Capabilities_10.additionalModuleColumns _t1

  let supportedChecksumAlgorithms (_t0, (_t1, (_t2, _t3))) =
    Capabilities_10.supportedChecksumAlgorithms _t1

  let supportsRestartRequest (_t0, (_t1, (_t2, _t3))) =
    Capabilities_10.supportsRestartRequest _t1

  let supportsExceptionOptions (_t0, (_t1, (_t2, _t3))) =
    Capabilities_10.supportsExceptionOptions _t1

  let supportsValueFormattingOptions (_t0, (_t1, (_t2, _t3))) =
    Capabilities_10.supportsValueFormattingOptions _t1

  let supportsExceptionInfoRequest (_t0, (_t1, (_t2, _t3))) =
    Capabilities_10.supportsExceptionInfoRequest _t1

  let supportTerminateDebuggee (_t0, (_t1, (_t2, _t3))) =
    Capabilities_20.supportTerminateDebuggee _t2

  let supportSuspendDebuggee (_t0, (_t1, (_t2, _t3))) =
    Capabilities_20.supportSuspendDebuggee _t2

  let supportsDelayedStackTraceLoading (_t0, (_t1, (_t2, _t3))) =
    Capabilities_20.supportsDelayedStackTraceLoading _t2

  let supportsLoadedSourcesRequest (_t0, (_t1, (_t2, _t3))) =
    Capabilities_20.supportsLoadedSourcesRequest _t2

  let supportsLogPoints (_t0, (_t1, (_t2, _t3))) =
    Capabilities_20.supportsLogPoints _t2

  let supportsTerminateThreadsRequest (_t0, (_t1, (_t2, _t3))) =
    Capabilities_20.supportsTerminateThreadsRequest _t2

  let supportsSetExpression (_t0, (_t1, (_t2, _t3))) =
    Capabilities_20.supportsSetExpression _t2

  let supportsTerminateRequest (_t0, (_t1, (_t2, _t3))) =
    Capabilities_20.supportsTerminateRequest _t2

  let supportsDataBreakpoints (_t0, (_t1, (_t2, _t3))) =
    Capabilities_20.supportsDataBreakpoints _t2

  let supportsReadMemoryRequest (_t0, (_t1, (_t2, _t3))) =
    Capabilities_20.supportsReadMemoryRequest _t2

  let supportsWriteMemoryRequest (_t0, (_t1, (_t2, _t3))) =
    Capabilities_30.supportsWriteMemoryRequest _t3

  let supportsDisassembleRequest (_t0, (_t1, (_t2, _t3))) =
    Capabilities_30.supportsDisassembleRequest _t3

  let supportsCancelRequest (_t0, (_t1, (_t2, _t3))) =
    Capabilities_30.supportsCancelRequest _t3

  let supportsBreakpointLocationsRequest (_t0, (_t1, (_t2, _t3))) =
    Capabilities_30.supportsBreakpointLocationsRequest _t3

  let supportsClipboardContext (_t0, (_t1, (_t2, _t3))) =
    Capabilities_30.supportsClipboardContext _t3

  let supportsSteppingGranularity (_t0, (_t1, (_t2, _t3))) =
    Capabilities_30.supportsSteppingGranularity _t3

  let supportsInstructionBreakpoints (_t0, (_t1, (_t2, _t3))) =
    Capabilities_30.supportsInstructionBreakpoints _t3

  let supportsExceptionFilterOptions (_t0, (_t1, (_t2, _t3))) =
    Capabilities_30.supportsExceptionFilterOptions _t3

  let supportsSingleThreadExecutionRequests (_t0, (_t1, (_t2, _t3))) =
    Capabilities_30.supportsSingleThreadExecutionRequests _t3
end

module CapabilitiesEvent_body : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : capabilities:Capabilities.t -> unit -> t

  val capabilities : t -> Capabilities.t
end = struct
  type t = {capabilities : Capabilities.t} [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* CapabilitiesEvent_body.t *)
    conv
      (fun {capabilities} -> capabilities)
      (fun capabilities -> {capabilities})
      (obj1 (req "capabilities" Capabilities.enc))

  let make ~capabilities () = {capabilities}

  let capabilities t = t.capabilities
end

module ProgressStartEvent_body : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    progressId:string ->
    title:string ->
    ?requestId:int ->
    ?cancellable:bool ->
    ?message:string ->
    ?percentage:int ->
    unit ->
    t

  val progressId : t -> string

  val title : t -> string

  val requestId : t -> int option

  val cancellable : t -> bool option

  val message : t -> string option

  val percentage : t -> int option
end = struct
  type t = {
    progressId : (string[@gen gen_utf8_str]);
    title : (string[@gen gen_utf8_str]);
    requestId : (int option[@gen gen_int31_opt]);
    cancellable : bool option;
    message : (string option[@gen gen_utf8_str_opt]);
    percentage : (int option[@gen gen_int31_opt]);
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* ProgressStartEvent_body.t *)
    conv
      (fun {progressId; title; requestId; cancellable; message; percentage} ->
        (progressId, title, requestId, cancellable, message, percentage))
      (fun (progressId, title, requestId, cancellable, message, percentage) ->
        {progressId; title; requestId; cancellable; message; percentage})
      (obj6
         (req "progressId" string)
         (req "title" string)
         (opt "requestId" int31)
         (opt "cancellable" bool)
         (opt "message" string)
         (opt "percentage" int31))

  let make ~progressId ~title ?requestId ?cancellable ?message ?percentage () =
    {progressId; title; requestId; cancellable; message; percentage}

  let progressId t = t.progressId

  let title t = t.title

  let requestId t = t.requestId

  let cancellable t = t.cancellable

  let message t = t.message

  let percentage t = t.percentage
end

module ProgressUpdateEvent_body : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    progressId:string -> ?message:string -> ?percentage:int -> unit -> t

  val progressId : t -> string

  val message : t -> string option

  val percentage : t -> int option
end = struct
  type t = {
    progressId : (string[@gen gen_utf8_str]);
    message : (string option[@gen gen_utf8_str_opt]);
    percentage : (int option[@gen gen_int31_opt]);
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* ProgressUpdateEvent_body.t *)
    conv
      (fun {progressId; message; percentage} ->
        (progressId, message, percentage))
      (fun (progressId, message, percentage) ->
        {progressId; message; percentage})
      (obj3
         (req "progressId" string)
         (opt "message" string)
         (opt "percentage" int31))

  let make ~progressId ?message ?percentage () =
    {progressId; message; percentage}

  let progressId t = t.progressId

  let message t = t.message

  let percentage t = t.percentage
end

module ProgressEndEvent_body : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : progressId:string -> ?message:string -> unit -> t

  val progressId : t -> string

  val message : t -> string option
end = struct
  type t = {
    progressId : (string[@gen gen_utf8_str]);
    message : (string option[@gen gen_utf8_str_opt]);
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* ProgressEndEvent_body.t *)
    conv
      (fun {progressId; message} -> (progressId, message))
      (fun (progressId, message) -> {progressId; message})
      (obj2 (req "progressId" string) (opt "message" string))

  let make ~progressId ?message () = {progressId; message}

  let progressId t = t.progressId

  let message t = t.message
end

(* dont bother with a sig for enums, the inferred one is fine *)
module InvalidatedAreas = struct
  type t = All | Stacks | Threads | Variables | Other of (string [@gen gen_utf8_str])
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    conv_with_guard
      (function
        | All -> "all"
        | Stacks -> "stacks"
        | Threads -> "threads"
        | Variables -> "variables"
        | Other s -> s)
      (function
        | "all" -> Ok All
        | "stacks" -> Ok Stacks
        | "threads" -> Ok Threads
        | "variables" -> Ok Variables
        | _ as s -> Ok (Other s))
      string
end

module InvalidatedEvent_body : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    ?areas:InvalidatedAreas.t list ->
    ?threadId:int ->
    ?stackFrameId:int ->
    unit ->
    t

  val areas : t -> InvalidatedAreas.t list option

  val threadId : t -> int option

  val stackFrameId : t -> int option
end = struct
  type t = {
    areas : InvalidatedAreas.t list option;
    threadId : (int option[@gen gen_int31_opt]);
    stackFrameId : (int option[@gen gen_int31_opt]);
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* InvalidatedEvent_body.t *)
    conv
      (fun {areas; threadId; stackFrameId} -> (areas, threadId, stackFrameId))
      (fun (areas, threadId, stackFrameId) -> {areas; threadId; stackFrameId})
      (obj3
         (opt "areas" (list InvalidatedAreas.enc))
         (opt "threadId" int31)
         (opt "stackFrameId" int31))

  let make ?areas ?threadId ?stackFrameId () = {areas; threadId; stackFrameId}

  let areas t = t.areas

  let threadId t = t.threadId

  let stackFrameId t = t.stackFrameId
end

module MemoryEvent_body : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : memoryReference:string -> offset:int -> count:int -> unit -> t

  val memoryReference : t -> string

  val offset : t -> int

  val count : t -> int
end = struct
  type t = {
    memoryReference : (string[@gen gen_utf8_str]);
    offset : (int[@gen gen_int31]);
    count : (int[@gen gen_int31]);
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* MemoryEvent_body.t *)
    conv
      (fun {memoryReference; offset; count} -> (memoryReference, offset, count))
      (fun (memoryReference, offset, count) -> {memoryReference; offset; count})
      (obj3
         (req "memoryReference" string)
         (req "offset" int31)
         (req "count" int31))

  let make ~memoryReference ~offset ~count () = {memoryReference; offset; count}

  let memoryReference t = t.memoryReference

  let offset t = t.offset

  let count t = t.count
end

(* dont bother with a sig for enums, the inferred one is fine *)
module RunInTerminalRequestArguments_kind = struct
  type t = Integrated | External [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    conv_with_guard
      (function Integrated -> "integrated" | External -> "external")
      (function
        | "integrated" -> Ok Integrated
        | "external" -> Ok External
        | _ -> Error "RunInTerminalRequestArguments_kind")
      string
end

module RunInTerminalRequestArguments : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    ?kind:RunInTerminalRequestArguments_kind.t ->
    ?title:string ->
    cwd:string ->
    args:string list ->
    ?env:Data_encoding.json ->
    unit ->
    t

  val kind : t -> RunInTerminalRequestArguments_kind.t option

  val title : t -> string option

  val cwd : t -> string

  val args : t -> string list

  val env : t -> Data_encoding.json option
end = struct
  type t = {
    kind : RunInTerminalRequestArguments_kind.t option;
    title : (string option[@gen gen_utf8_str_opt]);
    cwd : (string[@gen gen_utf8_str]);
    args : (string list[@gen gen_utf8_str_list]);
    env : (Data_encoding.json option[@gen gen_json_opt]);
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* RunInTerminalRequestArguments.t *)
    conv
      (fun {kind; title; cwd; args; env} -> (kind, title, cwd, args, env))
      (fun (kind, title, cwd, args, env) -> {kind; title; cwd; args; env})
      (obj5
         (opt "kind" RunInTerminalRequestArguments_kind.enc)
         (opt "title" string)
         (req "cwd" string)
         (req "args" (list string))
         (opt "env" json))

  let make ?kind ?title ~cwd ~args ?env () = {kind; title; cwd; args; env}

  let kind t = t.kind

  let title t = t.title

  let cwd t = t.cwd

  let args t = t.args

  let env t = t.env
end

module RunInTerminalResponse_body : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : ?processId:int -> ?shellProcessId:int -> unit -> t

  val processId : t -> int option

  val shellProcessId : t -> int option
end = struct
  type t = {
    processId : (int option[@gen gen_int31_opt]);
    shellProcessId : (int option[@gen gen_int31_opt]);
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* RunInTerminalResponse_body.t *)
    conv
      (fun {processId; shellProcessId} -> (processId, shellProcessId))
      (fun (processId, shellProcessId) -> {processId; shellProcessId})
      (obj2 (opt "processId" int31) (opt "shellProcessId" int31))

  let make ?processId ?shellProcessId () = {processId; shellProcessId}

  let processId t = t.processId

  let shellProcessId t = t.shellProcessId
end

(* dont bother with a sig for enums, the inferred one is fine *)
module InitializeRequestArguments_pathFormat = struct
  type t = Path | Uri | Other of (string [@gen gen_utf8_str]) [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    conv_with_guard
      (function Path -> "path" | Uri -> "uri" | Other s -> s)
      (function "path" -> Ok Path | "uri" -> Ok Uri | _ as s -> Ok (Other s))
      string
end

module InitializeRequestArguments : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    ?clientID:string ->
    ?clientName:string ->
    adapterID:string ->
    ?locale:string ->
    ?linesStartAt1:bool ->
    ?columnsStartAt1:bool ->
    ?pathFormat:InitializeRequestArguments_pathFormat.t ->
    ?supportsVariableType:bool ->
    ?supportsVariablePaging:bool ->
    ?supportsRunInTerminalRequest:bool ->
    ?supportsMemoryReferences:bool ->
    ?supportsProgressReporting:bool ->
    ?supportsInvalidatedEvent:bool ->
    ?supportsMemoryEvent:bool ->
    unit ->
    t

  val clientID : t -> string option

  val clientName : t -> string option

  val adapterID : t -> string

  val locale : t -> string option

  val linesStartAt1 : t -> bool option

  val columnsStartAt1 : t -> bool option

  val pathFormat : t -> InitializeRequestArguments_pathFormat.t option

  val supportsVariableType : t -> bool option

  val supportsVariablePaging : t -> bool option

  val supportsRunInTerminalRequest : t -> bool option

  val supportsMemoryReferences : t -> bool option

  val supportsProgressReporting : t -> bool option

  val supportsInvalidatedEvent : t -> bool option

  val supportsMemoryEvent : t -> bool option
end = struct
  module InitializeRequestArguments_0 : sig
    type t

    val enc : t Data_encoding.t

    val gen : t QCheck.Gen.t

    val make :
      ?clientID:string ->
      ?clientName:string ->
      adapterID:string ->
      ?locale:string ->
      ?linesStartAt1:bool ->
      ?columnsStartAt1:bool ->
      ?pathFormat:InitializeRequestArguments_pathFormat.t ->
      ?supportsVariableType:bool ->
      ?supportsVariablePaging:bool ->
      ?supportsRunInTerminalRequest:bool ->
      unit ->
      t

    val clientID : t -> string option

    val clientName : t -> string option

    val adapterID : t -> string

    val locale : t -> string option

    val linesStartAt1 : t -> bool option

    val columnsStartAt1 : t -> bool option

    val pathFormat : t -> InitializeRequestArguments_pathFormat.t option

    val supportsVariableType : t -> bool option

    val supportsVariablePaging : t -> bool option

    val supportsRunInTerminalRequest : t -> bool option
  end = struct
    type t = {
      clientID : (string option[@gen gen_utf8_str_opt]);
      clientName : (string option[@gen gen_utf8_str_opt]);
      adapterID : (string[@gen gen_utf8_str]);
      locale : (string option[@gen gen_utf8_str_opt]);
      linesStartAt1 : bool option;
      columnsStartAt1 : bool option;
      pathFormat : InitializeRequestArguments_pathFormat.t option;
      supportsVariableType : bool option;
      supportsVariablePaging : bool option;
      supportsRunInTerminalRequest : bool option;
    }
    [@@deriving qcheck]

    let enc =
      let open Data_encoding in
      (* InitializeRequestArguments_0.t *)
      conv
        (fun {
               clientID;
               clientName;
               adapterID;
               locale;
               linesStartAt1;
               columnsStartAt1;
               pathFormat;
               supportsVariableType;
               supportsVariablePaging;
               supportsRunInTerminalRequest;
             } ->
          ( clientID,
            clientName,
            adapterID,
            locale,
            linesStartAt1,
            columnsStartAt1,
            pathFormat,
            supportsVariableType,
            supportsVariablePaging,
            supportsRunInTerminalRequest ))
        (fun ( clientID,
               clientName,
               adapterID,
               locale,
               linesStartAt1,
               columnsStartAt1,
               pathFormat,
               supportsVariableType,
               supportsVariablePaging,
               supportsRunInTerminalRequest ) ->
          {
            clientID;
            clientName;
            adapterID;
            locale;
            linesStartAt1;
            columnsStartAt1;
            pathFormat;
            supportsVariableType;
            supportsVariablePaging;
            supportsRunInTerminalRequest;
          })
        (obj10
           (opt "clientID" string)
           (opt "clientName" string)
           (req "adapterID" string)
           (opt "locale" string)
           (opt "linesStartAt1" bool)
           (opt "columnsStartAt1" bool)
           (opt "pathFormat" InitializeRequestArguments_pathFormat.enc)
           (opt "supportsVariableType" bool)
           (opt "supportsVariablePaging" bool)
           (opt "supportsRunInTerminalRequest" bool))

    let make ?clientID ?clientName ~adapterID ?locale ?linesStartAt1
        ?columnsStartAt1 ?pathFormat ?supportsVariableType
        ?supportsVariablePaging ?supportsRunInTerminalRequest () =
      {
        clientID;
        clientName;
        adapterID;
        locale;
        linesStartAt1;
        columnsStartAt1;
        pathFormat;
        supportsVariableType;
        supportsVariablePaging;
        supportsRunInTerminalRequest;
      }

    let clientID t = t.clientID

    let clientName t = t.clientName

    let adapterID t = t.adapterID

    let locale t = t.locale

    let linesStartAt1 t = t.linesStartAt1

    let columnsStartAt1 t = t.columnsStartAt1

    let pathFormat t = t.pathFormat

    let supportsVariableType t = t.supportsVariableType

    let supportsVariablePaging t = t.supportsVariablePaging

    let supportsRunInTerminalRequest t = t.supportsRunInTerminalRequest
  end

  module InitializeRequestArguments_10 : sig
    type t

    val enc : t Data_encoding.t

    val gen : t QCheck.Gen.t

    val make :
      ?supportsMemoryReferences:bool ->
      ?supportsProgressReporting:bool ->
      ?supportsInvalidatedEvent:bool ->
      ?supportsMemoryEvent:bool ->
      unit ->
      t

    val supportsMemoryReferences : t -> bool option

    val supportsProgressReporting : t -> bool option

    val supportsInvalidatedEvent : t -> bool option

    val supportsMemoryEvent : t -> bool option
  end = struct
    type t = {
      supportsMemoryReferences : bool option;
      supportsProgressReporting : bool option;
      supportsInvalidatedEvent : bool option;
      supportsMemoryEvent : bool option;
    }
    [@@deriving qcheck]

    let enc =
      let open Data_encoding in
      (* InitializeRequestArguments_10.t *)
      conv
        (fun {
               supportsMemoryReferences;
               supportsProgressReporting;
               supportsInvalidatedEvent;
               supportsMemoryEvent;
             } ->
          ( supportsMemoryReferences,
            supportsProgressReporting,
            supportsInvalidatedEvent,
            supportsMemoryEvent ))
        (fun ( supportsMemoryReferences,
               supportsProgressReporting,
               supportsInvalidatedEvent,
               supportsMemoryEvent ) ->
          {
            supportsMemoryReferences;
            supportsProgressReporting;
            supportsInvalidatedEvent;
            supportsMemoryEvent;
          })
        (obj4
           (opt "supportsMemoryReferences" bool)
           (opt "supportsProgressReporting" bool)
           (opt "supportsInvalidatedEvent" bool)
           (opt "supportsMemoryEvent" bool))

    let make ?supportsMemoryReferences ?supportsProgressReporting
        ?supportsInvalidatedEvent ?supportsMemoryEvent () =
      {
        supportsMemoryReferences;
        supportsProgressReporting;
        supportsInvalidatedEvent;
        supportsMemoryEvent;
      }

    let supportsMemoryReferences t = t.supportsMemoryReferences

    let supportsProgressReporting t = t.supportsProgressReporting

    let supportsInvalidatedEvent t = t.supportsInvalidatedEvent

    let supportsMemoryEvent t = t.supportsMemoryEvent
  end

  type t = InitializeRequestArguments_0.t * InitializeRequestArguments_10.t
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    merge_objs
      InitializeRequestArguments_0.enc
      InitializeRequestArguments_10.enc

  let make ?clientID ?clientName ~adapterID ?locale ?linesStartAt1
      ?columnsStartAt1 ?pathFormat ?supportsVariableType ?supportsVariablePaging
      ?supportsRunInTerminalRequest ?supportsMemoryReferences
      ?supportsProgressReporting ?supportsInvalidatedEvent ?supportsMemoryEvent
      () =
    let t0 =
      InitializeRequestArguments_0.make
        ?clientID
        ?clientName
        ~adapterID
        ?locale
        ?linesStartAt1
        ?columnsStartAt1
        ?pathFormat
        ?supportsVariableType
        ?supportsVariablePaging
        ?supportsRunInTerminalRequest
        ()
    in

    let t1 =
      InitializeRequestArguments_10.make
        ?supportsMemoryReferences
        ?supportsProgressReporting
        ?supportsInvalidatedEvent
        ?supportsMemoryEvent
        ()
    in

    (t0, t1)

  let clientID (_t0, _t1) = InitializeRequestArguments_0.clientID _t0

  let clientName (_t0, _t1) = InitializeRequestArguments_0.clientName _t0

  let adapterID (_t0, _t1) = InitializeRequestArguments_0.adapterID _t0

  let locale (_t0, _t1) = InitializeRequestArguments_0.locale _t0

  let linesStartAt1 (_t0, _t1) = InitializeRequestArguments_0.linesStartAt1 _t0

  let columnsStartAt1 (_t0, _t1) =
    InitializeRequestArguments_0.columnsStartAt1 _t0

  let pathFormat (_t0, _t1) = InitializeRequestArguments_0.pathFormat _t0

  let supportsVariableType (_t0, _t1) =
    InitializeRequestArguments_0.supportsVariableType _t0

  let supportsVariablePaging (_t0, _t1) =
    InitializeRequestArguments_0.supportsVariablePaging _t0

  let supportsRunInTerminalRequest (_t0, _t1) =
    InitializeRequestArguments_0.supportsRunInTerminalRequest _t0

  let supportsMemoryReferences (_t0, _t1) =
    InitializeRequestArguments_10.supportsMemoryReferences _t1

  let supportsProgressReporting (_t0, _t1) =
    InitializeRequestArguments_10.supportsProgressReporting _t1

  let supportsInvalidatedEvent (_t0, _t1) =
    InitializeRequestArguments_10.supportsInvalidatedEvent _t1

  let supportsMemoryEvent (_t0, _t1) =
    InitializeRequestArguments_10.supportsMemoryEvent _t1
end

module ConfigurationDoneArguments : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : unit -> t
end = struct
  type t = unit [@@deriving qcheck]

  let enc = Data_encoding.empty

  let make () = ()
end

module DisconnectArguments : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    ?restart:bool ->
    ?terminateDebuggee:bool ->
    ?suspendDebuggee:bool ->
    unit ->
    t

  val restart : t -> bool option

  val terminateDebuggee : t -> bool option

  val suspendDebuggee : t -> bool option
end = struct
  type t = {
    restart : bool option;
    terminateDebuggee : bool option;
    suspendDebuggee : bool option;
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* DisconnectArguments.t *)
    conv
      (fun {restart; terminateDebuggee; suspendDebuggee} ->
        (restart, terminateDebuggee, suspendDebuggee))
      (fun (restart, terminateDebuggee, suspendDebuggee) ->
        {restart; terminateDebuggee; suspendDebuggee})
      (obj3
         (opt "restart" bool)
         (opt "terminateDebuggee" bool)
         (opt "suspendDebuggee" bool))

  let make ?restart ?terminateDebuggee ?suspendDebuggee () =
    {restart; terminateDebuggee; suspendDebuggee}

  let restart t = t.restart

  let terminateDebuggee t = t.terminateDebuggee

  let suspendDebuggee t = t.suspendDebuggee
end

module TerminateArguments : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : ?restart:bool -> unit -> t

  val restart : t -> bool option
end = struct
  type t = {restart : bool option} [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* TerminateArguments.t *)
    conv
      (fun {restart} -> restart)
      (fun restart -> {restart})
      (obj1 (opt "restart" bool))

  let make ?restart () = {restart}

  let restart t = t.restart
end

module BreakpointLocationsArguments : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    source:Source.t ->
    line:int ->
    ?column:int ->
    ?endLine:int ->
    ?endColumn:int ->
    unit ->
    t

  val source : t -> Source.t

  val line : t -> int

  val column : t -> int option

  val endLine : t -> int option

  val endColumn : t -> int option
end = struct
  type t = {
    source : Source.t;
    line : (int[@gen gen_int31]);
    column : (int option[@gen gen_int31_opt]);
    endLine : (int option[@gen gen_int31_opt]);
    endColumn : (int option[@gen gen_int31_opt]);
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* BreakpointLocationsArguments.t *)
    conv
      (fun {source; line; column; endLine; endColumn} ->
        (source, line, column, endLine, endColumn))
      (fun (source, line, column, endLine, endColumn) ->
        {source; line; column; endLine; endColumn})
      (obj5
         (req "source" Source.enc)
         (req "line" int31)
         (opt "column" int31)
         (opt "endLine" int31)
         (opt "endColumn" int31))

  let make ~source ~line ?column ?endLine ?endColumn () =
    {source; line; column; endLine; endColumn}

  let source t = t.source

  let line t = t.line

  let column t = t.column

  let endLine t = t.endLine

  let endColumn t = t.endColumn
end

module BreakpointLocation : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    line:int -> ?column:int -> ?endLine:int -> ?endColumn:int -> unit -> t

  val line : t -> int

  val column : t -> int option

  val endLine : t -> int option

  val endColumn : t -> int option
end = struct
  type t = {
    line : (int[@gen gen_int31]);
    column : (int option[@gen gen_int31_opt]);
    endLine : (int option[@gen gen_int31_opt]);
    endColumn : (int option[@gen gen_int31_opt]);
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* BreakpointLocation.t *)
    conv
      (fun {line; column; endLine; endColumn} ->
        (line, column, endLine, endColumn))
      (fun (line, column, endLine, endColumn) ->
        {line; column; endLine; endColumn})
      (obj4
         (req "line" int31)
         (opt "column" int31)
         (opt "endLine" int31)
         (opt "endColumn" int31))

  let make ~line ?column ?endLine ?endColumn () =
    {line; column; endLine; endColumn}

  let line t = t.line

  let column t = t.column

  let endLine t = t.endLine

  let endColumn t = t.endColumn
end

module BreakpointLocationsResponse_body : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : breakpoints:BreakpointLocation.t list -> unit -> t

  val breakpoints : t -> BreakpointLocation.t list
end = struct
  type t = {breakpoints : BreakpointLocation.t list} [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* BreakpointLocationsResponse_body.t *)
    conv
      (fun {breakpoints} -> breakpoints)
      (fun breakpoints -> {breakpoints})
      (obj1 (req "breakpoints" (list BreakpointLocation.enc)))

  let make ~breakpoints () = {breakpoints}

  let breakpoints t = t.breakpoints
end

module SourceBreakpoint : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    line:int ->
    ?column:int ->
    ?condition:string ->
    ?hitCondition:string ->
    ?logMessage:string ->
    unit ->
    t

  val line : t -> int

  val column : t -> int option

  val condition : t -> string option

  val hitCondition : t -> string option

  val logMessage : t -> string option
end = struct
  type t = {
    line : (int[@gen gen_int31]);
    column : (int option[@gen gen_int31_opt]);
    condition : (string option[@gen gen_utf8_str_opt]);
    hitCondition : (string option[@gen gen_utf8_str_opt]);
    logMessage : (string option[@gen gen_utf8_str_opt]);
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* SourceBreakpoint.t *)
    conv
      (fun {line; column; condition; hitCondition; logMessage} ->
        (line, column, condition, hitCondition, logMessage))
      (fun (line, column, condition, hitCondition, logMessage) ->
        {line; column; condition; hitCondition; logMessage})
      (obj5
         (req "line" int31)
         (opt "column" int31)
         (opt "condition" string)
         (opt "hitCondition" string)
         (opt "logMessage" string))

  let make ~line ?column ?condition ?hitCondition ?logMessage () =
    {line; column; condition; hitCondition; logMessage}

  let line t = t.line

  let column t = t.column

  let condition t = t.condition

  let hitCondition t = t.hitCondition

  let logMessage t = t.logMessage
end

module SetBreakpointsArguments : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    source:Source.t ->
    ?breakpoints:SourceBreakpoint.t list ->
    ?lines:int list ->
    ?sourceModified:bool ->
    unit ->
    t

  val source : t -> Source.t

  val breakpoints : t -> SourceBreakpoint.t list option

  val lines : t -> int list option

  val sourceModified : t -> bool option
end = struct
  type t = {
    source : Source.t;
    breakpoints : SourceBreakpoint.t list option;
    lines : (int list option[@gen gen_int31_list_opt]);
    sourceModified : bool option;
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* SetBreakpointsArguments.t *)
    conv
      (fun {source; breakpoints; lines; sourceModified} ->
        (source, breakpoints, lines, sourceModified))
      (fun (source, breakpoints, lines, sourceModified) ->
        {source; breakpoints; lines; sourceModified})
      (obj4
         (req "source" Source.enc)
         (opt "breakpoints" (list SourceBreakpoint.enc))
         (opt "lines" (list int31))
         (opt "sourceModified" bool))

  let make ~source ?breakpoints ?lines ?sourceModified () =
    {source; breakpoints; lines; sourceModified}

  let source t = t.source

  let breakpoints t = t.breakpoints

  let lines t = t.lines

  let sourceModified t = t.sourceModified
end

module SetBreakpointsResponse_body : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : breakpoints:Breakpoint.t list -> unit -> t

  val breakpoints : t -> Breakpoint.t list
end = struct
  type t = {breakpoints : Breakpoint.t list} [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* SetBreakpointsResponse_body.t *)
    conv
      (fun {breakpoints} -> breakpoints)
      (fun breakpoints -> {breakpoints})
      (obj1 (req "breakpoints" (list Breakpoint.enc)))

  let make ~breakpoints () = {breakpoints}

  let breakpoints t = t.breakpoints
end

module FunctionBreakpoint : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    name:string -> ?condition:string -> ?hitCondition:string -> unit -> t

  val name : t -> string

  val condition : t -> string option

  val hitCondition : t -> string option
end = struct
  type t = {
    name : (string[@gen gen_utf8_str]);
    condition : (string option[@gen gen_utf8_str_opt]);
    hitCondition : (string option[@gen gen_utf8_str_opt]);
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* FunctionBreakpoint.t *)
    conv
      (fun {name; condition; hitCondition} -> (name, condition, hitCondition))
      (fun (name, condition, hitCondition) -> {name; condition; hitCondition})
      (obj3
         (req "name" string)
         (opt "condition" string)
         (opt "hitCondition" string))

  let make ~name ?condition ?hitCondition () = {name; condition; hitCondition}

  let name t = t.name

  let condition t = t.condition

  let hitCondition t = t.hitCondition
end

module SetFunctionBreakpointsArguments : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : breakpoints:FunctionBreakpoint.t list -> unit -> t

  val breakpoints : t -> FunctionBreakpoint.t list
end = struct
  type t = {breakpoints : FunctionBreakpoint.t list} [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* SetFunctionBreakpointsArguments.t *)
    conv
      (fun {breakpoints} -> breakpoints)
      (fun breakpoints -> {breakpoints})
      (obj1 (req "breakpoints" (list FunctionBreakpoint.enc)))

  let make ~breakpoints () = {breakpoints}

  let breakpoints t = t.breakpoints
end

module SetFunctionBreakpointsResponse_body : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : breakpoints:Breakpoint.t list -> unit -> t

  val breakpoints : t -> Breakpoint.t list
end = struct
  type t = {breakpoints : Breakpoint.t list} [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* SetFunctionBreakpointsResponse_body.t *)
    conv
      (fun {breakpoints} -> breakpoints)
      (fun breakpoints -> {breakpoints})
      (obj1 (req "breakpoints" (list Breakpoint.enc)))

  let make ~breakpoints () = {breakpoints}

  let breakpoints t = t.breakpoints
end

module ExceptionFilterOptions : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : filterId:string -> ?condition:string -> unit -> t

  val filterId : t -> string

  val condition : t -> string option
end = struct
  type t = {
    filterId : (string[@gen gen_utf8_str]);
    condition : (string option[@gen gen_utf8_str_opt]);
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* ExceptionFilterOptions.t *)
    conv
      (fun {filterId; condition} -> (filterId, condition))
      (fun (filterId, condition) -> {filterId; condition})
      (obj2 (req "filterId" string) (opt "condition" string))

  let make ~filterId ?condition () = {filterId; condition}

  let filterId t = t.filterId

  let condition t = t.condition
end

module ExceptionPathSegment : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : ?negate:bool -> names:string list -> unit -> t

  val negate : t -> bool option

  val names : t -> string list
end = struct
  type t = {negate : bool option; names : (string list[@gen gen_utf8_str_list])}
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* ExceptionPathSegment.t *)
    conv
      (fun {negate; names} -> (negate, names))
      (fun (negate, names) -> {negate; names})
      (obj2 (opt "negate" bool) (req "names" (list string)))

  let make ?negate ~names () = {negate; names}

  let negate t = t.negate

  let names t = t.names
end

(* dont bother with a sig for enums, the inferred one is fine *)
module ExceptionBreakMode = struct
  type t = Never | Always | Unhandled | UserUnhandled [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    conv_with_guard
      (function
        | Never -> "never"
        | Always -> "always"
        | Unhandled -> "unhandled"
        | UserUnhandled -> "userUnhandled")
      (function
        | "never" -> Ok Never
        | "always" -> Ok Always
        | "unhandled" -> Ok Unhandled
        | "userUnhandled" -> Ok UserUnhandled
        | _ -> Error "ExceptionBreakMode")
      string
end

module ExceptionOptions : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    ?path:ExceptionPathSegment.t list ->
    breakMode:ExceptionBreakMode.t ->
    unit ->
    t

  val path : t -> ExceptionPathSegment.t list option

  val breakMode : t -> ExceptionBreakMode.t
end = struct
  type t = {
    path : ExceptionPathSegment.t list option;
    breakMode : ExceptionBreakMode.t;
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* ExceptionOptions.t *)
    conv
      (fun {path; breakMode} -> (path, breakMode))
      (fun (path, breakMode) -> {path; breakMode})
      (obj2
         (opt "path" (list ExceptionPathSegment.enc))
         (req "breakMode" ExceptionBreakMode.enc))

  let make ?path ~breakMode () = {path; breakMode}

  let path t = t.path

  let breakMode t = t.breakMode
end

module SetExceptionBreakpointsArguments : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    filters:string list ->
    ?filterOptions:ExceptionFilterOptions.t list ->
    ?exceptionOptions:ExceptionOptions.t list ->
    unit ->
    t

  val filters : t -> string list

  val filterOptions : t -> ExceptionFilterOptions.t list option

  val exceptionOptions : t -> ExceptionOptions.t list option
end = struct
  type t = {
    filters : (string list[@gen gen_utf8_str_list]);
    filterOptions : ExceptionFilterOptions.t list option;
    exceptionOptions : ExceptionOptions.t list option;
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* SetExceptionBreakpointsArguments.t *)
    conv
      (fun {filters; filterOptions; exceptionOptions} ->
        (filters, filterOptions, exceptionOptions))
      (fun (filters, filterOptions, exceptionOptions) ->
        {filters; filterOptions; exceptionOptions})
      (obj3
         (req "filters" (list string))
         (opt "filterOptions" (list ExceptionFilterOptions.enc))
         (opt "exceptionOptions" (list ExceptionOptions.enc)))

  let make ~filters ?filterOptions ?exceptionOptions () =
    {filters; filterOptions; exceptionOptions}

  let filters t = t.filters

  let filterOptions t = t.filterOptions

  let exceptionOptions t = t.exceptionOptions
end

module SetExceptionBreakpointsResponse_body : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : ?breakpoints:Breakpoint.t list -> unit -> t

  val breakpoints : t -> Breakpoint.t list option
end = struct
  type t = {breakpoints : Breakpoint.t list option} [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* SetExceptionBreakpointsResponse_body.t *)
    conv
      (fun {breakpoints} -> breakpoints)
      (fun breakpoints -> {breakpoints})
      (obj1 (opt "breakpoints" (list Breakpoint.enc)))

  let make ?breakpoints () = {breakpoints}

  let breakpoints t = t.breakpoints
end

module DataBreakpointInfoArguments : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : ?variablesReference:int -> name:string -> unit -> t

  val variablesReference : t -> int option

  val name : t -> string
end = struct
  type t = {
    variablesReference : (int option[@gen gen_int31_opt]);
    name : (string[@gen gen_utf8_str]);
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* DataBreakpointInfoArguments.t *)
    conv
      (fun {variablesReference; name} -> (variablesReference, name))
      (fun (variablesReference, name) -> {variablesReference; name})
      (obj2 (opt "variablesReference" int31) (req "name" string))

  let make ?variablesReference ~name () = {variablesReference; name}

  let variablesReference t = t.variablesReference

  let name t = t.name
end

(* dont bother with a sig for enums, the inferred one is fine *)
module DataBreakpointAccessType = struct
  type t = Read | Write | ReadWrite [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    conv_with_guard
      (function Read -> "read" | Write -> "write" | ReadWrite -> "readWrite")
      (function
        | "read" -> Ok Read
        | "write" -> Ok Write
        | "readWrite" -> Ok ReadWrite
        | _ -> Error "DataBreakpointAccessType")
      string
end

module DataBreakpointInfoResponse_body : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    dataId:string option ->
    description:string ->
    ?accessTypes:DataBreakpointAccessType.t list ->
    ?canPersist:bool ->
    unit ->
    t

  val dataId : t -> string option

  val description : t -> string

  val accessTypes : t -> DataBreakpointAccessType.t list option

  val canPersist : t -> bool option
end = struct
  type t = {
    dataId : (string option[@gen gen_utf8_str_opt]);
    description : (string[@gen gen_utf8_str]);
    accessTypes : DataBreakpointAccessType.t list option;
    canPersist : bool option;
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* DataBreakpointInfoResponse_body.t *)
    conv
      (fun {dataId; description; accessTypes; canPersist} ->
        (dataId, description, accessTypes, canPersist))
      (fun (dataId, description, accessTypes, canPersist) ->
        {dataId; description; accessTypes; canPersist})
      (obj4
         (req "dataId" (option string))
         (req "description" string)
         (opt "accessTypes" (list DataBreakpointAccessType.enc))
         (opt "canPersist" bool))

  let make ~dataId ~description ?accessTypes ?canPersist () =
    {dataId; description; accessTypes; canPersist}

  let dataId t = t.dataId

  let description t = t.description

  let accessTypes t = t.accessTypes

  let canPersist t = t.canPersist
end

module DataBreakpoint : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    dataId:string ->
    ?accessType:DataBreakpointAccessType.t ->
    ?condition:string ->
    ?hitCondition:string ->
    unit ->
    t

  val dataId : t -> string

  val accessType : t -> DataBreakpointAccessType.t option

  val condition : t -> string option

  val hitCondition : t -> string option
end = struct
  type t = {
    dataId : (string[@gen gen_utf8_str]);
    accessType : DataBreakpointAccessType.t option;
    condition : (string option[@gen gen_utf8_str_opt]);
    hitCondition : (string option[@gen gen_utf8_str_opt]);
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* DataBreakpoint.t *)
    conv
      (fun {dataId; accessType; condition; hitCondition} ->
        (dataId, accessType, condition, hitCondition))
      (fun (dataId, accessType, condition, hitCondition) ->
        {dataId; accessType; condition; hitCondition})
      (obj4
         (req "dataId" string)
         (opt "accessType" DataBreakpointAccessType.enc)
         (opt "condition" string)
         (opt "hitCondition" string))

  let make ~dataId ?accessType ?condition ?hitCondition () =
    {dataId; accessType; condition; hitCondition}

  let dataId t = t.dataId

  let accessType t = t.accessType

  let condition t = t.condition

  let hitCondition t = t.hitCondition
end

module SetDataBreakpointsArguments : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : breakpoints:DataBreakpoint.t list -> unit -> t

  val breakpoints : t -> DataBreakpoint.t list
end = struct
  type t = {breakpoints : DataBreakpoint.t list} [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* SetDataBreakpointsArguments.t *)
    conv
      (fun {breakpoints} -> breakpoints)
      (fun breakpoints -> {breakpoints})
      (obj1 (req "breakpoints" (list DataBreakpoint.enc)))

  let make ~breakpoints () = {breakpoints}

  let breakpoints t = t.breakpoints
end

module SetDataBreakpointsResponse_body : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : breakpoints:Breakpoint.t list -> unit -> t

  val breakpoints : t -> Breakpoint.t list
end = struct
  type t = {breakpoints : Breakpoint.t list} [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* SetDataBreakpointsResponse_body.t *)
    conv
      (fun {breakpoints} -> breakpoints)
      (fun breakpoints -> {breakpoints})
      (obj1 (req "breakpoints" (list Breakpoint.enc)))

  let make ~breakpoints () = {breakpoints}

  let breakpoints t = t.breakpoints
end

module InstructionBreakpoint : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    instructionReference:string ->
    ?offset:int ->
    ?condition:string ->
    ?hitCondition:string ->
    unit ->
    t

  val instructionReference : t -> string

  val offset : t -> int option

  val condition : t -> string option

  val hitCondition : t -> string option
end = struct
  type t = {
    instructionReference : (string[@gen gen_utf8_str]);
    offset : (int option[@gen gen_int31_opt]);
    condition : (string option[@gen gen_utf8_str_opt]);
    hitCondition : (string option[@gen gen_utf8_str_opt]);
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* InstructionBreakpoint.t *)
    conv
      (fun {instructionReference; offset; condition; hitCondition} ->
        (instructionReference, offset, condition, hitCondition))
      (fun (instructionReference, offset, condition, hitCondition) ->
        {instructionReference; offset; condition; hitCondition})
      (obj4
         (req "instructionReference" string)
         (opt "offset" int31)
         (opt "condition" string)
         (opt "hitCondition" string))

  let make ~instructionReference ?offset ?condition ?hitCondition () =
    {instructionReference; offset; condition; hitCondition}

  let instructionReference t = t.instructionReference

  let offset t = t.offset

  let condition t = t.condition

  let hitCondition t = t.hitCondition
end

module SetInstructionBreakpointsArguments : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : breakpoints:InstructionBreakpoint.t list -> unit -> t

  val breakpoints : t -> InstructionBreakpoint.t list
end = struct
  type t = {breakpoints : InstructionBreakpoint.t list} [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* SetInstructionBreakpointsArguments.t *)
    conv
      (fun {breakpoints} -> breakpoints)
      (fun breakpoints -> {breakpoints})
      (obj1 (req "breakpoints" (list InstructionBreakpoint.enc)))

  let make ~breakpoints () = {breakpoints}

  let breakpoints t = t.breakpoints
end

module SetInstructionBreakpointsResponse_body : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : breakpoints:Breakpoint.t list -> unit -> t

  val breakpoints : t -> Breakpoint.t list
end = struct
  type t = {breakpoints : Breakpoint.t list} [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* SetInstructionBreakpointsResponse_body.t *)
    conv
      (fun {breakpoints} -> breakpoints)
      (fun breakpoints -> {breakpoints})
      (obj1 (req "breakpoints" (list Breakpoint.enc)))

  let make ~breakpoints () = {breakpoints}

  let breakpoints t = t.breakpoints
end

module ContinueArguments : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : threadId:int -> ?singleThread:bool -> unit -> t

  val threadId : t -> int

  val singleThread : t -> bool option
end = struct
  type t = {threadId : (int[@gen gen_int31]); singleThread : bool option}
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* ContinueArguments.t *)
    conv
      (fun {threadId; singleThread} -> (threadId, singleThread))
      (fun (threadId, singleThread) -> {threadId; singleThread})
      (obj2 (req "threadId" int31) (opt "singleThread" bool))

  let make ~threadId ?singleThread () = {threadId; singleThread}

  let threadId t = t.threadId

  let singleThread t = t.singleThread
end

module ContinueResponse_body : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : ?allThreadsContinued:bool -> unit -> t

  val allThreadsContinued : t -> bool option
end = struct
  type t = {allThreadsContinued : bool option} [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* ContinueResponse_body.t *)
    conv
      (fun {allThreadsContinued} -> allThreadsContinued)
      (fun allThreadsContinued -> {allThreadsContinued})
      (obj1 (opt "allThreadsContinued" bool))

  let make ?allThreadsContinued () = {allThreadsContinued}

  let allThreadsContinued t = t.allThreadsContinued
end

(* dont bother with a sig for enums, the inferred one is fine *)
module SteppingGranularity = struct
  type t = Statement | Line | Instruction [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    conv_with_guard
      (function
        | Statement -> "statement"
        | Line -> "line"
        | Instruction -> "instruction")
      (function
        | "statement" -> Ok Statement
        | "line" -> Ok Line
        | "instruction" -> Ok Instruction
        | _ -> Error "SteppingGranularity")
      string
end

module NextArguments : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    threadId:int ->
    ?singleThread:bool ->
    ?granularity:SteppingGranularity.t ->
    unit ->
    t

  val threadId : t -> int

  val singleThread : t -> bool option

  val granularity : t -> SteppingGranularity.t option
end = struct
  type t = {
    threadId : (int[@gen gen_int31]);
    singleThread : bool option;
    granularity : SteppingGranularity.t option;
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* NextArguments.t *)
    conv
      (fun {threadId; singleThread; granularity} ->
        (threadId, singleThread, granularity))
      (fun (threadId, singleThread, granularity) ->
        {threadId; singleThread; granularity})
      (obj3
         (req "threadId" int31)
         (opt "singleThread" bool)
         (opt "granularity" SteppingGranularity.enc))

  let make ~threadId ?singleThread ?granularity () =
    {threadId; singleThread; granularity}

  let threadId t = t.threadId

  let singleThread t = t.singleThread

  let granularity t = t.granularity
end

module StepInArguments : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    threadId:int ->
    ?singleThread:bool ->
    ?targetId:int ->
    ?granularity:SteppingGranularity.t ->
    unit ->
    t

  val threadId : t -> int

  val singleThread : t -> bool option

  val targetId : t -> int option

  val granularity : t -> SteppingGranularity.t option
end = struct
  type t = {
    threadId : (int[@gen gen_int31]);
    singleThread : bool option;
    targetId : (int option[@gen gen_int31_opt]);
    granularity : SteppingGranularity.t option;
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* StepInArguments.t *)
    conv
      (fun {threadId; singleThread; targetId; granularity} ->
        (threadId, singleThread, targetId, granularity))
      (fun (threadId, singleThread, targetId, granularity) ->
        {threadId; singleThread; targetId; granularity})
      (obj4
         (req "threadId" int31)
         (opt "singleThread" bool)
         (opt "targetId" int31)
         (opt "granularity" SteppingGranularity.enc))

  let make ~threadId ?singleThread ?targetId ?granularity () =
    {threadId; singleThread; targetId; granularity}

  let threadId t = t.threadId

  let singleThread t = t.singleThread

  let targetId t = t.targetId

  let granularity t = t.granularity
end

module StepOutArguments : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    threadId:int ->
    ?singleThread:bool ->
    ?granularity:SteppingGranularity.t ->
    unit ->
    t

  val threadId : t -> int

  val singleThread : t -> bool option

  val granularity : t -> SteppingGranularity.t option
end = struct
  type t = {
    threadId : (int[@gen gen_int31]);
    singleThread : bool option;
    granularity : SteppingGranularity.t option;
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* StepOutArguments.t *)
    conv
      (fun {threadId; singleThread; granularity} ->
        (threadId, singleThread, granularity))
      (fun (threadId, singleThread, granularity) ->
        {threadId; singleThread; granularity})
      (obj3
         (req "threadId" int31)
         (opt "singleThread" bool)
         (opt "granularity" SteppingGranularity.enc))

  let make ~threadId ?singleThread ?granularity () =
    {threadId; singleThread; granularity}

  let threadId t = t.threadId

  let singleThread t = t.singleThread

  let granularity t = t.granularity
end

module StepBackArguments : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    threadId:int ->
    ?singleThread:bool ->
    ?granularity:SteppingGranularity.t ->
    unit ->
    t

  val threadId : t -> int

  val singleThread : t -> bool option

  val granularity : t -> SteppingGranularity.t option
end = struct
  type t = {
    threadId : (int[@gen gen_int31]);
    singleThread : bool option;
    granularity : SteppingGranularity.t option;
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* StepBackArguments.t *)
    conv
      (fun {threadId; singleThread; granularity} ->
        (threadId, singleThread, granularity))
      (fun (threadId, singleThread, granularity) ->
        {threadId; singleThread; granularity})
      (obj3
         (req "threadId" int31)
         (opt "singleThread" bool)
         (opt "granularity" SteppingGranularity.enc))

  let make ~threadId ?singleThread ?granularity () =
    {threadId; singleThread; granularity}

  let threadId t = t.threadId

  let singleThread t = t.singleThread

  let granularity t = t.granularity
end

module ReverseContinueArguments : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : threadId:int -> ?singleThread:bool -> unit -> t

  val threadId : t -> int

  val singleThread : t -> bool option
end = struct
  type t = {threadId : (int[@gen gen_int31]); singleThread : bool option}
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* ReverseContinueArguments.t *)
    conv
      (fun {threadId; singleThread} -> (threadId, singleThread))
      (fun (threadId, singleThread) -> {threadId; singleThread})
      (obj2 (req "threadId" int31) (opt "singleThread" bool))

  let make ~threadId ?singleThread () = {threadId; singleThread}

  let threadId t = t.threadId

  let singleThread t = t.singleThread
end

module RestartFrameArguments : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : frameId:int -> unit -> t

  val frameId : t -> int
end = struct
  type t = {frameId : int} [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* RestartFrameArguments.t *)
    conv
      (fun {frameId} -> frameId)
      (fun frameId -> {frameId})
      (obj1 (req "frameId" int31))

  let make ~frameId () = {frameId}

  let frameId t = t.frameId
end

module GotoArguments : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : threadId:int -> targetId:int -> unit -> t

  val threadId : t -> int

  val targetId : t -> int
end = struct
  type t = {threadId : (int[@gen gen_int31]); targetId : int}
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* GotoArguments.t *)
    conv
      (fun {threadId; targetId} -> (threadId, targetId))
      (fun (threadId, targetId) -> {threadId; targetId})
      (obj2 (req "threadId" int31) (req "targetId" int31))

  let make ~threadId ~targetId () = {threadId; targetId}

  let threadId t = t.threadId

  let targetId t = t.targetId
end

module PauseArguments : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : threadId:int -> unit -> t

  val threadId : t -> int
end = struct
  type t = {threadId : int} [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* PauseArguments.t *)
    conv
      (fun {threadId} -> threadId)
      (fun threadId -> {threadId})
      (obj1 (req "threadId" int31))

  let make ~threadId () = {threadId}

  let threadId t = t.threadId
end

module ValueFormat : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : ?hex:bool -> unit -> t

  val hex : t -> bool option
end = struct
  type t = {hex : bool option} [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* ValueFormat.t *)
    conv (fun {hex} -> hex) (fun hex -> {hex}) (obj1 (opt "hex" bool))

  let make ?hex () = {hex}

  let hex t = t.hex
end

module StackFrameFormat : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    ?hex:bool ->
    ?parameters:bool ->
    ?parameterTypes:bool ->
    ?parameterNames:bool ->
    ?parameterValues:bool ->
    ?line:bool ->
    ?module_:bool ->
    ?includeAll:bool ->
    unit ->
    t

  val hex : t -> bool option

  val parameters : t -> bool option

  val parameterTypes : t -> bool option

  val parameterNames : t -> bool option

  val parameterValues : t -> bool option

  val line : t -> bool option

  val module_ : t -> bool option

  val includeAll : t -> bool option
end = struct
  type t = {
    hex : bool option;
    parameters : bool option;
    parameterTypes : bool option;
    parameterNames : bool option;
    parameterValues : bool option;
    line : bool option;
    module_ : bool option;
    includeAll : bool option;
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* StackFrameFormat.t *)
    conv
      (fun {
             hex;
             parameters;
             parameterTypes;
             parameterNames;
             parameterValues;
             line;
             module_;
             includeAll;
           } ->
        ( hex,
          parameters,
          parameterTypes,
          parameterNames,
          parameterValues,
          line,
          module_,
          includeAll ))
      (fun ( hex,
             parameters,
             parameterTypes,
             parameterNames,
             parameterValues,
             line,
             module_,
             includeAll ) ->
        {
          hex;
          parameters;
          parameterTypes;
          parameterNames;
          parameterValues;
          line;
          module_;
          includeAll;
        })
      (obj8
         (opt "hex" bool)
         (opt "parameters" bool)
         (opt "parameterTypes" bool)
         (opt "parameterNames" bool)
         (opt "parameterValues" bool)
         (opt "line" bool)
         (opt "module" bool)
         (opt "includeAll" bool))

  let make ?hex ?parameters ?parameterTypes ?parameterNames ?parameterValues
      ?line ?module_ ?includeAll () =
    {
      hex;
      parameters;
      parameterTypes;
      parameterNames;
      parameterValues;
      line;
      module_;
      includeAll;
    }

  let hex t = t.hex

  let parameters t = t.parameters

  let parameterTypes t = t.parameterTypes

  let parameterNames t = t.parameterNames

  let parameterValues t = t.parameterValues

  let line t = t.line

  let module_ t = t.module_

  let includeAll t = t.includeAll
end

module StackTraceArguments : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    threadId:int ->
    ?startFrame:int ->
    ?levels:int ->
    ?format:StackFrameFormat.t ->
    unit ->
    t

  val threadId : t -> int

  val startFrame : t -> int option

  val levels : t -> int option

  val format : t -> StackFrameFormat.t option
end = struct
  type t = {
    threadId : (int[@gen gen_int31]);
    startFrame : (int option[@gen gen_int31_opt]);
    levels : (int option[@gen gen_int31_opt]);
    format : StackFrameFormat.t option;
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* StackTraceArguments.t *)
    conv
      (fun {threadId; startFrame; levels; format} ->
        (threadId, startFrame, levels, format))
      (fun (threadId, startFrame, levels, format) ->
        {threadId; startFrame; levels; format})
      (obj4
         (req "threadId" int31)
         (opt "startFrame" int31)
         (opt "levels" int31)
         (opt "format" StackFrameFormat.enc))

  let make ~threadId ?startFrame ?levels ?format () =
    {threadId; startFrame; levels; format}

  let threadId t = t.threadId

  let startFrame t = t.startFrame

  let levels t = t.levels

  let format t = t.format
end

(* dont bother with a sig for enums, the inferred one is fine *)
module StackFrame_presentationHint = struct
  type t = Normal | Label | Subtle [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    conv_with_guard
      (function Normal -> "normal" | Label -> "label" | Subtle -> "subtle")
      (function
        | "normal" -> Ok Normal
        | "label" -> Ok Label
        | "subtle" -> Ok Subtle
        | _ -> Error "StackFrame_presentationHint")
      string
end

module StackFrame : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    id:int ->
    name:string ->
    ?source:Source.t ->
    line:int ->
    column:int ->
    ?endLine:int ->
    ?endColumn:int ->
    ?canRestart:bool ->
    ?instructionPointerReference:string ->
    ?moduleId:IntString.t ->
    ?presentationHint:StackFrame_presentationHint.t ->
    unit ->
    t

  val id : t -> int

  val name : t -> string

  val source : t -> Source.t option

  val line : t -> int

  val column : t -> int

  val endLine : t -> int option

  val endColumn : t -> int option

  val canRestart : t -> bool option

  val instructionPointerReference : t -> string option

  val moduleId : t -> IntString.t option

  val presentationHint : t -> StackFrame_presentationHint.t option
end = struct
  module StackFrame_0 : sig
    type t

    val enc : t Data_encoding.t

    val gen : t QCheck.Gen.t

    val make :
      id:int ->
      name:string ->
      ?source:Source.t ->
      line:int ->
      column:int ->
      ?endLine:int ->
      ?endColumn:int ->
      ?canRestart:bool ->
      ?instructionPointerReference:string ->
      ?moduleId:IntString.t ->
      unit ->
      t

    val id : t -> int

    val name : t -> string

    val source : t -> Source.t option

    val line : t -> int

    val column : t -> int

    val endLine : t -> int option

    val endColumn : t -> int option

    val canRestart : t -> bool option

    val instructionPointerReference : t -> string option

    val moduleId : t -> IntString.t option
  end = struct
    type t = {
      id : (int[@gen gen_int31]);
      name : (string[@gen gen_utf8_str]);
      source : Source.t option;
      line : (int[@gen gen_int31]);
      column : (int[@gen gen_int31]);
      endLine : (int option[@gen gen_int31_opt]);
      endColumn : (int option[@gen gen_int31_opt]);
      canRestart : bool option;
      instructionPointerReference : (string option[@gen gen_utf8_str_opt]);
      moduleId : IntString.t option;
    }
    [@@deriving qcheck]

    let enc =
      let open Data_encoding in
      (* StackFrame_0.t *)
      conv
        (fun {
               id;
               name;
               source;
               line;
               column;
               endLine;
               endColumn;
               canRestart;
               instructionPointerReference;
               moduleId;
             } ->
          ( id,
            name,
            source,
            line,
            column,
            endLine,
            endColumn,
            canRestart,
            instructionPointerReference,
            moduleId ))
        (fun ( id,
               name,
               source,
               line,
               column,
               endLine,
               endColumn,
               canRestart,
               instructionPointerReference,
               moduleId ) ->
          {
            id;
            name;
            source;
            line;
            column;
            endLine;
            endColumn;
            canRestart;
            instructionPointerReference;
            moduleId;
          })
        (obj10
           (req "id" int31)
           (req "name" string)
           (opt "source" Source.enc)
           (req "line" int31)
           (req "column" int31)
           (opt "endLine" int31)
           (opt "endColumn" int31)
           (opt "canRestart" bool)
           (opt "instructionPointerReference" string)
           (opt "moduleId" IntString.enc))

    let make ~id ~name ?source ~line ~column ?endLine ?endColumn ?canRestart
        ?instructionPointerReference ?moduleId () =
      {
        id;
        name;
        source;
        line;
        column;
        endLine;
        endColumn;
        canRestart;
        instructionPointerReference;
        moduleId;
      }

    let id t = t.id

    let name t = t.name

    let source t = t.source

    let line t = t.line

    let column t = t.column

    let endLine t = t.endLine

    let endColumn t = t.endColumn

    let canRestart t = t.canRestart

    let instructionPointerReference t = t.instructionPointerReference

    let moduleId t = t.moduleId
  end

  module StackFrame_10 : sig
    type t

    val enc : t Data_encoding.t

    val gen : t QCheck.Gen.t

    val make : ?presentationHint:StackFrame_presentationHint.t -> unit -> t

    val presentationHint : t -> StackFrame_presentationHint.t option
  end = struct
    type t = {presentationHint : StackFrame_presentationHint.t option}
    [@@deriving qcheck]

    let enc =
      let open Data_encoding in
      (* StackFrame_10.t *)
      conv
        (fun {presentationHint} -> presentationHint)
        (fun presentationHint -> {presentationHint})
        (obj1 (opt "presentationHint" StackFrame_presentationHint.enc))

    let make ?presentationHint () = {presentationHint}

    let presentationHint t = t.presentationHint
  end

  type t = StackFrame_0.t * StackFrame_10.t [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    merge_objs StackFrame_0.enc StackFrame_10.enc

  let make ~id ~name ?source ~line ~column ?endLine ?endColumn ?canRestart
      ?instructionPointerReference ?moduleId ?presentationHint () =
    let t0 =
      StackFrame_0.make
        ~id
        ~name
        ?source
        ~line
        ~column
        ?endLine
        ?endColumn
        ?canRestart
        ?instructionPointerReference
        ?moduleId
        ()
    in

    let t1 = StackFrame_10.make ?presentationHint () in

    (t0, t1)

  let id (_t0, _t1) = StackFrame_0.id _t0

  let name (_t0, _t1) = StackFrame_0.name _t0

  let source (_t0, _t1) = StackFrame_0.source _t0

  let line (_t0, _t1) = StackFrame_0.line _t0

  let column (_t0, _t1) = StackFrame_0.column _t0

  let endLine (_t0, _t1) = StackFrame_0.endLine _t0

  let endColumn (_t0, _t1) = StackFrame_0.endColumn _t0

  let canRestart (_t0, _t1) = StackFrame_0.canRestart _t0

  let instructionPointerReference (_t0, _t1) =
    StackFrame_0.instructionPointerReference _t0

  let moduleId (_t0, _t1) = StackFrame_0.moduleId _t0

  let presentationHint (_t0, _t1) = StackFrame_10.presentationHint _t1
end

module StackTraceResponse_body : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : stackFrames:StackFrame.t list -> ?totalFrames:int -> unit -> t

  val stackFrames : t -> StackFrame.t list

  val totalFrames : t -> int option
end = struct
  type t = {
    stackFrames : StackFrame.t list;
    totalFrames : (int option[@gen gen_int31_opt]);
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* StackTraceResponse_body.t *)
    conv
      (fun {stackFrames; totalFrames} -> (stackFrames, totalFrames))
      (fun (stackFrames, totalFrames) -> {stackFrames; totalFrames})
      (obj2 (req "stackFrames" (list StackFrame.enc)) (opt "totalFrames" int31))

  let make ~stackFrames ?totalFrames () = {stackFrames; totalFrames}

  let stackFrames t = t.stackFrames

  let totalFrames t = t.totalFrames
end

module ScopesArguments : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : frameId:int -> unit -> t

  val frameId : t -> int
end = struct
  type t = {frameId : int} [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* ScopesArguments.t *)
    conv
      (fun {frameId} -> frameId)
      (fun frameId -> {frameId})
      (obj1 (req "frameId" int31))

  let make ~frameId () = {frameId}

  let frameId t = t.frameId
end

(* dont bother with a sig for enums, the inferred one is fine *)
module Scope_presentationHint = struct
  type t = Arguments | Locals | Registers | Other of (string [@gen gen_utf8_str])
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    conv_with_guard
      (function
        | Arguments -> "arguments"
        | Locals -> "locals"
        | Registers -> "registers"
        | Other s -> s)
      (function
        | "arguments" -> Ok Arguments
        | "locals" -> Ok Locals
        | "registers" -> Ok Registers
        | _ as s -> Ok (Other s))
      string
end

module Scope : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    name:string ->
    ?presentationHint:Scope_presentationHint.t ->
    variablesReference:int ->
    ?namedVariables:int ->
    ?indexedVariables:int ->
    expensive:bool ->
    ?source:Source.t ->
    ?line:int ->
    ?column:int ->
    ?endLine:int ->
    ?endColumn:int ->
    unit ->
    t

  val name : t -> string

  val presentationHint : t -> Scope_presentationHint.t option

  val variablesReference : t -> int

  val namedVariables : t -> int option

  val indexedVariables : t -> int option

  val expensive : t -> bool

  val source : t -> Source.t option

  val line : t -> int option

  val column : t -> int option

  val endLine : t -> int option

  val endColumn : t -> int option
end = struct
  module Scope_0 : sig
    type t

    val enc : t Data_encoding.t

    val gen : t QCheck.Gen.t

    val make :
      name:string ->
      ?presentationHint:Scope_presentationHint.t ->
      variablesReference:int ->
      ?namedVariables:int ->
      ?indexedVariables:int ->
      expensive:bool ->
      ?source:Source.t ->
      ?line:int ->
      ?column:int ->
      ?endLine:int ->
      unit ->
      t

    val name : t -> string

    val presentationHint : t -> Scope_presentationHint.t option

    val variablesReference : t -> int

    val namedVariables : t -> int option

    val indexedVariables : t -> int option

    val expensive : t -> bool

    val source : t -> Source.t option

    val line : t -> int option

    val column : t -> int option

    val endLine : t -> int option
  end = struct
    type t = {
      name : (string[@gen gen_utf8_str]);
      presentationHint : Scope_presentationHint.t option;
      variablesReference : (int[@gen gen_int31]);
      namedVariables : (int option[@gen gen_int31_opt]);
      indexedVariables : (int option[@gen gen_int31_opt]);
      expensive : bool;
      source : Source.t option;
      line : (int option[@gen gen_int31_opt]);
      column : (int option[@gen gen_int31_opt]);
      endLine : (int option[@gen gen_int31_opt]);
    }
    [@@deriving qcheck]

    let enc =
      let open Data_encoding in
      (* Scope_0.t *)
      conv
        (fun {
               name;
               presentationHint;
               variablesReference;
               namedVariables;
               indexedVariables;
               expensive;
               source;
               line;
               column;
               endLine;
             } ->
          ( name,
            presentationHint,
            variablesReference,
            namedVariables,
            indexedVariables,
            expensive,
            source,
            line,
            column,
            endLine ))
        (fun ( name,
               presentationHint,
               variablesReference,
               namedVariables,
               indexedVariables,
               expensive,
               source,
               line,
               column,
               endLine ) ->
          {
            name;
            presentationHint;
            variablesReference;
            namedVariables;
            indexedVariables;
            expensive;
            source;
            line;
            column;
            endLine;
          })
        (obj10
           (req "name" string)
           (opt "presentationHint" Scope_presentationHint.enc)
           (req "variablesReference" int31)
           (opt "namedVariables" int31)
           (opt "indexedVariables" int31)
           (req "expensive" bool)
           (opt "source" Source.enc)
           (opt "line" int31)
           (opt "column" int31)
           (opt "endLine" int31))

    let make ~name ?presentationHint ~variablesReference ?namedVariables
        ?indexedVariables ~expensive ?source ?line ?column ?endLine () =
      {
        name;
        presentationHint;
        variablesReference;
        namedVariables;
        indexedVariables;
        expensive;
        source;
        line;
        column;
        endLine;
      }

    let name t = t.name

    let presentationHint t = t.presentationHint

    let variablesReference t = t.variablesReference

    let namedVariables t = t.namedVariables

    let indexedVariables t = t.indexedVariables

    let expensive t = t.expensive

    let source t = t.source

    let line t = t.line

    let column t = t.column

    let endLine t = t.endLine
  end

  module Scope_10 : sig
    type t

    val enc : t Data_encoding.t

    val gen : t QCheck.Gen.t

    val make : ?endColumn:int -> unit -> t

    val endColumn : t -> int option
  end = struct
    type t = {endColumn : (int option[@gen gen_int31_opt])} [@@deriving qcheck]

    let enc =
      let open Data_encoding in
      (* Scope_10.t *)
      conv
        (fun {endColumn} -> endColumn)
        (fun endColumn -> {endColumn})
        (obj1 (opt "endColumn" int31))

    let make ?endColumn () = {endColumn}

    let endColumn t = t.endColumn
  end

  type t = Scope_0.t * Scope_10.t [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    merge_objs Scope_0.enc Scope_10.enc

  let make ~name ?presentationHint ~variablesReference ?namedVariables
      ?indexedVariables ~expensive ?source ?line ?column ?endLine ?endColumn ()
      =
    let t0 =
      Scope_0.make
        ~name
        ?presentationHint
        ~variablesReference
        ?namedVariables
        ?indexedVariables
        ~expensive
        ?source
        ?line
        ?column
        ?endLine
        ()
    in

    let t1 = Scope_10.make ?endColumn () in

    (t0, t1)

  let name (_t0, _t1) = Scope_0.name _t0

  let presentationHint (_t0, _t1) = Scope_0.presentationHint _t0

  let variablesReference (_t0, _t1) = Scope_0.variablesReference _t0

  let namedVariables (_t0, _t1) = Scope_0.namedVariables _t0

  let indexedVariables (_t0, _t1) = Scope_0.indexedVariables _t0

  let expensive (_t0, _t1) = Scope_0.expensive _t0

  let source (_t0, _t1) = Scope_0.source _t0

  let line (_t0, _t1) = Scope_0.line _t0

  let column (_t0, _t1) = Scope_0.column _t0

  let endLine (_t0, _t1) = Scope_0.endLine _t0

  let endColumn (_t0, _t1) = Scope_10.endColumn _t1
end

module ScopesResponse_body : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : scopes:Scope.t list -> unit -> t

  val scopes : t -> Scope.t list
end = struct
  type t = {scopes : Scope.t list} [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* ScopesResponse_body.t *)
    conv
      (fun {scopes} -> scopes)
      (fun scopes -> {scopes})
      (obj1 (req "scopes" (list Scope.enc)))

  let make ~scopes () = {scopes}

  let scopes t = t.scopes
end

(* dont bother with a sig for enums, the inferred one is fine *)
module VariablesArguments_filter = struct
  type t = Indexed | Named [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    conv_with_guard
      (function Indexed -> "indexed" | Named -> "named")
      (function
        | "indexed" -> Ok Indexed
        | "named" -> Ok Named
        | _ -> Error "VariablesArguments_filter")
      string
end

module VariablesArguments : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    variablesReference:int ->
    ?filter:VariablesArguments_filter.t ->
    ?start:int ->
    ?count:int ->
    ?format:ValueFormat.t ->
    unit ->
    t

  val variablesReference : t -> int

  val filter : t -> VariablesArguments_filter.t option

  val start : t -> int option

  val count : t -> int option

  val format : t -> ValueFormat.t option
end = struct
  type t = {
    variablesReference : (int[@gen gen_int31]);
    filter : VariablesArguments_filter.t option;
    start : (int option[@gen gen_int31_opt]);
    count : (int option[@gen gen_int31_opt]);
    format : ValueFormat.t option;
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* VariablesArguments.t *)
    conv
      (fun {variablesReference; filter; start; count; format} ->
        (variablesReference, filter, start, count, format))
      (fun (variablesReference, filter, start, count, format) ->
        {variablesReference; filter; start; count; format})
      (obj5
         (req "variablesReference" int31)
         (opt "filter" VariablesArguments_filter.enc)
         (opt "start" int31)
         (opt "count" int31)
         (opt "format" ValueFormat.enc))

  let make ~variablesReference ?filter ?start ?count ?format () =
    {variablesReference; filter; start; count; format}

  let variablesReference t = t.variablesReference

  let filter t = t.filter

  let start t = t.start

  let count t = t.count

  let format t = t.format
end

(* dont bother with a sig for enums, the inferred one is fine *)
module VariablePresentationHint_kind = struct
  type t =
    | Property
    | Method
    | Class
    | Data
    | Event
    | BaseClass
    | InnerClass
    | Interface
    | MostDerivedClass
    | Virtual
    | DataBreakpoint
    | Other of (string [@gen gen_utf8_str])
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    conv_with_guard
      (function
        | Property -> "property"
        | Method -> "method"
        | Class -> "class"
        | Data -> "data"
        | Event -> "event"
        | BaseClass -> "baseClass"
        | InnerClass -> "innerClass"
        | Interface -> "interface"
        | MostDerivedClass -> "mostDerivedClass"
        | Virtual -> "virtual"
        | DataBreakpoint -> "dataBreakpoint"
        | Other s -> s)
      (function
        | "property" -> Ok Property
        | "method" -> Ok Method
        | "class" -> Ok Class
        | "data" -> Ok Data
        | "event" -> Ok Event
        | "baseClass" -> Ok BaseClass
        | "innerClass" -> Ok InnerClass
        | "interface" -> Ok Interface
        | "mostDerivedClass" -> Ok MostDerivedClass
        | "virtual" -> Ok Virtual
        | "dataBreakpoint" -> Ok DataBreakpoint
        | _ as s -> Ok (Other s))
      string
end

(* dont bother with a sig for enums, the inferred one is fine *)
module VariablePresentationHint_attributes_items = struct
  type t =
    | Static
    | Constant
    | ReadOnly
    | RawString
    | HasObjectId
    | CanHaveObjectId
    | HasSideEffects
    | HasDataBreakpoint
    | Other of (string [@gen gen_utf8_str])
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    conv_with_guard
      (function
        | Static -> "static"
        | Constant -> "constant"
        | ReadOnly -> "readOnly"
        | RawString -> "rawString"
        | HasObjectId -> "hasObjectId"
        | CanHaveObjectId -> "canHaveObjectId"
        | HasSideEffects -> "hasSideEffects"
        | HasDataBreakpoint -> "hasDataBreakpoint"
        | Other s -> s)
      (function
        | "static" -> Ok Static
        | "constant" -> Ok Constant
        | "readOnly" -> Ok ReadOnly
        | "rawString" -> Ok RawString
        | "hasObjectId" -> Ok HasObjectId
        | "canHaveObjectId" -> Ok CanHaveObjectId
        | "hasSideEffects" -> Ok HasSideEffects
        | "hasDataBreakpoint" -> Ok HasDataBreakpoint
        | _ as s -> Ok (Other s))
      string
end

(* dont bother with a sig for enums, the inferred one is fine *)
module VariablePresentationHint_visibility = struct
  type t = Public | Private | Protected | Internal | Final | Other of (string [@gen gen_utf8_str])
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    conv_with_guard
      (function
        | Public -> "public"
        | Private -> "private"
        | Protected -> "protected"
        | Internal -> "internal"
        | Final -> "final"
        | Other s -> s)
      (function
        | "public" -> Ok Public
        | "private" -> Ok Private
        | "protected" -> Ok Protected
        | "internal" -> Ok Internal
        | "final" -> Ok Final
        | _ as s -> Ok (Other s))
      string
end

module VariablePresentationHint : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    ?kind:VariablePresentationHint_kind.t ->
    ?attributes:VariablePresentationHint_attributes_items.t list ->
    ?visibility:VariablePresentationHint_visibility.t ->
    ?lazy_:bool ->
    unit ->
    t

  val kind : t -> VariablePresentationHint_kind.t option

  val attributes : t -> VariablePresentationHint_attributes_items.t list option

  val visibility : t -> VariablePresentationHint_visibility.t option

  val lazy_ : t -> bool option
end = struct
  type t = {
    kind : VariablePresentationHint_kind.t option;
    attributes : VariablePresentationHint_attributes_items.t list option;
    visibility : VariablePresentationHint_visibility.t option;
    lazy_ : bool option;
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* VariablePresentationHint.t *)
    conv
      (fun {kind; attributes; visibility; lazy_} ->
        (kind, attributes, visibility, lazy_))
      (fun (kind, attributes, visibility, lazy_) ->
        {kind; attributes; visibility; lazy_})
      (obj4
         (opt "kind" VariablePresentationHint_kind.enc)
         (opt "attributes" (list VariablePresentationHint_attributes_items.enc))
         (opt "visibility" VariablePresentationHint_visibility.enc)
         (opt "lazy" bool))

  let make ?kind ?attributes ?visibility ?lazy_ () =
    {kind; attributes; visibility; lazy_}

  let kind t = t.kind

  let attributes t = t.attributes

  let visibility t = t.visibility

  let lazy_ t = t.lazy_
end

module Variable_ : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    name:string ->
    value:string ->
    ?type_:string ->
    ?presentationHint:VariablePresentationHint.t ->
    ?evaluateName:string ->
    variablesReference:int ->
    ?namedVariables:int ->
    ?indexedVariables:int ->
    ?memoryReference:string ->
    unit ->
    t

  val name : t -> string

  val value : t -> string

  val type_ : t -> string option

  val presentationHint : t -> VariablePresentationHint.t option

  val evaluateName : t -> string option

  val variablesReference : t -> int

  val namedVariables : t -> int option

  val indexedVariables : t -> int option

  val memoryReference : t -> string option
end = struct
  type t = {
    name : (string[@gen gen_utf8_str]);
    value : (string[@gen gen_utf8_str]);
    type_ : (string option[@gen gen_utf8_str_opt]);
    presentationHint : VariablePresentationHint.t option;
    evaluateName : (string option[@gen gen_utf8_str_opt]);
    variablesReference : (int[@gen gen_int31]);
    namedVariables : (int option[@gen gen_int31_opt]);
    indexedVariables : (int option[@gen gen_int31_opt]);
    memoryReference : (string option[@gen gen_utf8_str_opt]);
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* Variable_.t *)
    conv
      (fun {
             name;
             value;
             type_;
             presentationHint;
             evaluateName;
             variablesReference;
             namedVariables;
             indexedVariables;
             memoryReference;
           } ->
        ( name,
          value,
          type_,
          presentationHint,
          evaluateName,
          variablesReference,
          namedVariables,
          indexedVariables,
          memoryReference ))
      (fun ( name,
             value,
             type_,
             presentationHint,
             evaluateName,
             variablesReference,
             namedVariables,
             indexedVariables,
             memoryReference ) ->
        {
          name;
          value;
          type_;
          presentationHint;
          evaluateName;
          variablesReference;
          namedVariables;
          indexedVariables;
          memoryReference;
        })
      (obj9
         (req "name" string)
         (req "value" string)
         (opt "type" string)
         (opt "presentationHint" VariablePresentationHint.enc)
         (opt "evaluateName" string)
         (req "variablesReference" int31)
         (opt "namedVariables" int31)
         (opt "indexedVariables" int31)
         (opt "memoryReference" string))

  let make ~name ~value ?type_ ?presentationHint ?evaluateName
      ~variablesReference ?namedVariables ?indexedVariables ?memoryReference ()
      =
    {
      name;
      value;
      type_;
      presentationHint;
      evaluateName;
      variablesReference;
      namedVariables;
      indexedVariables;
      memoryReference;
    }

  let name t = t.name

  let value t = t.value

  let type_ t = t.type_

  let presentationHint t = t.presentationHint

  let evaluateName t = t.evaluateName

  let variablesReference t = t.variablesReference

  let namedVariables t = t.namedVariables

  let indexedVariables t = t.indexedVariables

  let memoryReference t = t.memoryReference
end

module VariablesResponse_body : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : variables:Variable_.t list -> unit -> t

  val variables : t -> Variable_.t list
end = struct
  type t = {variables : Variable_.t list} [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* VariablesResponse_body.t *)
    conv
      (fun {variables} -> variables)
      (fun variables -> {variables})
      (obj1 (req "variables" (list Variable_.enc)))

  let make ~variables () = {variables}

  let variables t = t.variables
end

module SetVariableArguments : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    variablesReference:int ->
    name:string ->
    value:string ->
    ?format:ValueFormat.t ->
    unit ->
    t

  val variablesReference : t -> int

  val name : t -> string

  val value : t -> string

  val format : t -> ValueFormat.t option
end = struct
  type t = {
    variablesReference : (int[@gen gen_int31]);
    name : (string[@gen gen_utf8_str]);
    value : (string[@gen gen_utf8_str]);
    format : ValueFormat.t option;
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* SetVariableArguments.t *)
    conv
      (fun {variablesReference; name; value; format} ->
        (variablesReference, name, value, format))
      (fun (variablesReference, name, value, format) ->
        {variablesReference; name; value; format})
      (obj4
         (req "variablesReference" int31)
         (req "name" string)
         (req "value" string)
         (opt "format" ValueFormat.enc))

  let make ~variablesReference ~name ~value ?format () =
    {variablesReference; name; value; format}

  let variablesReference t = t.variablesReference

  let name t = t.name

  let value t = t.value

  let format t = t.format
end

module SetVariableResponse_body : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    value:string ->
    ?type_:string ->
    ?variablesReference:int ->
    ?namedVariables:int ->
    ?indexedVariables:int ->
    unit ->
    t

  val value : t -> string

  val type_ : t -> string option

  val variablesReference : t -> int option

  val namedVariables : t -> int option

  val indexedVariables : t -> int option
end = struct
  type t = {
    value : (string[@gen gen_utf8_str]);
    type_ : (string option[@gen gen_utf8_str_opt]);
    variablesReference : (int option[@gen gen_int31_opt]);
    namedVariables : (int option[@gen gen_int31_opt]);
    indexedVariables : (int option[@gen gen_int31_opt]);
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* SetVariableResponse_body.t *)
    conv
      (fun {value; type_; variablesReference; namedVariables; indexedVariables} ->
        (value, type_, variablesReference, namedVariables, indexedVariables))
      (fun (value, type_, variablesReference, namedVariables, indexedVariables) ->
        {value; type_; variablesReference; namedVariables; indexedVariables})
      (obj5
         (req "value" string)
         (opt "type" string)
         (opt "variablesReference" int31)
         (opt "namedVariables" int31)
         (opt "indexedVariables" int31))

  let make ~value ?type_ ?variablesReference ?namedVariables ?indexedVariables
      () =
    {value; type_; variablesReference; namedVariables; indexedVariables}

  let value t = t.value

  let type_ t = t.type_

  let variablesReference t = t.variablesReference

  let namedVariables t = t.namedVariables

  let indexedVariables t = t.indexedVariables
end

module SourceArguments : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : ?source:Source.t -> sourceReference:int -> unit -> t

  val source : t -> Source.t option

  val sourceReference : t -> int
end = struct
  type t = {source : Source.t option; sourceReference : int} [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* SourceArguments.t *)
    conv
      (fun {source; sourceReference} -> (source, sourceReference))
      (fun (source, sourceReference) -> {source; sourceReference})
      (obj2 (opt "source" Source.enc) (req "sourceReference" int31))

  let make ?source ~sourceReference () = {source; sourceReference}

  let source t = t.source

  let sourceReference t = t.sourceReference
end

module SourceResponse_body : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : content:string -> ?mimeType:string -> unit -> t

  val content : t -> string

  val mimeType : t -> string option
end = struct
  type t = {
    content : (string[@gen gen_utf8_str]);
    mimeType : (string option[@gen gen_utf8_str_opt]);
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* SourceResponse_body.t *)
    conv
      (fun {content; mimeType} -> (content, mimeType))
      (fun (content, mimeType) -> {content; mimeType})
      (obj2 (req "content" string) (opt "mimeType" string))

  let make ~content ?mimeType () = {content; mimeType}

  let content t = t.content

  let mimeType t = t.mimeType
end

module Thread : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : id:int -> name:string -> unit -> t

  val id : t -> int

  val name : t -> string
end = struct
  type t = {id : (int[@gen gen_int31]); name : (string[@gen gen_utf8_str])}
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* Thread.t *)
    conv
      (fun {id; name} -> (id, name))
      (fun (id, name) -> {id; name})
      (obj2 (req "id" int31) (req "name" string))

  let make ~id ~name () = {id; name}

  let id t = t.id

  let name t = t.name
end

module ThreadsResponse_body : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : threads:Thread.t list -> unit -> t

  val threads : t -> Thread.t list
end = struct
  type t = {threads : Thread.t list} [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* ThreadsResponse_body.t *)
    conv
      (fun {threads} -> threads)
      (fun threads -> {threads})
      (obj1 (req "threads" (list Thread.enc)))

  let make ~threads () = {threads}

  let threads t = t.threads
end

module TerminateThreadsArguments : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : ?threadIds:int list -> unit -> t

  val threadIds : t -> int list option
end = struct
  type t = {threadIds : (int list option[@gen gen_int31_list_opt])}
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* TerminateThreadsArguments.t *)
    conv
      (fun {threadIds} -> threadIds)
      (fun threadIds -> {threadIds})
      (obj1 (opt "threadIds" (list int31)))

  let make ?threadIds () = {threadIds}

  let threadIds t = t.threadIds
end

module ModulesArguments : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : ?startModule:int -> ?moduleCount:int -> unit -> t

  val startModule : t -> int option

  val moduleCount : t -> int option
end = struct
  type t = {
    startModule : (int option[@gen gen_int31_opt]);
    moduleCount : (int option[@gen gen_int31_opt]);
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* ModulesArguments.t *)
    conv
      (fun {startModule; moduleCount} -> (startModule, moduleCount))
      (fun (startModule, moduleCount) -> {startModule; moduleCount})
      (obj2 (opt "startModule" int31) (opt "moduleCount" int31))

  let make ?startModule ?moduleCount () = {startModule; moduleCount}

  let startModule t = t.startModule

  let moduleCount t = t.moduleCount
end

module ModulesResponse_body : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : modules:Module_.t list -> ?totalModules:int -> unit -> t

  val modules : t -> Module_.t list

  val totalModules : t -> int option
end = struct
  type t = {
    modules : Module_.t list;
    totalModules : (int option[@gen gen_int31_opt]);
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* ModulesResponse_body.t *)
    conv
      (fun {modules; totalModules} -> (modules, totalModules))
      (fun (modules, totalModules) -> {modules; totalModules})
      (obj2 (req "modules" (list Module_.enc)) (opt "totalModules" int31))

  let make ~modules ?totalModules () = {modules; totalModules}

  let modules t = t.modules

  let totalModules t = t.totalModules
end

module LoadedSourcesArguments : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : unit -> t
end = struct
  type t = unit [@@deriving qcheck]

  let enc = Data_encoding.empty

  let make () = ()
end

module LoadedSourcesResponse_body : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : sources:Source.t list -> unit -> t

  val sources : t -> Source.t list
end = struct
  type t = {sources : Source.t list} [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* LoadedSourcesResponse_body.t *)
    conv
      (fun {sources} -> sources)
      (fun sources -> {sources})
      (obj1 (req "sources" (list Source.enc)))

  let make ~sources () = {sources}

  let sources t = t.sources
end

(* dont bother with a sig for enums, the inferred one is fine *)
module EvaluateArguments_context = struct
  type t = Variables | Watch | Repl | Hover | Clipboard | Other of (string [@gen gen_utf8_str])
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    conv_with_guard
      (function
        | Variables -> "variables"
        | Watch -> "watch"
        | Repl -> "repl"
        | Hover -> "hover"
        | Clipboard -> "clipboard"
        | Other s -> s)
      (function
        | "variables" -> Ok Variables
        | "watch" -> Ok Watch
        | "repl" -> Ok Repl
        | "hover" -> Ok Hover
        | "clipboard" -> Ok Clipboard
        | _ as s -> Ok (Other s))
      string
end

module EvaluateArguments : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    expression:string ->
    ?frameId:int ->
    ?context:EvaluateArguments_context.t ->
    ?format:ValueFormat.t ->
    unit ->
    t

  val expression : t -> string

  val frameId : t -> int option

  val context : t -> EvaluateArguments_context.t option

  val format : t -> ValueFormat.t option
end = struct
  type t = {
    expression : (string[@gen gen_utf8_str]);
    frameId : (int option[@gen gen_int31_opt]);
    context : EvaluateArguments_context.t option;
    format : ValueFormat.t option;
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* EvaluateArguments.t *)
    conv
      (fun {expression; frameId; context; format} ->
        (expression, frameId, context, format))
      (fun (expression, frameId, context, format) ->
        {expression; frameId; context; format})
      (obj4
         (req "expression" string)
         (opt "frameId" int31)
         (opt "context" EvaluateArguments_context.enc)
         (opt "format" ValueFormat.enc))

  let make ~expression ?frameId ?context ?format () =
    {expression; frameId; context; format}

  let expression t = t.expression

  let frameId t = t.frameId

  let context t = t.context

  let format t = t.format
end

module EvaluateResponse_body : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    result:string ->
    ?type_:string ->
    ?presentationHint:VariablePresentationHint.t ->
    variablesReference:int ->
    ?namedVariables:int ->
    ?indexedVariables:int ->
    ?memoryReference:string ->
    unit ->
    t

  val result : t -> string

  val type_ : t -> string option

  val presentationHint : t -> VariablePresentationHint.t option

  val variablesReference : t -> int

  val namedVariables : t -> int option

  val indexedVariables : t -> int option

  val memoryReference : t -> string option
end = struct
  type t = {
    result : (string[@gen gen_utf8_str]);
    type_ : (string option[@gen gen_utf8_str_opt]);
    presentationHint : VariablePresentationHint.t option;
    variablesReference : (int[@gen gen_int31]);
    namedVariables : (int option[@gen gen_int31_opt]);
    indexedVariables : (int option[@gen gen_int31_opt]);
    memoryReference : (string option[@gen gen_utf8_str_opt]);
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* EvaluateResponse_body.t *)
    conv
      (fun {
             result;
             type_;
             presentationHint;
             variablesReference;
             namedVariables;
             indexedVariables;
             memoryReference;
           } ->
        ( result,
          type_,
          presentationHint,
          variablesReference,
          namedVariables,
          indexedVariables,
          memoryReference ))
      (fun ( result,
             type_,
             presentationHint,
             variablesReference,
             namedVariables,
             indexedVariables,
             memoryReference ) ->
        {
          result;
          type_;
          presentationHint;
          variablesReference;
          namedVariables;
          indexedVariables;
          memoryReference;
        })
      (obj7
         (req "result" string)
         (opt "type" string)
         (opt "presentationHint" VariablePresentationHint.enc)
         (req "variablesReference" int31)
         (opt "namedVariables" int31)
         (opt "indexedVariables" int31)
         (opt "memoryReference" string))

  let make ~result ?type_ ?presentationHint ~variablesReference ?namedVariables
      ?indexedVariables ?memoryReference () =
    {
      result;
      type_;
      presentationHint;
      variablesReference;
      namedVariables;
      indexedVariables;
      memoryReference;
    }

  let result t = t.result

  let type_ t = t.type_

  let presentationHint t = t.presentationHint

  let variablesReference t = t.variablesReference

  let namedVariables t = t.namedVariables

  let indexedVariables t = t.indexedVariables

  let memoryReference t = t.memoryReference
end

module SetExpressionArguments : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    expression:string ->
    value:string ->
    ?frameId:int ->
    ?format:ValueFormat.t ->
    unit ->
    t

  val expression : t -> string

  val value : t -> string

  val frameId : t -> int option

  val format : t -> ValueFormat.t option
end = struct
  type t = {
    expression : (string[@gen gen_utf8_str]);
    value : (string[@gen gen_utf8_str]);
    frameId : (int option[@gen gen_int31_opt]);
    format : ValueFormat.t option;
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* SetExpressionArguments.t *)
    conv
      (fun {expression; value; frameId; format} ->
        (expression, value, frameId, format))
      (fun (expression, value, frameId, format) ->
        {expression; value; frameId; format})
      (obj4
         (req "expression" string)
         (req "value" string)
         (opt "frameId" int31)
         (opt "format" ValueFormat.enc))

  let make ~expression ~value ?frameId ?format () =
    {expression; value; frameId; format}

  let expression t = t.expression

  let value t = t.value

  let frameId t = t.frameId

  let format t = t.format
end

module SetExpressionResponse_body : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    value:string ->
    ?type_:string ->
    ?presentationHint:VariablePresentationHint.t ->
    ?variablesReference:int ->
    ?namedVariables:int ->
    ?indexedVariables:int ->
    unit ->
    t

  val value : t -> string

  val type_ : t -> string option

  val presentationHint : t -> VariablePresentationHint.t option

  val variablesReference : t -> int option

  val namedVariables : t -> int option

  val indexedVariables : t -> int option
end = struct
  type t = {
    value : (string[@gen gen_utf8_str]);
    type_ : (string option[@gen gen_utf8_str_opt]);
    presentationHint : VariablePresentationHint.t option;
    variablesReference : (int option[@gen gen_int31_opt]);
    namedVariables : (int option[@gen gen_int31_opt]);
    indexedVariables : (int option[@gen gen_int31_opt]);
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* SetExpressionResponse_body.t *)
    conv
      (fun {
             value;
             type_;
             presentationHint;
             variablesReference;
             namedVariables;
             indexedVariables;
           } ->
        ( value,
          type_,
          presentationHint,
          variablesReference,
          namedVariables,
          indexedVariables ))
      (fun ( value,
             type_,
             presentationHint,
             variablesReference,
             namedVariables,
             indexedVariables ) ->
        {
          value;
          type_;
          presentationHint;
          variablesReference;
          namedVariables;
          indexedVariables;
        })
      (obj6
         (req "value" string)
         (opt "type" string)
         (opt "presentationHint" VariablePresentationHint.enc)
         (opt "variablesReference" int31)
         (opt "namedVariables" int31)
         (opt "indexedVariables" int31))

  let make ~value ?type_ ?presentationHint ?variablesReference ?namedVariables
      ?indexedVariables () =
    {
      value;
      type_;
      presentationHint;
      variablesReference;
      namedVariables;
      indexedVariables;
    }

  let value t = t.value

  let type_ t = t.type_

  let presentationHint t = t.presentationHint

  let variablesReference t = t.variablesReference

  let namedVariables t = t.namedVariables

  let indexedVariables t = t.indexedVariables
end

module StepInTargetsArguments : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : frameId:int -> unit -> t

  val frameId : t -> int
end = struct
  type t = {frameId : int} [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* StepInTargetsArguments.t *)
    conv
      (fun {frameId} -> frameId)
      (fun frameId -> {frameId})
      (obj1 (req "frameId" int31))

  let make ~frameId () = {frameId}

  let frameId t = t.frameId
end

module StepInTarget : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    id:int ->
    label:string ->
    ?line:int ->
    ?column:int ->
    ?endLine:int ->
    ?endColumn:int ->
    unit ->
    t

  val id : t -> int

  val label : t -> string

  val line : t -> int option

  val column : t -> int option

  val endLine : t -> int option

  val endColumn : t -> int option
end = struct
  type t = {
    id : (int[@gen gen_int31]);
    label : (string[@gen gen_utf8_str]);
    line : (int option[@gen gen_int31_opt]);
    column : (int option[@gen gen_int31_opt]);
    endLine : (int option[@gen gen_int31_opt]);
    endColumn : (int option[@gen gen_int31_opt]);
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* StepInTarget.t *)
    conv
      (fun {id; label; line; column; endLine; endColumn} ->
        (id, label, line, column, endLine, endColumn))
      (fun (id, label, line, column, endLine, endColumn) ->
        {id; label; line; column; endLine; endColumn})
      (obj6
         (req "id" int31)
         (req "label" string)
         (opt "line" int31)
         (opt "column" int31)
         (opt "endLine" int31)
         (opt "endColumn" int31))

  let make ~id ~label ?line ?column ?endLine ?endColumn () =
    {id; label; line; column; endLine; endColumn}

  let id t = t.id

  let label t = t.label

  let line t = t.line

  let column t = t.column

  let endLine t = t.endLine

  let endColumn t = t.endColumn
end

module StepInTargetsResponse_body : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : targets:StepInTarget.t list -> unit -> t

  val targets : t -> StepInTarget.t list
end = struct
  type t = {targets : StepInTarget.t list} [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* StepInTargetsResponse_body.t *)
    conv
      (fun {targets} -> targets)
      (fun targets -> {targets})
      (obj1 (req "targets" (list StepInTarget.enc)))

  let make ~targets () = {targets}

  let targets t = t.targets
end

module GotoTargetsArguments : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : source:Source.t -> line:int -> ?column:int -> unit -> t

  val source : t -> Source.t

  val line : t -> int

  val column : t -> int option
end = struct
  type t = {
    source : Source.t;
    line : (int[@gen gen_int31]);
    column : (int option[@gen gen_int31_opt]);
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* GotoTargetsArguments.t *)
    conv
      (fun {source; line; column} -> (source, line, column))
      (fun (source, line, column) -> {source; line; column})
      (obj3 (req "source" Source.enc) (req "line" int31) (opt "column" int31))

  let make ~source ~line ?column () = {source; line; column}

  let source t = t.source

  let line t = t.line

  let column t = t.column
end

module GotoTarget : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    id:int ->
    label:string ->
    line:int ->
    ?column:int ->
    ?endLine:int ->
    ?endColumn:int ->
    ?instructionPointerReference:string ->
    unit ->
    t

  val id : t -> int

  val label : t -> string

  val line : t -> int

  val column : t -> int option

  val endLine : t -> int option

  val endColumn : t -> int option

  val instructionPointerReference : t -> string option
end = struct
  type t = {
    id : (int[@gen gen_int31]);
    label : (string[@gen gen_utf8_str]);
    line : (int[@gen gen_int31]);
    column : (int option[@gen gen_int31_opt]);
    endLine : (int option[@gen gen_int31_opt]);
    endColumn : (int option[@gen gen_int31_opt]);
    instructionPointerReference : (string option[@gen gen_utf8_str_opt]);
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* GotoTarget.t *)
    conv
      (fun {
             id;
             label;
             line;
             column;
             endLine;
             endColumn;
             instructionPointerReference;
           } ->
        ( id,
          label,
          line,
          column,
          endLine,
          endColumn,
          instructionPointerReference ))
      (fun ( id,
             label,
             line,
             column,
             endLine,
             endColumn,
             instructionPointerReference ) ->
        {
          id;
          label;
          line;
          column;
          endLine;
          endColumn;
          instructionPointerReference;
        })
      (obj7
         (req "id" int31)
         (req "label" string)
         (req "line" int31)
         (opt "column" int31)
         (opt "endLine" int31)
         (opt "endColumn" int31)
         (opt "instructionPointerReference" string))

  let make ~id ~label ~line ?column ?endLine ?endColumn
      ?instructionPointerReference () =
    {id; label; line; column; endLine; endColumn; instructionPointerReference}

  let id t = t.id

  let label t = t.label

  let line t = t.line

  let column t = t.column

  let endLine t = t.endLine

  let endColumn t = t.endColumn

  let instructionPointerReference t = t.instructionPointerReference
end

module GotoTargetsResponse_body : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : targets:GotoTarget.t list -> unit -> t

  val targets : t -> GotoTarget.t list
end = struct
  type t = {targets : GotoTarget.t list} [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* GotoTargetsResponse_body.t *)
    conv
      (fun {targets} -> targets)
      (fun targets -> {targets})
      (obj1 (req "targets" (list GotoTarget.enc)))

  let make ~targets () = {targets}

  let targets t = t.targets
end

module CompletionsArguments : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : ?frameId:int -> text:string -> column:int -> ?line:int -> unit -> t

  val frameId : t -> int option

  val text : t -> string

  val column : t -> int

  val line : t -> int option
end = struct
  type t = {
    frameId : (int option[@gen gen_int31_opt]);
    text : (string[@gen gen_utf8_str]);
    column : (int[@gen gen_int31]);
    line : (int option[@gen gen_int31_opt]);
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* CompletionsArguments.t *)
    conv
      (fun {frameId; text; column; line} -> (frameId, text, column, line))
      (fun (frameId, text, column, line) -> {frameId; text; column; line})
      (obj4
         (opt "frameId" int31)
         (req "text" string)
         (req "column" int31)
         (opt "line" int31))

  let make ?frameId ~text ~column ?line () = {frameId; text; column; line}

  let frameId t = t.frameId

  let text t = t.text

  let column t = t.column

  let line t = t.line
end

(* dont bother with a sig for enums, the inferred one is fine *)
module CompletionItemType = struct
  type t =
    | Method
    | Function
    | Constructor
    | Field
    | Variable_
    | Class
    | Interface
    | Module_
    | Property
    | Unit
    | Value
    | Enum
    | Keyword
    | Snippet
    | Text
    | Color
    | File
    | Reference
    | Customcolor
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    conv_with_guard
      (function
        | Method -> "method"
        | Function -> "function"
        | Constructor -> "constructor"
        | Field -> "field"
        | Variable_ -> "variable"
        | Class -> "class"
        | Interface -> "interface"
        | Module_ -> "module"
        | Property -> "property"
        | Unit -> "unit"
        | Value -> "value"
        | Enum -> "enum"
        | Keyword -> "keyword"
        | Snippet -> "snippet"
        | Text -> "text"
        | Color -> "color"
        | File -> "file"
        | Reference -> "reference"
        | Customcolor -> "customcolor")
      (function
        | "method" -> Ok Method
        | "function" -> Ok Function
        | "constructor" -> Ok Constructor
        | "field" -> Ok Field
        | "variable" -> Ok Variable_
        | "class" -> Ok Class
        | "interface" -> Ok Interface
        | "module" -> Ok Module_
        | "property" -> Ok Property
        | "unit" -> Ok Unit
        | "value" -> Ok Value
        | "enum" -> Ok Enum
        | "keyword" -> Ok Keyword
        | "snippet" -> Ok Snippet
        | "text" -> Ok Text
        | "color" -> Ok Color
        | "file" -> Ok File
        | "reference" -> Ok Reference
        | "customcolor" -> Ok Customcolor
        | _ -> Error "CompletionItemType")
      string
end

module CompletionItem : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    label:string ->
    ?text:string ->
    ?sortText:string ->
    ?detail:string ->
    ?type_:CompletionItemType.t ->
    ?start:int ->
    ?length:int ->
    ?selectionStart:int ->
    ?selectionLength:int ->
    unit ->
    t

  val label : t -> string

  val text : t -> string option

  val sortText : t -> string option

  val detail : t -> string option

  val type_ : t -> CompletionItemType.t option

  val start : t -> int option

  val length : t -> int option

  val selectionStart : t -> int option

  val selectionLength : t -> int option
end = struct
  type t = {
    label : (string[@gen gen_utf8_str]);
    text : (string option[@gen gen_utf8_str_opt]);
    sortText : (string option[@gen gen_utf8_str_opt]);
    detail : (string option[@gen gen_utf8_str_opt]);
    type_ : CompletionItemType.t option;
    start : (int option[@gen gen_int31_opt]);
    length : (int option[@gen gen_int31_opt]);
    selectionStart : (int option[@gen gen_int31_opt]);
    selectionLength : (int option[@gen gen_int31_opt]);
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* CompletionItem.t *)
    conv
      (fun {
             label;
             text;
             sortText;
             detail;
             type_;
             start;
             length;
             selectionStart;
             selectionLength;
           } ->
        ( label,
          text,
          sortText,
          detail,
          type_,
          start,
          length,
          selectionStart,
          selectionLength ))
      (fun ( label,
             text,
             sortText,
             detail,
             type_,
             start,
             length,
             selectionStart,
             selectionLength ) ->
        {
          label;
          text;
          sortText;
          detail;
          type_;
          start;
          length;
          selectionStart;
          selectionLength;
        })
      (obj9
         (req "label" string)
         (opt "text" string)
         (opt "sortText" string)
         (opt "detail" string)
         (opt "type" CompletionItemType.enc)
         (opt "start" int31)
         (opt "length" int31)
         (opt "selectionStart" int31)
         (opt "selectionLength" int31))

  let make ~label ?text ?sortText ?detail ?type_ ?start ?length ?selectionStart
      ?selectionLength () =
    {
      label;
      text;
      sortText;
      detail;
      type_;
      start;
      length;
      selectionStart;
      selectionLength;
    }

  let label t = t.label

  let text t = t.text

  let sortText t = t.sortText

  let detail t = t.detail

  let type_ t = t.type_

  let start t = t.start

  let length t = t.length

  let selectionStart t = t.selectionStart

  let selectionLength t = t.selectionLength
end

module CompletionsResponse_body : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : targets:CompletionItem.t list -> unit -> t

  val targets : t -> CompletionItem.t list
end = struct
  type t = {targets : CompletionItem.t list} [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* CompletionsResponse_body.t *)
    conv
      (fun {targets} -> targets)
      (fun targets -> {targets})
      (obj1 (req "targets" (list CompletionItem.enc)))

  let make ~targets () = {targets}

  let targets t = t.targets
end

module ExceptionInfoArguments : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : threadId:int -> unit -> t

  val threadId : t -> int
end = struct
  type t = {threadId : int} [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* ExceptionInfoArguments.t *)
    conv
      (fun {threadId} -> threadId)
      (fun threadId -> {threadId})
      (obj1 (req "threadId" int31))

  let make ~threadId () = {threadId}

  let threadId t = t.threadId
end

module ExceptionDetails : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    ?message:string ->
    ?typeName:string ->
    ?fullTypeName:string ->
    ?evaluateName:string ->
    ?stackTrace:string ->
    ?innerException:t list ->
    unit ->
    t

  val message : t -> string option

  val typeName : t -> string option

  val fullTypeName : t -> string option

  val evaluateName : t -> string option

  val stackTrace : t -> string option

  val innerException : t -> t list option
end = struct
  type t = {
    message : (string option[@gen gen_utf8_str_opt]);
    typeName : (string option[@gen gen_utf8_str_opt]);
    fullTypeName : (string option[@gen gen_utf8_str_opt]);
    evaluateName : (string option[@gen gen_utf8_str_opt]);
    stackTrace : (string option[@gen gen_utf8_str_opt]);
    innerException : (t list option[@gen QCheck.Gen.(pure None)]);
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    mu "ExceptionDetails.t" (fun e ->
        conv
          (fun {
                 message;
                 typeName;
                 fullTypeName;
                 evaluateName;
                 stackTrace;
                 innerException;
               } ->
            ( message,
              typeName,
              fullTypeName,
              evaluateName,
              stackTrace,
              innerException ))
          (fun ( message,
                 typeName,
                 fullTypeName,
                 evaluateName,
                 stackTrace,
                 innerException ) ->
            {
              message;
              typeName;
              fullTypeName;
              evaluateName;
              stackTrace;
              innerException;
            })
          (obj6
             (opt "message" string)
             (opt "typeName" string)
             (opt "fullTypeName" string)
             (opt "evaluateName" string)
             (opt "stackTrace" string)
             (opt "innerException" (list e))))

  let make ?message ?typeName ?fullTypeName ?evaluateName ?stackTrace
      ?innerException () =
    {message; typeName; fullTypeName; evaluateName; stackTrace; innerException}

  let message t = t.message

  let typeName t = t.typeName

  let fullTypeName t = t.fullTypeName

  let evaluateName t = t.evaluateName

  let stackTrace t = t.stackTrace

  let innerException t = t.innerException
end

module ExceptionInfoResponse_body : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    exceptionId:string ->
    ?description:string ->
    breakMode:ExceptionBreakMode.t ->
    ?details:ExceptionDetails.t ->
    unit ->
    t

  val exceptionId : t -> string

  val description : t -> string option

  val breakMode : t -> ExceptionBreakMode.t

  val details : t -> ExceptionDetails.t option
end = struct
  type t = {
    exceptionId : (string[@gen gen_utf8_str]);
    description : (string option[@gen gen_utf8_str_opt]);
    breakMode : ExceptionBreakMode.t;
    details : ExceptionDetails.t option;
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* ExceptionInfoResponse_body.t *)
    conv
      (fun {exceptionId; description; breakMode; details} ->
        (exceptionId, description, breakMode, details))
      (fun (exceptionId, description, breakMode, details) ->
        {exceptionId; description; breakMode; details})
      (obj4
         (req "exceptionId" string)
         (opt "description" string)
         (req "breakMode" ExceptionBreakMode.enc)
         (opt "details" ExceptionDetails.enc))

  let make ~exceptionId ?description ~breakMode ?details () =
    {exceptionId; description; breakMode; details}

  let exceptionId t = t.exceptionId

  let description t = t.description

  let breakMode t = t.breakMode

  let details t = t.details
end

module ReadMemoryArguments : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : memoryReference:string -> ?offset:int -> count:int -> unit -> t

  val memoryReference : t -> string

  val offset : t -> int option

  val count : t -> int
end = struct
  type t = {
    memoryReference : (string[@gen gen_utf8_str]);
    offset : (int option[@gen gen_int31_opt]);
    count : (int[@gen gen_int31]);
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* ReadMemoryArguments.t *)
    conv
      (fun {memoryReference; offset; count} -> (memoryReference, offset, count))
      (fun (memoryReference, offset, count) -> {memoryReference; offset; count})
      (obj3
         (req "memoryReference" string)
         (opt "offset" int31)
         (req "count" int31))

  let make ~memoryReference ?offset ~count () = {memoryReference; offset; count}

  let memoryReference t = t.memoryReference

  let offset t = t.offset

  let count t = t.count
end

module ReadMemoryResponse_body : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : address:string -> ?unreadableBytes:int -> ?data:string -> unit -> t

  val address : t -> string

  val unreadableBytes : t -> int option

  val data : t -> string option
end = struct
  type t = {
    address : (string[@gen gen_utf8_str]);
    unreadableBytes : (int option[@gen gen_int31_opt]);
    data : (string option[@gen gen_utf8_str_opt]);
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* ReadMemoryResponse_body.t *)
    conv
      (fun {address; unreadableBytes; data} -> (address, unreadableBytes, data))
      (fun (address, unreadableBytes, data) -> {address; unreadableBytes; data})
      (obj3
         (req "address" string)
         (opt "unreadableBytes" int31)
         (opt "data" string))

  let make ~address ?unreadableBytes ?data () = {address; unreadableBytes; data}

  let address t = t.address

  let unreadableBytes t = t.unreadableBytes

  let data t = t.data
end

module WriteMemoryArguments : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    memoryReference:string ->
    ?offset:int ->
    ?allowPartial:bool ->
    data:string ->
    unit ->
    t

  val memoryReference : t -> string

  val offset : t -> int option

  val allowPartial : t -> bool option

  val data : t -> string
end = struct
  type t = {
    memoryReference : (string[@gen gen_utf8_str]);
    offset : (int option[@gen gen_int31_opt]);
    allowPartial : bool option;
    data : (string[@gen gen_utf8_str]);
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* WriteMemoryArguments.t *)
    conv
      (fun {memoryReference; offset; allowPartial; data} ->
        (memoryReference, offset, allowPartial, data))
      (fun (memoryReference, offset, allowPartial, data) ->
        {memoryReference; offset; allowPartial; data})
      (obj4
         (req "memoryReference" string)
         (opt "offset" int31)
         (opt "allowPartial" bool)
         (req "data" string))

  let make ~memoryReference ?offset ?allowPartial ~data () =
    {memoryReference; offset; allowPartial; data}

  let memoryReference t = t.memoryReference

  let offset t = t.offset

  let allowPartial t = t.allowPartial

  let data t = t.data
end

module WriteMemoryResponse_body : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : ?offset:int -> ?bytesWritten:int -> unit -> t

  val offset : t -> int option

  val bytesWritten : t -> int option
end = struct
  type t = {
    offset : (int option[@gen gen_int31_opt]);
    bytesWritten : (int option[@gen gen_int31_opt]);
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* WriteMemoryResponse_body.t *)
    conv
      (fun {offset; bytesWritten} -> (offset, bytesWritten))
      (fun (offset, bytesWritten) -> {offset; bytesWritten})
      (obj2 (opt "offset" int31) (opt "bytesWritten" int31))

  let make ?offset ?bytesWritten () = {offset; bytesWritten}

  let offset t = t.offset

  let bytesWritten t = t.bytesWritten
end

module DisassembleArguments : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    memoryReference:string ->
    ?offset:int ->
    ?instructionOffset:int ->
    instructionCount:int ->
    ?resolveSymbols:bool ->
    unit ->
    t

  val memoryReference : t -> string

  val offset : t -> int option

  val instructionOffset : t -> int option

  val instructionCount : t -> int

  val resolveSymbols : t -> bool option
end = struct
  type t = {
    memoryReference : (string[@gen gen_utf8_str]);
    offset : (int option[@gen gen_int31_opt]);
    instructionOffset : (int option[@gen gen_int31_opt]);
    instructionCount : (int[@gen gen_int31]);
    resolveSymbols : bool option;
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* DisassembleArguments.t *)
    conv
      (fun {
             memoryReference;
             offset;
             instructionOffset;
             instructionCount;
             resolveSymbols;
           } ->
        ( memoryReference,
          offset,
          instructionOffset,
          instructionCount,
          resolveSymbols ))
      (fun ( memoryReference,
             offset,
             instructionOffset,
             instructionCount,
             resolveSymbols ) ->
        {
          memoryReference;
          offset;
          instructionOffset;
          instructionCount;
          resolveSymbols;
        })
      (obj5
         (req "memoryReference" string)
         (opt "offset" int31)
         (opt "instructionOffset" int31)
         (req "instructionCount" int31)
         (opt "resolveSymbols" bool))

  let make ~memoryReference ?offset ?instructionOffset ~instructionCount
      ?resolveSymbols () =
    {
      memoryReference;
      offset;
      instructionOffset;
      instructionCount;
      resolveSymbols;
    }

  let memoryReference t = t.memoryReference

  let offset t = t.offset

  let instructionOffset t = t.instructionOffset

  let instructionCount t = t.instructionCount

  let resolveSymbols t = t.resolveSymbols
end

module DisassembledInstruction : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make :
    address:string ->
    ?instructionBytes:string ->
    instruction:string ->
    ?symbol:string ->
    ?location:Source.t ->
    ?line:int ->
    ?column:int ->
    ?endLine:int ->
    ?endColumn:int ->
    unit ->
    t

  val address : t -> string

  val instructionBytes : t -> string option

  val instruction : t -> string

  val symbol : t -> string option

  val location : t -> Source.t option

  val line : t -> int option

  val column : t -> int option

  val endLine : t -> int option

  val endColumn : t -> int option
end = struct
  type t = {
    address : (string[@gen gen_utf8_str]);
    instructionBytes : (string option[@gen gen_utf8_str_opt]);
    instruction : (string[@gen gen_utf8_str]);
    symbol : (string option[@gen gen_utf8_str_opt]);
    location : Source.t option;
    line : (int option[@gen gen_int31_opt]);
    column : (int option[@gen gen_int31_opt]);
    endLine : (int option[@gen gen_int31_opt]);
    endColumn : (int option[@gen gen_int31_opt]);
  }
  [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* DisassembledInstruction.t *)
    conv
      (fun {
             address;
             instructionBytes;
             instruction;
             symbol;
             location;
             line;
             column;
             endLine;
             endColumn;
           } ->
        ( address,
          instructionBytes,
          instruction,
          symbol,
          location,
          line,
          column,
          endLine,
          endColumn ))
      (fun ( address,
             instructionBytes,
             instruction,
             symbol,
             location,
             line,
             column,
             endLine,
             endColumn ) ->
        {
          address;
          instructionBytes;
          instruction;
          symbol;
          location;
          line;
          column;
          endLine;
          endColumn;
        })
      (obj9
         (req "address" string)
         (opt "instructionBytes" string)
         (req "instruction" string)
         (opt "symbol" string)
         (opt "location" Source.enc)
         (opt "line" int31)
         (opt "column" int31)
         (opt "endLine" int31)
         (opt "endColumn" int31))

  let make ~address ?instructionBytes ~instruction ?symbol ?location ?line
      ?column ?endLine ?endColumn () =
    {
      address;
      instructionBytes;
      instruction;
      symbol;
      location;
      line;
      column;
      endLine;
      endColumn;
    }

  let address t = t.address

  let instructionBytes t = t.instructionBytes

  let instruction t = t.instruction

  let symbol t = t.symbol

  let location t = t.location

  let line t = t.line

  let column t = t.column

  let endLine t = t.endLine

  let endColumn t = t.endColumn
end

module DisassembleResponse_body : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : instructions:DisassembledInstruction.t list -> unit -> t

  val instructions : t -> DisassembledInstruction.t list
end = struct
  type t = {instructions : DisassembledInstruction.t list} [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* DisassembleResponse_body.t *)
    conv
      (fun {instructions} -> instructions)
      (fun instructions -> {instructions})
      (obj1 (req "instructions" (list DisassembledInstruction.enc)))

  let make ~instructions () = {instructions}

  let instructions t = t.instructions
end

module ModulesViewDescriptor : sig
  type t

  val enc : t Data_encoding.t

  val gen : t QCheck.Gen.t

  val make : columns:ColumnDescriptor.t list -> unit -> t

  val columns : t -> ColumnDescriptor.t list
end = struct
  type t = {columns : ColumnDescriptor.t list} [@@deriving qcheck]

  let enc =
    let open Data_encoding in
    (* ModulesViewDescriptor.t *)
    conv
      (fun {columns} -> columns)
      (fun columns -> {columns})
      (obj1 (req "columns" (list ColumnDescriptor.enc)))

  let make ~columns () = {columns}

  let columns t = t.columns
end

type (_, _, _) request =
  | CancelRequest :
      ( Dap_commands.cancel,
        CancelArguments.t option,
        RequestMessage.opt )
      RequestMessage.t
      -> ( Dap_commands.cancel,
           CancelArguments.t option,
           RequestMessage.opt )
         request
  | RunInTerminalRequest :
      ( Dap_commands.runInTerminal,
        RunInTerminalRequestArguments.t,
        RequestMessage.req )
      RequestMessage.t
      -> ( Dap_commands.runInTerminal,
           RunInTerminalRequestArguments.t,
           RequestMessage.req )
         request
  | InitializeRequest :
      ( Dap_commands.initialize,
        InitializeRequestArguments.t,
        RequestMessage.req )
      RequestMessage.t
      -> ( Dap_commands.initialize,
           InitializeRequestArguments.t,
           RequestMessage.req )
         request
  | ConfigurationDoneRequest :
      ( Dap_commands.configurationDone,
        ConfigurationDoneArguments.t option,
        RequestMessage.opt )
      RequestMessage.t
      -> ( Dap_commands.configurationDone,
           ConfigurationDoneArguments.t option,
           RequestMessage.opt )
         request
  | LaunchRequest :
      ( Dap_commands.launch,
        LaunchRequestArguments.t,
        RequestMessage.req )
      RequestMessage.t
      -> ( Dap_commands.launch,
           LaunchRequestArguments.t,
           RequestMessage.req )
         request
  | AttachRequest :
      ( Dap_commands.attach,
        AttachRequestArguments.t,
        RequestMessage.req )
      RequestMessage.t
      -> ( Dap_commands.attach,
           AttachRequestArguments.t,
           RequestMessage.req )
         request
  | RestartRequest :
      ( Dap_commands.restart,
        RestartArguments.t option,
        RequestMessage.opt )
      RequestMessage.t
      -> ( Dap_commands.restart,
           RestartArguments.t option,
           RequestMessage.opt )
         request
  | DisconnectRequest :
      ( Dap_commands.disconnect,
        DisconnectArguments.t option,
        RequestMessage.opt )
      RequestMessage.t
      -> ( Dap_commands.disconnect,
           DisconnectArguments.t option,
           RequestMessage.opt )
         request
  | TerminateRequest :
      ( Dap_commands.terminate,
        TerminateArguments.t option,
        RequestMessage.opt )
      RequestMessage.t
      -> ( Dap_commands.terminate,
           TerminateArguments.t option,
           RequestMessage.opt )
         request
  | BreakpointLocationsRequest :
      ( Dap_commands.breakpointLocations,
        BreakpointLocationsArguments.t option,
        RequestMessage.opt )
      RequestMessage.t
      -> ( Dap_commands.breakpointLocations,
           BreakpointLocationsArguments.t option,
           RequestMessage.opt )
         request
  | SetBreakpointsRequest :
      ( Dap_commands.setBreakpoints,
        SetBreakpointsArguments.t,
        RequestMessage.req )
      RequestMessage.t
      -> ( Dap_commands.setBreakpoints,
           SetBreakpointsArguments.t,
           RequestMessage.req )
         request
  | SetFunctionBreakpointsRequest :
      ( Dap_commands.setFunctionBreakpoints,
        SetFunctionBreakpointsArguments.t,
        RequestMessage.req )
      RequestMessage.t
      -> ( Dap_commands.setFunctionBreakpoints,
           SetFunctionBreakpointsArguments.t,
           RequestMessage.req )
         request
  | SetExceptionBreakpointsRequest :
      ( Dap_commands.setExceptionBreakpoints,
        SetExceptionBreakpointsArguments.t,
        RequestMessage.req )
      RequestMessage.t
      -> ( Dap_commands.setExceptionBreakpoints,
           SetExceptionBreakpointsArguments.t,
           RequestMessage.req )
         request
  | DataBreakpointInfoRequest :
      ( Dap_commands.dataBreakpointInfo,
        DataBreakpointInfoArguments.t,
        RequestMessage.req )
      RequestMessage.t
      -> ( Dap_commands.dataBreakpointInfo,
           DataBreakpointInfoArguments.t,
           RequestMessage.req )
         request
  | SetDataBreakpointsRequest :
      ( Dap_commands.setDataBreakpoints,
        SetDataBreakpointsArguments.t,
        RequestMessage.req )
      RequestMessage.t
      -> ( Dap_commands.setDataBreakpoints,
           SetDataBreakpointsArguments.t,
           RequestMessage.req )
         request
  | SetInstructionBreakpointsRequest :
      ( Dap_commands.setInstructionBreakpoints,
        SetInstructionBreakpointsArguments.t,
        RequestMessage.req )
      RequestMessage.t
      -> ( Dap_commands.setInstructionBreakpoints,
           SetInstructionBreakpointsArguments.t,
           RequestMessage.req )
         request
  | ContinueRequest :
      ( Dap_commands.continue,
        ContinueArguments.t,
        RequestMessage.req )
      RequestMessage.t
      -> ( Dap_commands.continue,
           ContinueArguments.t,
           RequestMessage.req )
         request
  | NextRequest :
      (Dap_commands.next, NextArguments.t, RequestMessage.req) RequestMessage.t
      -> (Dap_commands.next, NextArguments.t, RequestMessage.req) request
  | StepInRequest :
      ( Dap_commands.stepIn,
        StepInArguments.t,
        RequestMessage.req )
      RequestMessage.t
      -> (Dap_commands.stepIn, StepInArguments.t, RequestMessage.req) request
  | StepOutRequest :
      ( Dap_commands.stepOut,
        StepOutArguments.t,
        RequestMessage.req )
      RequestMessage.t
      -> (Dap_commands.stepOut, StepOutArguments.t, RequestMessage.req) request
  | StepBackRequest :
      ( Dap_commands.stepBack,
        StepBackArguments.t,
        RequestMessage.req )
      RequestMessage.t
      -> ( Dap_commands.stepBack,
           StepBackArguments.t,
           RequestMessage.req )
         request
  | ReverseContinueRequest :
      ( Dap_commands.reverseContinue,
        ReverseContinueArguments.t,
        RequestMessage.req )
      RequestMessage.t
      -> ( Dap_commands.reverseContinue,
           ReverseContinueArguments.t,
           RequestMessage.req )
         request
  | RestartFrameRequest :
      ( Dap_commands.restartFrame,
        RestartFrameArguments.t,
        RequestMessage.req )
      RequestMessage.t
      -> ( Dap_commands.restartFrame,
           RestartFrameArguments.t,
           RequestMessage.req )
         request
  | GotoRequest :
      (Dap_commands.goto, GotoArguments.t, RequestMessage.req) RequestMessage.t
      -> (Dap_commands.goto, GotoArguments.t, RequestMessage.req) request
  | PauseRequest :
      ( Dap_commands.pause,
        PauseArguments.t,
        RequestMessage.req )
      RequestMessage.t
      -> (Dap_commands.pause, PauseArguments.t, RequestMessage.req) request
  | StackTraceRequest :
      ( Dap_commands.stackTrace,
        StackTraceArguments.t,
        RequestMessage.req )
      RequestMessage.t
      -> ( Dap_commands.stackTrace,
           StackTraceArguments.t,
           RequestMessage.req )
         request
  | ScopesRequest :
      ( Dap_commands.scopes,
        ScopesArguments.t,
        RequestMessage.req )
      RequestMessage.t
      -> (Dap_commands.scopes, ScopesArguments.t, RequestMessage.req) request
  | VariablesRequest :
      ( Dap_commands.variables,
        VariablesArguments.t,
        RequestMessage.req )
      RequestMessage.t
      -> ( Dap_commands.variables,
           VariablesArguments.t,
           RequestMessage.req )
         request
  | SetVariableRequest :
      ( Dap_commands.setVariable,
        SetVariableArguments.t,
        RequestMessage.req )
      RequestMessage.t
      -> ( Dap_commands.setVariable,
           SetVariableArguments.t,
           RequestMessage.req )
         request
  | SourceRequest :
      ( Dap_commands.source,
        SourceArguments.t,
        RequestMessage.req )
      RequestMessage.t
      -> (Dap_commands.source, SourceArguments.t, RequestMessage.req) request
  | ThreadsRequest :
      ( Dap_commands.threads,
        EmptyObject.t option,
        RequestMessage.opt )
      RequestMessage.t
      -> ( Dap_commands.threads,
           EmptyObject.t option,
           RequestMessage.opt )
         request
  | TerminateThreadsRequest :
      ( Dap_commands.terminateThreads,
        TerminateThreadsArguments.t,
        RequestMessage.req )
      RequestMessage.t
      -> ( Dap_commands.terminateThreads,
           TerminateThreadsArguments.t,
           RequestMessage.req )
         request
  | ModulesRequest :
      ( Dap_commands.modules,
        ModulesArguments.t,
        RequestMessage.req )
      RequestMessage.t
      -> (Dap_commands.modules, ModulesArguments.t, RequestMessage.req) request
  | LoadedSourcesRequest :
      ( Dap_commands.loadedSources,
        LoadedSourcesArguments.t option,
        RequestMessage.opt )
      RequestMessage.t
      -> ( Dap_commands.loadedSources,
           LoadedSourcesArguments.t option,
           RequestMessage.opt )
         request
  | EvaluateRequest :
      ( Dap_commands.evaluate,
        EvaluateArguments.t,
        RequestMessage.req )
      RequestMessage.t
      -> ( Dap_commands.evaluate,
           EvaluateArguments.t,
           RequestMessage.req )
         request
  | SetExpressionRequest :
      ( Dap_commands.setExpression,
        SetExpressionArguments.t,
        RequestMessage.req )
      RequestMessage.t
      -> ( Dap_commands.setExpression,
           SetExpressionArguments.t,
           RequestMessage.req )
         request
  | StepInTargetsRequest :
      ( Dap_commands.stepInTargets,
        StepInTargetsArguments.t,
        RequestMessage.req )
      RequestMessage.t
      -> ( Dap_commands.stepInTargets,
           StepInTargetsArguments.t,
           RequestMessage.req )
         request
  | GotoTargetsRequest :
      ( Dap_commands.gotoTargets,
        GotoTargetsArguments.t,
        RequestMessage.req )
      RequestMessage.t
      -> ( Dap_commands.gotoTargets,
           GotoTargetsArguments.t,
           RequestMessage.req )
         request
  | CompletionsRequest :
      ( Dap_commands.completions,
        CompletionsArguments.t,
        RequestMessage.req )
      RequestMessage.t
      -> ( Dap_commands.completions,
           CompletionsArguments.t,
           RequestMessage.req )
         request
  | ExceptionInfoRequest :
      ( Dap_commands.exceptionInfo,
        ExceptionInfoArguments.t,
        RequestMessage.req )
      RequestMessage.t
      -> ( Dap_commands.exceptionInfo,
           ExceptionInfoArguments.t,
           RequestMessage.req )
         request
  | ReadMemoryRequest :
      ( Dap_commands.readMemory,
        ReadMemoryArguments.t,
        RequestMessage.req )
      RequestMessage.t
      -> ( Dap_commands.readMemory,
           ReadMemoryArguments.t,
           RequestMessage.req )
         request
  | WriteMemoryRequest :
      ( Dap_commands.writeMemory,
        WriteMemoryArguments.t,
        RequestMessage.req )
      RequestMessage.t
      -> ( Dap_commands.writeMemory,
           WriteMemoryArguments.t,
           RequestMessage.req )
         request
  | DisassembleRequest :
      ( Dap_commands.disassemble,
        DisassembleArguments.t,
        RequestMessage.req )
      RequestMessage.t
      -> ( Dap_commands.disassemble,
           DisassembleArguments.t,
           RequestMessage.req )
         request

let cancelrequest req = CancelRequest req

let runinterminalrequest req = RunInTerminalRequest req

let initializerequest req = InitializeRequest req

let configurationdonerequest req = ConfigurationDoneRequest req

let launchrequest req = LaunchRequest req

let attachrequest req = AttachRequest req

let restartrequest req = RestartRequest req

let disconnectrequest req = DisconnectRequest req

let terminaterequest req = TerminateRequest req

let breakpointlocationsrequest req = BreakpointLocationsRequest req

let setbreakpointsrequest req = SetBreakpointsRequest req

let setfunctionbreakpointsrequest req = SetFunctionBreakpointsRequest req

let setexceptionbreakpointsrequest req = SetExceptionBreakpointsRequest req

let databreakpointinforequest req = DataBreakpointInfoRequest req

let setdatabreakpointsrequest req = SetDataBreakpointsRequest req

let setinstructionbreakpointsrequest req = SetInstructionBreakpointsRequest req

let continuerequest req = ContinueRequest req

let reversecontinuerequest req = ReverseContinueRequest req

let restartframerequest req = RestartFrameRequest req

let scopesrequest req = ScopesRequest req

let setvariablerequest req = SetVariableRequest req

let sourcerequest req = SourceRequest req

let terminatethreadsrequest req = TerminateThreadsRequest req

let modulesrequest req = ModulesRequest req

let evaluaterequest req = EvaluateRequest req

let setexpressionrequest req = SetExpressionRequest req

let stepintargetsrequest req = StepInTargetsRequest req

let gototargetsrequest req = GotoTargetsRequest req

let completionsrequest req = CompletionsRequest req

let exceptioninforequest req = ExceptionInfoRequest req

let readmemoryrequest req = ReadMemoryRequest req

let writememoryrequest req = WriteMemoryRequest req

let disassemblerequest req = DisassembleRequest req

type (_, _, _) response =
  | ErrorResponse :
      ( Dap_commands.error,
        ErrorResponse_body.t,
        ResponseMessage.req )
      ResponseMessage.t
      -> ( Dap_commands.error,
           ErrorResponse_body.t,
           ResponseMessage.req )
         response
  | CancelResponse :
      ( Dap_commands.cancel,
        EmptyObject.t option,
        ResponseMessage.opt )
      ResponseMessage.t
      -> ( Dap_commands.cancel,
           EmptyObject.t option,
           ResponseMessage.opt )
         response
  | RunInTerminalResponse :
      ( Dap_commands.runInTerminal,
        RunInTerminalResponse_body.t,
        ResponseMessage.req )
      ResponseMessage.t
      -> ( Dap_commands.runInTerminal,
           RunInTerminalResponse_body.t,
           ResponseMessage.req )
         response
  | InitializeResponse :
      ( Dap_commands.initialize,
        Capabilities.t option,
        ResponseMessage.opt )
      ResponseMessage.t
      -> ( Dap_commands.initialize,
           Capabilities.t option,
           ResponseMessage.opt )
         response
  | ConfigurationDoneResponse :
      ( Dap_commands.configurationDone,
        EmptyObject.t option,
        ResponseMessage.opt )
      ResponseMessage.t
      -> ( Dap_commands.configurationDone,
           EmptyObject.t option,
           ResponseMessage.opt )
         response
  | LaunchResponse :
      ( Dap_commands.launch,
        EmptyObject.t option,
        ResponseMessage.opt )
      ResponseMessage.t
      -> ( Dap_commands.launch,
           EmptyObject.t option,
           ResponseMessage.opt )
         response
  | AttachResponse :
      ( Dap_commands.attach,
        EmptyObject.t option,
        ResponseMessage.opt )
      ResponseMessage.t
      -> ( Dap_commands.attach,
           EmptyObject.t option,
           ResponseMessage.opt )
         response
  | RestartResponse :
      ( Dap_commands.restart,
        EmptyObject.t option,
        ResponseMessage.opt )
      ResponseMessage.t
      -> ( Dap_commands.restart,
           EmptyObject.t option,
           ResponseMessage.opt )
         response
  | DisconnectResponse :
      ( Dap_commands.disconnect,
        EmptyObject.t option,
        ResponseMessage.opt )
      ResponseMessage.t
      -> ( Dap_commands.disconnect,
           EmptyObject.t option,
           ResponseMessage.opt )
         response
  | TerminateResponse :
      ( Dap_commands.terminate,
        EmptyObject.t option,
        ResponseMessage.opt )
      ResponseMessage.t
      -> ( Dap_commands.terminate,
           EmptyObject.t option,
           ResponseMessage.opt )
         response
  | BreakpointLocationsResponse :
      ( Dap_commands.breakpointLocations,
        BreakpointLocationsResponse_body.t,
        ResponseMessage.req )
      ResponseMessage.t
      -> ( Dap_commands.breakpointLocations,
           BreakpointLocationsResponse_body.t,
           ResponseMessage.req )
         response
  | SetBreakpointsResponse :
      ( Dap_commands.setBreakpoints,
        SetBreakpointsResponse_body.t,
        ResponseMessage.req )
      ResponseMessage.t
      -> ( Dap_commands.setBreakpoints,
           SetBreakpointsResponse_body.t,
           ResponseMessage.req )
         response
  | SetFunctionBreakpointsResponse :
      ( Dap_commands.setFunctionBreakpoints,
        SetFunctionBreakpointsResponse_body.t,
        ResponseMessage.req )
      ResponseMessage.t
      -> ( Dap_commands.setFunctionBreakpoints,
           SetFunctionBreakpointsResponse_body.t,
           ResponseMessage.req )
         response
  | SetExceptionBreakpointsResponse :
      ( Dap_commands.setExceptionBreakpoints,
        SetExceptionBreakpointsResponse_body.t option,
        ResponseMessage.opt )
      ResponseMessage.t
      -> ( Dap_commands.setExceptionBreakpoints,
           SetExceptionBreakpointsResponse_body.t option,
           ResponseMessage.opt )
         response
  | DataBreakpointInfoResponse :
      ( Dap_commands.dataBreakpointInfo,
        DataBreakpointInfoResponse_body.t,
        ResponseMessage.req )
      ResponseMessage.t
      -> ( Dap_commands.dataBreakpointInfo,
           DataBreakpointInfoResponse_body.t,
           ResponseMessage.req )
         response
  | SetDataBreakpointsResponse :
      ( Dap_commands.setDataBreakpoints,
        SetDataBreakpointsResponse_body.t,
        ResponseMessage.req )
      ResponseMessage.t
      -> ( Dap_commands.setDataBreakpoints,
           SetDataBreakpointsResponse_body.t,
           ResponseMessage.req )
         response
  | SetInstructionBreakpointsResponse :
      ( Dap_commands.setInstructionBreakpoints,
        SetInstructionBreakpointsResponse_body.t,
        ResponseMessage.req )
      ResponseMessage.t
      -> ( Dap_commands.setInstructionBreakpoints,
           SetInstructionBreakpointsResponse_body.t,
           ResponseMessage.req )
         response
  | ContinueResponse :
      ( Dap_commands.continue,
        ContinueResponse_body.t,
        ResponseMessage.req )
      ResponseMessage.t
      -> ( Dap_commands.continue,
           ContinueResponse_body.t,
           ResponseMessage.req )
         response
  | NextResponse :
      ( Dap_commands.next,
        EmptyObject.t option,
        ResponseMessage.opt )
      ResponseMessage.t
      -> (Dap_commands.next, EmptyObject.t option, ResponseMessage.opt) response
  | StepInResponse :
      ( Dap_commands.stepIn,
        EmptyObject.t option,
        ResponseMessage.opt )
      ResponseMessage.t
      -> ( Dap_commands.stepIn,
           EmptyObject.t option,
           ResponseMessage.opt )
         response
  | StepOutResponse :
      ( Dap_commands.stepOut,
        EmptyObject.t option,
        ResponseMessage.opt )
      ResponseMessage.t
      -> ( Dap_commands.stepOut,
           EmptyObject.t option,
           ResponseMessage.opt )
         response
  | StepBackResponse :
      ( Dap_commands.stepBack,
        EmptyObject.t option,
        ResponseMessage.opt )
      ResponseMessage.t
      -> ( Dap_commands.stepBack,
           EmptyObject.t option,
           ResponseMessage.opt )
         response
  | ReverseContinueResponse :
      ( Dap_commands.reverseContinue,
        EmptyObject.t option,
        ResponseMessage.opt )
      ResponseMessage.t
      -> ( Dap_commands.reverseContinue,
           EmptyObject.t option,
           ResponseMessage.opt )
         response
  | RestartFrameResponse :
      ( Dap_commands.restartFrame,
        EmptyObject.t option,
        ResponseMessage.opt )
      ResponseMessage.t
      -> ( Dap_commands.restartFrame,
           EmptyObject.t option,
           ResponseMessage.opt )
         response
  | GotoResponse :
      ( Dap_commands.goto,
        EmptyObject.t option,
        ResponseMessage.opt )
      ResponseMessage.t
      -> (Dap_commands.goto, EmptyObject.t option, ResponseMessage.opt) response
  | PauseResponse :
      ( Dap_commands.pause,
        EmptyObject.t option,
        ResponseMessage.opt )
      ResponseMessage.t
      -> ( Dap_commands.pause,
           EmptyObject.t option,
           ResponseMessage.opt )
         response
  | StackTraceResponse :
      ( Dap_commands.stackTrace,
        StackTraceResponse_body.t,
        ResponseMessage.req )
      ResponseMessage.t
      -> ( Dap_commands.stackTrace,
           StackTraceResponse_body.t,
           ResponseMessage.req )
         response
  | ScopesResponse :
      ( Dap_commands.scopes,
        ScopesResponse_body.t,
        ResponseMessage.req )
      ResponseMessage.t
      -> ( Dap_commands.scopes,
           ScopesResponse_body.t,
           ResponseMessage.req )
         response
  | VariablesResponse :
      ( Dap_commands.variables,
        VariablesResponse_body.t,
        ResponseMessage.req )
      ResponseMessage.t
      -> ( Dap_commands.variables,
           VariablesResponse_body.t,
           ResponseMessage.req )
         response
  | SetVariableResponse :
      ( Dap_commands.setVariable,
        SetVariableResponse_body.t,
        ResponseMessage.req )
      ResponseMessage.t
      -> ( Dap_commands.setVariable,
           SetVariableResponse_body.t,
           ResponseMessage.req )
         response
  | SourceResponse :
      ( Dap_commands.source,
        SourceResponse_body.t,
        ResponseMessage.req )
      ResponseMessage.t
      -> ( Dap_commands.source,
           SourceResponse_body.t,
           ResponseMessage.req )
         response
  | ThreadsResponse :
      ( Dap_commands.threads,
        ThreadsResponse_body.t,
        ResponseMessage.req )
      ResponseMessage.t
      -> ( Dap_commands.threads,
           ThreadsResponse_body.t,
           ResponseMessage.req )
         response
  | TerminateThreadsResponse :
      ( Dap_commands.terminateThreads,
        EmptyObject.t option,
        ResponseMessage.opt )
      ResponseMessage.t
      -> ( Dap_commands.terminateThreads,
           EmptyObject.t option,
           ResponseMessage.opt )
         response
  | ModulesResponse :
      ( Dap_commands.modules,
        ModulesResponse_body.t,
        ResponseMessage.req )
      ResponseMessage.t
      -> ( Dap_commands.modules,
           ModulesResponse_body.t,
           ResponseMessage.req )
         response
  | LoadedSourcesResponse :
      ( Dap_commands.loadedSources,
        LoadedSourcesResponse_body.t,
        ResponseMessage.req )
      ResponseMessage.t
      -> ( Dap_commands.loadedSources,
           LoadedSourcesResponse_body.t,
           ResponseMessage.req )
         response
  | EvaluateResponse :
      ( Dap_commands.evaluate,
        EvaluateResponse_body.t,
        ResponseMessage.req )
      ResponseMessage.t
      -> ( Dap_commands.evaluate,
           EvaluateResponse_body.t,
           ResponseMessage.req )
         response
  | SetExpressionResponse :
      ( Dap_commands.setExpression,
        SetExpressionResponse_body.t,
        ResponseMessage.req )
      ResponseMessage.t
      -> ( Dap_commands.setExpression,
           SetExpressionResponse_body.t,
           ResponseMessage.req )
         response
  | StepInTargetsResponse :
      ( Dap_commands.stepInTargets,
        StepInTargetsResponse_body.t,
        ResponseMessage.req )
      ResponseMessage.t
      -> ( Dap_commands.stepInTargets,
           StepInTargetsResponse_body.t,
           ResponseMessage.req )
         response
  | GotoTargetsResponse :
      ( Dap_commands.gotoTargets,
        GotoTargetsResponse_body.t,
        ResponseMessage.req )
      ResponseMessage.t
      -> ( Dap_commands.gotoTargets,
           GotoTargetsResponse_body.t,
           ResponseMessage.req )
         response
  | CompletionsResponse :
      ( Dap_commands.completions,
        CompletionsResponse_body.t,
        ResponseMessage.req )
      ResponseMessage.t
      -> ( Dap_commands.completions,
           CompletionsResponse_body.t,
           ResponseMessage.req )
         response
  | ExceptionInfoResponse :
      ( Dap_commands.exceptionInfo,
        ExceptionInfoResponse_body.t,
        ResponseMessage.req )
      ResponseMessage.t
      -> ( Dap_commands.exceptionInfo,
           ExceptionInfoResponse_body.t,
           ResponseMessage.req )
         response
  | ReadMemoryResponse :
      ( Dap_commands.readMemory,
        ReadMemoryResponse_body.t option,
        ResponseMessage.opt )
      ResponseMessage.t
      -> ( Dap_commands.readMemory,
           ReadMemoryResponse_body.t option,
           ResponseMessage.opt )
         response
  | WriteMemoryResponse :
      ( Dap_commands.writeMemory,
        WriteMemoryResponse_body.t option,
        ResponseMessage.opt )
      ResponseMessage.t
      -> ( Dap_commands.writeMemory,
           WriteMemoryResponse_body.t option,
           ResponseMessage.opt )
         response
  | DisassembleResponse :
      ( Dap_commands.disassemble,
        DisassembleResponse_body.t option,
        ResponseMessage.opt )
      ResponseMessage.t
      -> ( Dap_commands.disassemble,
           DisassembleResponse_body.t option,
           ResponseMessage.opt )
         response

type (_, _, _) event =
  | InitializedEvent :
      ( Dap_events.initialized,
        EmptyObject.t option,
        EventMessage.opt )
      EventMessage.t
      -> (Dap_events.initialized, EmptyObject.t option, EventMessage.opt) event
  | StoppedEvent :
      (Dap_events.stopped, StoppedEvent_body.t, EventMessage.req) EventMessage.t
      -> (Dap_events.stopped, StoppedEvent_body.t, EventMessage.req) event
  | ContinuedEvent :
      ( Dap_events.continued,
        ContinuedEvent_body.t,
        EventMessage.req )
      EventMessage.t
      -> (Dap_events.continued, ContinuedEvent_body.t, EventMessage.req) event
  | ExitedEvent :
      (Dap_events.exited, ExitedEvent_body.t, EventMessage.req) EventMessage.t
      -> (Dap_events.exited, ExitedEvent_body.t, EventMessage.req) event
  | TerminatedEvent :
      ( Dap_events.terminated,
        TerminatedEvent_body.t option,
        EventMessage.opt )
      EventMessage.t
      -> ( Dap_events.terminated,
           TerminatedEvent_body.t option,
           EventMessage.opt )
         event
  | ThreadEvent :
      (Dap_events.thread, ThreadEvent_body.t, EventMessage.req) EventMessage.t
      -> (Dap_events.thread, ThreadEvent_body.t, EventMessage.req) event
  | OutputEvent :
      (Dap_events.output, OutputEvent_body.t, EventMessage.req) EventMessage.t
      -> (Dap_events.output, OutputEvent_body.t, EventMessage.req) event
  | BreakpointEvent :
      ( Dap_events.breakpoint,
        BreakpointEvent_body.t,
        EventMessage.req )
      EventMessage.t
      -> (Dap_events.breakpoint, BreakpointEvent_body.t, EventMessage.req) event
  | ModuleEvent :
      (Dap_events.module_, ModuleEvent_body.t, EventMessage.req) EventMessage.t
      -> (Dap_events.module_, ModuleEvent_body.t, EventMessage.req) event
  | LoadedSourceEvent :
      ( Dap_events.loadedSource,
        LoadedSourceEvent_body.t,
        EventMessage.req )
      EventMessage.t
      -> ( Dap_events.loadedSource,
           LoadedSourceEvent_body.t,
           EventMessage.req )
         event
  | ProcessEvent :
      (Dap_events.process, ProcessEvent_body.t, EventMessage.req) EventMessage.t
      -> (Dap_events.process, ProcessEvent_body.t, EventMessage.req) event
  | CapabilitiesEvent :
      ( Dap_events.capabilities,
        CapabilitiesEvent_body.t,
        EventMessage.req )
      EventMessage.t
      -> ( Dap_events.capabilities,
           CapabilitiesEvent_body.t,
           EventMessage.req )
         event
  | ProgressStartEvent :
      ( Dap_events.progressStart,
        ProgressStartEvent_body.t,
        EventMessage.req )
      EventMessage.t
      -> ( Dap_events.progressStart,
           ProgressStartEvent_body.t,
           EventMessage.req )
         event
  | ProgressUpdateEvent :
      ( Dap_events.progressUpdate,
        ProgressUpdateEvent_body.t,
        EventMessage.req )
      EventMessage.t
      -> ( Dap_events.progressUpdate,
           ProgressUpdateEvent_body.t,
           EventMessage.req )
         event
  | ProgressEndEvent :
      ( Dap_events.progressEnd,
        ProgressEndEvent_body.t,
        EventMessage.req )
      EventMessage.t
      -> ( Dap_events.progressEnd,
           ProgressEndEvent_body.t,
           EventMessage.req )
         event
  | InvalidatedEvent :
      ( Dap_events.invalidated,
        InvalidatedEvent_body.t,
        EventMessage.req )
      EventMessage.t
      -> ( Dap_events.invalidated,
           InvalidatedEvent_body.t,
           EventMessage.req )
         event
  | MemoryEvent :
      (Dap_events.memory, MemoryEvent_body.t, EventMessage.req) EventMessage.t
      -> (Dap_events.memory, MemoryEvent_body.t, EventMessage.req) event
