open Dap_render

let%expect_test "Check phantoms (command and event) example" =
  let schema_js = Ezjsonm.from_channel @@ open_in "data/phantoms.json" in
  let dfs = Dfs.make ~schema_js in
  let actual = render dfs @@ Commands ML in
  Printf.printf "%s" actual;
  [%expect {|
    (* NOTE autogenerated, do not manually edit *)
     type v = Cancel | Error [@@deriving eq]

     type 'a t = v

    type cancel
    type error

    let equal = equal_v

    let cancel : cancel t = Cancel
    let error : error t = Error

    let to_string (type a) : a t -> string = function | (Cancel : cancel t) -> "cancel"
    | (Error : error t) -> "error"

    let from_string (type a) : string -> a t = function | "cancel" -> (Cancel : cancel t)
    | "error" -> (Error : error t)| _ -> failwith "Dap_commands"



    let enc ~value =
      let open Data_encoding in
      let to_str = to_string in
      let from_str =
        let sentinal = to_string value in
        function
        | s when s = sentinal ->
          Ok (from_string s)
        | _  as s ->
          let err = Printf.sprintf "expected '%s', got '%s'" sentinal s in
          Error err
      in
      conv_with_guard
        to_str from_str string |}];

  let actual = render dfs @@ Commands MLI in
  Printf.printf "%s" actual;
  [%expect {|
    (* NOTE autogenerated, do not manually edit *)
     type 'a t
    type cancel
    type error

    val equal : 'a t -> 'b t -> bool

    val cancel : cancel t
    val error : error t

    val to_string : 'a t -> string

    val from_string : string -> 'a t

    val enc : value:'a t -> 'a t Data_encoding.t |}];

  let actual = render dfs @@ Events ML in
  Printf.printf "%s" actual;
  [%expect {|
    (* NOTE autogenerated, do not manually edit *)
     type v = Terminated | Exited | Continued | Stopped | Initialized [@@deriving eq]

     type 'a t = v

    type terminated
    type exited
    type continued
    type stopped
    type initialized

    let equal = equal_v

    let terminated : terminated t = Terminated
    let exited : exited t = Exited
    let continued : continued t = Continued
    let stopped : stopped t = Stopped
    let initialized : initialized t = Initialized

    let to_string (type a) : a t -> string = function | (Terminated : terminated t) -> "terminated"
    | (Exited : exited t) -> "exited"
    | (Continued : continued t) -> "continued"
    | (Stopped : stopped t) -> "stopped"
    | (Initialized : initialized t) -> "initialized"

    let from_string (type a) : string -> a t = function | "terminated" -> (Terminated : terminated t)
    | "exited" -> (Exited : exited t)
    | "continued" -> (Continued : continued t)
    | "stopped" -> (Stopped : stopped t)
    | "initialized" -> (Initialized : initialized t)| _ -> failwith "Dap_events"



    let enc ~value =
      let open Data_encoding in
      let to_str = to_string in
      let from_str =
        let sentinal = to_string value in
        function
        | s when s = sentinal ->
          Ok (from_string s)
        | _  as s ->
          let err = Printf.sprintf "expected '%s', got '%s'" sentinal s in
          Error err
      in
      conv_with_guard
        to_str from_str string |}];

  let actual = render dfs @@ Events MLI in
  Printf.printf "%s" actual;
  [%expect {|
    (* NOTE autogenerated, do not manually edit *)
     type 'a t
    type terminated
    type exited
    type continued
    type stopped
    type initialized

    val equal : 'a t -> 'b t -> bool

    val terminated : terminated t
    val exited : exited t
    val continued : continued t
    val stopped : stopped t
    val initialized : initialized t

    val to_string : 'a t -> string

    val from_string : string -> 'a t

    val enc : value:'a t -> 'a t Data_encoding.t |}]

let%expect_test "Check ErrorResponse example" =
  let schema_js = Ezjsonm.from_channel @@ open_in "data/errorResponse.json" in
  let dfs = Dfs.make ~schema_js in
  let actual = render dfs Messages in
  Printf.printf "%s" actual;
  [%expect {|
    (* NOTE this file was autogenerated - do not modify by hand *)

     module RequestMessage = Dap_request_message
     module ResponseMessage = Dap_response_message
     module EventMessage = Dap_event_message

     module Data = struct

     include Dap_base

     (* supporting data modules *) module Message : sig
    type t
     val equal : t -> t -> bool
     val enc : t Data_encoding.t
     val gen : t QCheck.Gen.t
     val arb : t QCheck.arbitrary
     val make : id:int -> format:string -> ?variables:Data_encoding.json -> ?sendTelemetry:bool -> ?showUser:bool -> ?url:string -> ?urlLabel:string -> ?lines:int list -> unit -> t
     val id : t -> (int  )
    val format : t -> (string  )
    val variables : t -> (Data_encoding.json option  )
    val sendTelemetry : t -> (bool option  )
    val showUser : t -> (bool option  )
    val url : t -> (string option  )
    val urlLabel : t -> (string option  )
    val lines : t -> (int list option  )
    end = struct
     type t = { id: (int [@gen Gen.gen_int31] );
    format: (string [@gen Gen.gen_utf8_str] );
    variables: (Data_encoding.json option [@gen Gen.gen_json_opt] [@equal Eq.equal_json_opt]);
    sendTelemetry: (bool option  );
    showUser: (bool option  );
    url: (string option [@gen Gen.gen_utf8_str_opt] );
    urlLabel: (string option [@gen Gen.gen_utf8_str_opt] );
    lines: (int list option [@gen Gen.gen_int31_list_opt] ); } [@@deriving qcheck, eq]



     let enc =
     let open Data_encoding in
     (* Message.t *)
             conv
     (fun {id; format; variables; sendTelemetry; showUser; url; urlLabel; lines} -> (id, format, variables, sendTelemetry, showUser, url, urlLabel, lines))
     (fun (id, format, variables, sendTelemetry, showUser, url, urlLabel, lines) -> {id; format; variables; sendTelemetry; showUser; url; urlLabel; lines})
     (obj8
    (req "id" int31)
    (req "format" string)
    (opt "variables" json)
    (opt "sendTelemetry" bool)
    (opt "showUser" bool)
    (opt "url" string)
    (opt "urlLabel" string)
    (opt "lines" (list int31)))


     let make ~id ~format ?variables ?sendTelemetry ?showUser ?url ?urlLabel ?lines () =
    {id; format; variables; sendTelemetry; showUser; url; urlLabel; lines}

     let id t = t.id
    let format t = t.format
    let variables t = t.variables
    let sendTelemetry t = t.sendTelemetry
    let showUser t = t.showUser
    let url t = t.url
    let urlLabel t = t.urlLabel
    let lines t = t.lines

     end


    module ErrorResponse_body : sig
    type t
     val equal : t -> t -> bool
     val enc : t Data_encoding.t
     val gen : t QCheck.Gen.t
     val arb : t QCheck.arbitrary
     val make : ?error:Message.t -> unit -> t
     val error : t -> (Message.t option  )
    end = struct
     type t = { error: (Message.t option  ); } [@@deriving qcheck, eq]



     let enc =
     let open Data_encoding in
     (* ErrorResponse_body.t *)
             conv
     (fun {error} -> error)
     (fun error -> {error})
     (obj1
    (opt "error" Message.enc))


     let make ?error () =
    {error}

     let error t = t.error

     end




     end

     module Request  = struct

     open Data

     type _ t =

           | Fmap : ('a -> 'b) -> ('a -> 'b) t

           (* request GADT items *)

     (* request constructors *)

     end

     module Response = struct

     open Data

     type _ t =

           | Fmap : ('a -> 'b) -> ('a -> 'b) t

           (* response GADT items *) | ErrorResponse : (Dap_commands.error, ErrorResponse_body.t, Presence.req) ResponseMessage.t -> (Dap_commands.error, ErrorResponse_body.t, Presence.req) ResponseMessage.t t

     (* response constructors *) let errorResponse resp = ErrorResponse resp

     end

     module Event = struct

     open Data

     type _ t =

           | Fmap : ('a -> 'b) -> ('a -> 'b) t

           (* event GADT items *)


           (* event constructors *)

     end |}]


let%expect_test "Check CancelRequest example" =
  let schema_js = Ezjsonm.from_channel @@ open_in "data/cancelRequest.json" in
  let dfs = Dfs.make ~schema_js in
  let actual = render dfs Messages in
  Printf.printf "%s" actual;
  [%expect {|
    (* NOTE this file was autogenerated - do not modify by hand *)

     module RequestMessage = Dap_request_message
     module ResponseMessage = Dap_response_message
     module EventMessage = Dap_event_message

     module Data = struct

     include Dap_base

     (* supporting data modules *) module CancelArguments : sig
    type t
     val equal : t -> t -> bool
     val enc : t Data_encoding.t
     val gen : t QCheck.Gen.t
     val arb : t QCheck.arbitrary
     val make : ?requestId:int -> ?progressId:string -> unit -> t
     val requestId : t -> (int option  )
    val progressId : t -> (string option  )
    end = struct
     type t = { requestId: (int option [@gen Gen.gen_int31_opt] );
    progressId: (string option [@gen Gen.gen_utf8_str_opt] ); } [@@deriving qcheck, eq]



     let enc =
     let open Data_encoding in
     (* CancelArguments.t *)
             conv
     (fun {requestId; progressId} -> (requestId, progressId))
     (fun (requestId, progressId) -> {requestId; progressId})
     (obj2
    (opt "requestId" int31)
    (opt "progressId" string))


     let make ?requestId ?progressId () =
    {requestId; progressId}

     let requestId t = t.requestId
    let progressId t = t.progressId

     end




     end

     module Request  = struct

     open Data

     type _ t =

           | Fmap : ('a -> 'b) -> ('a -> 'b) t

           (* request GADT items *) | CancelRequest : (Dap_commands.cancel, CancelArguments.t option, Presence.opt) RequestMessage.t -> (Dap_commands.cancel, CancelArguments.t option, Presence.opt) RequestMessage.t t

     (* request constructors *) let cancelRequest req = CancelRequest req

     end

     module Response = struct

     open Data

     type _ t =

           | Fmap : ('a -> 'b) -> ('a -> 'b) t

           (* response GADT items *)

     (* response constructors *)

     end

     module Event = struct

     open Data

     type _ t =

           | Fmap : ('a -> 'b) -> ('a -> 'b) t

           (* event GADT items *)


           (* event constructors *)

     end |}]


let%expect_test "Check StoppedEvent example" =
  let schema_js = Ezjsonm.from_channel @@ open_in "data/stoppedEvent.json" in
  let dfs = Dfs.make ~schema_js in
  let actual = render dfs Messages in
  Printf.printf "%s" actual;
  [%expect {|
    (* NOTE this file was autogenerated - do not modify by hand *)

     module RequestMessage = Dap_request_message
     module ResponseMessage = Dap_response_message
     module EventMessage = Dap_event_message

     module Data = struct

     include Dap_base

     (* supporting data modules *) (* dont bother with a sig for enums, the inferred one is fine *)
     module StoppedEvent_body_reason = struct
     type t = Step | Breakpoint | Exception | Pause | Entry | Goto | Function_breakpoint | Data_breakpoint | Instruction_breakpoint | Other of string [@@deriving qcheck, eq]

     let enc =
     let open Data_encoding in
     conv_with_guard
     (function Step -> "step" | Breakpoint -> "breakpoint" | Exception -> "exception" | Pause -> "pause" | Entry -> "entry" | Goto -> "goto" | Function_breakpoint -> "function breakpoint" | Data_breakpoint -> "data breakpoint" | Instruction_breakpoint -> "instruction breakpoint" | Other s -> s)
     (function "step" -> Ok Step | "breakpoint" -> Ok Breakpoint | "exception" -> Ok Exception | "pause" -> Ok Pause | "entry" -> Ok Entry | "goto" -> Ok Goto | "function breakpoint" -> Ok Function_breakpoint | "data breakpoint" -> Ok Data_breakpoint | "instruction breakpoint" -> Ok Instruction_breakpoint | _ as s -> Ok (Other s))
     string

     end


    module StoppedEvent_body : sig
    type t
     val equal : t -> t -> bool
     val enc : t Data_encoding.t
     val gen : t QCheck.Gen.t
     val arb : t QCheck.arbitrary
     val make : reason:StoppedEvent_body_reason.t -> ?description:string -> ?threadId:int -> ?preserveFocusHint:bool -> ?text:string -> ?allThreadsStopped:bool -> ?hitBreakpointIds:int list -> unit -> t
     val reason : t -> (StoppedEvent_body_reason.t  )
    val description : t -> (string option  )
    val threadId : t -> (int option  )
    val preserveFocusHint : t -> (bool option  )
    val text : t -> (string option  )
    val allThreadsStopped : t -> (bool option  )
    val hitBreakpointIds : t -> (int list option  )
    end = struct
     type t = { reason: (StoppedEvent_body_reason.t  );
    description: (string option [@gen Gen.gen_utf8_str_opt] );
    threadId: (int option [@gen Gen.gen_int31_opt] );
    preserveFocusHint: (bool option  );
    text: (string option [@gen Gen.gen_utf8_str_opt] );
    allThreadsStopped: (bool option  );
    hitBreakpointIds: (int list option [@gen Gen.gen_int31_list_opt] ); } [@@deriving qcheck, eq]



     let enc =
     let open Data_encoding in
     (* StoppedEvent_body.t *)
             conv
     (fun {reason; description; threadId; preserveFocusHint; text; allThreadsStopped; hitBreakpointIds} -> (reason, description, threadId, preserveFocusHint, text, allThreadsStopped, hitBreakpointIds))
     (fun (reason, description, threadId, preserveFocusHint, text, allThreadsStopped, hitBreakpointIds) -> {reason; description; threadId; preserveFocusHint; text; allThreadsStopped; hitBreakpointIds})
     (obj7
    (req "reason" StoppedEvent_body_reason.enc)
    (opt "description" string)
    (opt "threadId" int31)
    (opt "preserveFocusHint" bool)
    (opt "text" string)
    (opt "allThreadsStopped" bool)
    (opt "hitBreakpointIds" (list int31)))


     let make ~reason ?description ?threadId ?preserveFocusHint ?text ?allThreadsStopped ?hitBreakpointIds () =
    {reason; description; threadId; preserveFocusHint; text; allThreadsStopped; hitBreakpointIds}

     let reason t = t.reason
    let description t = t.description
    let threadId t = t.threadId
    let preserveFocusHint t = t.preserveFocusHint
    let text t = t.text
    let allThreadsStopped t = t.allThreadsStopped
    let hitBreakpointIds t = t.hitBreakpointIds

     end




     end

     module Request  = struct

     open Data

     type _ t =

           | Fmap : ('a -> 'b) -> ('a -> 'b) t

           (* request GADT items *)

     (* request constructors *)

     end

     module Response = struct

     open Data

     type _ t =

           | Fmap : ('a -> 'b) -> ('a -> 'b) t

           (* response GADT items *)

     (* response constructors *)

     end

     module Event = struct

     open Data

     type _ t =

           | Fmap : ('a -> 'b) -> ('a -> 'b) t

           (* event GADT items *) | StoppedEvent : (Dap_events.stopped, StoppedEvent_body.t, Presence.req) EventMessage.t -> (Dap_events.stopped, StoppedEvent_body.t, Presence.req) EventMessage.t t


           (* event constructors *) let stoppedEvent ev = StoppedEvent ev

     end |}]


let%expect_test "Check cyclic example" =
  let schema_js = Ezjsonm.from_channel @@ open_in "data/cyclic.json" in
  let dfs = Dfs.make ~schema_js in
  let actual = render dfs Messages in
  Printf.printf "%s" actual;
  [%expect {|
    (* NOTE this file was autogenerated - do not modify by hand *)

     module RequestMessage = Dap_request_message
     module ResponseMessage = Dap_response_message
     module EventMessage = Dap_event_message

     module Data = struct

     include Dap_base

     (* supporting data modules *) module ExceptionDetails : sig
    type t
     val equal : t -> t -> bool
     val enc : t Data_encoding.t
     val gen : t QCheck.Gen.t
     val arb : t QCheck.arbitrary
     val make : ?message:string -> ?typeName:string -> ?fullTypeName:string -> ?evaluateName:string -> ?stackTrace:string -> ?innerException:t list -> unit -> t
     val message : t -> (string option  )
    val typeName : t -> (string option  )
    val fullTypeName : t -> (string option  )
    val evaluateName : t -> (string option  )
    val stackTrace : t -> (string option  )
    val innerException : t -> (t list option  )
    end = struct
     type t = { message: (string option [@gen Gen.gen_utf8_str_opt] );
    typeName: (string option [@gen Gen.gen_utf8_str_opt] );
    fullTypeName: (string option [@gen Gen.gen_utf8_str_opt] );
    evaluateName: (string option [@gen Gen.gen_utf8_str_opt] );
    stackTrace: (string option [@gen Gen.gen_utf8_str_opt] );
    innerException: (t list option  ); } [@@deriving eq]

     let gen = QCheck.Gen.(sized @@ fix (fun self n ->
     let basecase = oneofl [None; Some []] in
     let _gen_t =
                fun t ->
                  let gg =
                    tup6
                      Gen.gen_utf8_str_opt
    Gen.gen_utf8_str_opt
    Gen.gen_utf8_str_opt
    Gen.gen_utf8_str_opt
    Gen.gen_utf8_str_opt
    t
                  in
                  map (fun ( message, typeName, fullTypeName, evaluateName, stackTrace, innerException ) -> { message; typeName; fullTypeName; evaluateName; stackTrace; innerException }) gg
              in
              match n with
              | 0 -> _gen_t basecase
              | n ->
                frequency
                  [
                    (1, _gen_t basecase);
                    (1, let t = map (fun {innerException; _} -> innerException) @@ self (n - 1) in _gen_t t);
                  ]
            ))
     let arb = QCheck.make gen


     let enc =
     let open Data_encoding in
     mu "ExceptionDetails.t"
     ( fun e ->
     conv
     (fun {message; typeName; fullTypeName; evaluateName; stackTrace; innerException} -> (message, typeName, fullTypeName, evaluateName, stackTrace, innerException))
     (fun (message, typeName, fullTypeName, evaluateName, stackTrace, innerException) -> {message; typeName; fullTypeName; evaluateName; stackTrace; innerException})
     (obj6
    (opt "message" string)
    (opt "typeName" string)
    (opt "fullTypeName" string)
    (opt "evaluateName" string)
    (opt "stackTrace" string)
    (opt "innerException" (list e)))
    )

     let make ?message ?typeName ?fullTypeName ?evaluateName ?stackTrace ?innerException () =
    {message; typeName; fullTypeName; evaluateName; stackTrace; innerException}

     let message t = t.message
    let typeName t = t.typeName
    let fullTypeName t = t.fullTypeName
    let evaluateName t = t.evaluateName
    let stackTrace t = t.stackTrace
    let innerException t = t.innerException

     end


     end

     module Request  = struct

     open Data

     type _ t =

           | Fmap : ('a -> 'b) -> ('a -> 'b) t

           (* request GADT items *)

     (* request constructors *)

     end

     module Response = struct

     open Data

     type _ t =

           | Fmap : ('a -> 'b) -> ('a -> 'b) t

           (* response GADT items *)

     (* response constructors *)

     end

     module Event = struct

     open Data

     type _ t =

           | Fmap : ('a -> 'b) -> ('a -> 'b) t

           (* event GADT items *)


           (* event constructors *)

     end |}]

let%expect_test "Check large example" =
  let schema_js = Ezjsonm.from_channel @@ open_in "data/largeObject.json" in
  let dfs = Dfs.make ~schema_js in
  let actual = render dfs Messages in
  Printf.printf "%s" actual;
  [%expect {|
    (* NOTE this file was autogenerated - do not modify by hand *)

     module RequestMessage = Dap_request_message
     module ResponseMessage = Dap_response_message
     module EventMessage = Dap_event_message

     module Data = struct

     include Dap_base

     (* supporting data modules *) module Capabilities : sig
    type t
     val equal : t -> t -> bool
     val enc : t Data_encoding.t
     val gen : t QCheck.Gen.t
     val arb : t QCheck.arbitrary
     val make : ?supportsConfigurationDoneRequest:bool -> ?supportsFunctionBreakpoints:bool -> ?supportsConditionalBreakpoints:bool -> ?supportsHitConditionalBreakpoints:bool -> ?supportsEvaluateForHovers:bool -> ?supportsStepBack:bool -> ?supportsSetVariable:bool -> ?supportsRestartFrame:bool -> ?supportsGotoTargetsRequest:bool -> ?supportsStepInTargetsRequest:bool -> ?supportsCompletionsRequest:bool -> ?completionTriggerCharacters:string list -> ?supportsModulesRequest:bool -> ?supportsRestartRequest:bool -> ?supportsExceptionOptions:bool -> ?supportsValueFormattingOptions:bool -> ?supportsExceptionInfoRequest:bool -> ?supportTerminateDebuggee:bool -> ?supportSuspendDebuggee:bool -> ?supportsDelayedStackTraceLoading:bool -> ?supportsLoadedSourcesRequest:bool -> ?supportsLogPoints:bool -> ?supportsTerminateThreadsRequest:bool -> ?supportsSetExpression:bool -> ?supportsTerminateRequest:bool -> ?supportsDataBreakpoints:bool -> ?supportsReadMemoryRequest:bool -> ?supportsWriteMemoryRequest:bool -> ?supportsDisassembleRequest:bool -> ?supportsCancelRequest:bool -> ?supportsBreakpointLocationsRequest:bool -> ?supportsClipboardContext:bool -> ?supportsSteppingGranularity:bool -> ?supportsInstructionBreakpoints:bool -> ?supportsExceptionFilterOptions:bool -> ?supportsSingleThreadExecutionRequests:bool -> unit -> t
     val supportsConfigurationDoneRequest : t -> (bool option  )
    val supportsFunctionBreakpoints : t -> (bool option  )
    val supportsConditionalBreakpoints : t -> (bool option  )
    val supportsHitConditionalBreakpoints : t -> (bool option  )
    val supportsEvaluateForHovers : t -> (bool option  )
    val supportsStepBack : t -> (bool option  )
    val supportsSetVariable : t -> (bool option  )
    val supportsRestartFrame : t -> (bool option  )
    val supportsGotoTargetsRequest : t -> (bool option  )
    val supportsStepInTargetsRequest : t -> (bool option  )
    val supportsCompletionsRequest : t -> (bool option  )
    val completionTriggerCharacters : t -> (string list option  )
    val supportsModulesRequest : t -> (bool option  )
    val supportsRestartRequest : t -> (bool option  )
    val supportsExceptionOptions : t -> (bool option  )
    val supportsValueFormattingOptions : t -> (bool option  )
    val supportsExceptionInfoRequest : t -> (bool option  )
    val supportTerminateDebuggee : t -> (bool option  )
    val supportSuspendDebuggee : t -> (bool option  )
    val supportsDelayedStackTraceLoading : t -> (bool option  )
    val supportsLoadedSourcesRequest : t -> (bool option  )
    val supportsLogPoints : t -> (bool option  )
    val supportsTerminateThreadsRequest : t -> (bool option  )
    val supportsSetExpression : t -> (bool option  )
    val supportsTerminateRequest : t -> (bool option  )
    val supportsDataBreakpoints : t -> (bool option  )
    val supportsReadMemoryRequest : t -> (bool option  )
    val supportsWriteMemoryRequest : t -> (bool option  )
    val supportsDisassembleRequest : t -> (bool option  )
    val supportsCancelRequest : t -> (bool option  )
    val supportsBreakpointLocationsRequest : t -> (bool option  )
    val supportsClipboardContext : t -> (bool option  )
    val supportsSteppingGranularity : t -> (bool option  )
    val supportsInstructionBreakpoints : t -> (bool option  )
    val supportsExceptionFilterOptions : t -> (bool option  )
    val supportsSingleThreadExecutionRequests : t -> (bool option  )
    end = struct
     module Capabilities_0 = struct
     type t = { supportsConfigurationDoneRequest: (bool option  );
    supportsFunctionBreakpoints: (bool option  );
    supportsConditionalBreakpoints: (bool option  );
    supportsHitConditionalBreakpoints: (bool option  );
    supportsEvaluateForHovers: (bool option  );
    supportsStepBack: (bool option  );
    supportsSetVariable: (bool option  );
    supportsRestartFrame: (bool option  );
    supportsGotoTargetsRequest: (bool option  );
    supportsStepInTargetsRequest: (bool option  ); } [@@deriving qcheck, eq]



     let enc =
     let open Data_encoding in
     (* Capabilities_0.t *)
             conv
     (fun {supportsConfigurationDoneRequest; supportsFunctionBreakpoints; supportsConditionalBreakpoints; supportsHitConditionalBreakpoints; supportsEvaluateForHovers; supportsStepBack; supportsSetVariable; supportsRestartFrame; supportsGotoTargetsRequest; supportsStepInTargetsRequest} -> (supportsConfigurationDoneRequest, supportsFunctionBreakpoints, supportsConditionalBreakpoints, supportsHitConditionalBreakpoints, supportsEvaluateForHovers, supportsStepBack, supportsSetVariable, supportsRestartFrame, supportsGotoTargetsRequest, supportsStepInTargetsRequest))
     (fun (supportsConfigurationDoneRequest, supportsFunctionBreakpoints, supportsConditionalBreakpoints, supportsHitConditionalBreakpoints, supportsEvaluateForHovers, supportsStepBack, supportsSetVariable, supportsRestartFrame, supportsGotoTargetsRequest, supportsStepInTargetsRequest) -> {supportsConfigurationDoneRequest; supportsFunctionBreakpoints; supportsConditionalBreakpoints; supportsHitConditionalBreakpoints; supportsEvaluateForHovers; supportsStepBack; supportsSetVariable; supportsRestartFrame; supportsGotoTargetsRequest; supportsStepInTargetsRequest})
     (obj10
    (opt "supportsConfigurationDoneRequest" bool)
    (opt "supportsFunctionBreakpoints" bool)
    (opt "supportsConditionalBreakpoints" bool)
    (opt "supportsHitConditionalBreakpoints" bool)
    (opt "supportsEvaluateForHovers" bool)
    (opt "supportsStepBack" bool)
    (opt "supportsSetVariable" bool)
    (opt "supportsRestartFrame" bool)
    (opt "supportsGotoTargetsRequest" bool)
    (opt "supportsStepInTargetsRequest" bool))


     let make ?supportsConfigurationDoneRequest ?supportsFunctionBreakpoints ?supportsConditionalBreakpoints ?supportsHitConditionalBreakpoints ?supportsEvaluateForHovers ?supportsStepBack ?supportsSetVariable ?supportsRestartFrame ?supportsGotoTargetsRequest ?supportsStepInTargetsRequest () =
    {supportsConfigurationDoneRequest; supportsFunctionBreakpoints; supportsConditionalBreakpoints; supportsHitConditionalBreakpoints; supportsEvaluateForHovers; supportsStepBack; supportsSetVariable; supportsRestartFrame; supportsGotoTargetsRequest; supportsStepInTargetsRequest}

     let supportsConfigurationDoneRequest t = t.supportsConfigurationDoneRequest
    let supportsFunctionBreakpoints t = t.supportsFunctionBreakpoints
    let supportsConditionalBreakpoints t = t.supportsConditionalBreakpoints
    let supportsHitConditionalBreakpoints t = t.supportsHitConditionalBreakpoints
    let supportsEvaluateForHovers t = t.supportsEvaluateForHovers
    let supportsStepBack t = t.supportsStepBack
    let supportsSetVariable t = t.supportsSetVariable
    let supportsRestartFrame t = t.supportsRestartFrame
    let supportsGotoTargetsRequest t = t.supportsGotoTargetsRequest
    let supportsStepInTargetsRequest t = t.supportsStepInTargetsRequest

     end


    module Capabilities_10 = struct
     type t = { supportsCompletionsRequest: (bool option  );
    completionTriggerCharacters: (string list option [@gen Gen.gen_utf8_str_list_opt] );
    supportsModulesRequest: (bool option  );
    supportsRestartRequest: (bool option  );
    supportsExceptionOptions: (bool option  );
    supportsValueFormattingOptions: (bool option  );
    supportsExceptionInfoRequest: (bool option  );
    supportTerminateDebuggee: (bool option  );
    supportSuspendDebuggee: (bool option  );
    supportsDelayedStackTraceLoading: (bool option  ); } [@@deriving qcheck, eq]



     let enc =
     let open Data_encoding in
     (* Capabilities_10.t *)
             conv
     (fun {supportsCompletionsRequest; completionTriggerCharacters; supportsModulesRequest; supportsRestartRequest; supportsExceptionOptions; supportsValueFormattingOptions; supportsExceptionInfoRequest; supportTerminateDebuggee; supportSuspendDebuggee; supportsDelayedStackTraceLoading} -> (supportsCompletionsRequest, completionTriggerCharacters, supportsModulesRequest, supportsRestartRequest, supportsExceptionOptions, supportsValueFormattingOptions, supportsExceptionInfoRequest, supportTerminateDebuggee, supportSuspendDebuggee, supportsDelayedStackTraceLoading))
     (fun (supportsCompletionsRequest, completionTriggerCharacters, supportsModulesRequest, supportsRestartRequest, supportsExceptionOptions, supportsValueFormattingOptions, supportsExceptionInfoRequest, supportTerminateDebuggee, supportSuspendDebuggee, supportsDelayedStackTraceLoading) -> {supportsCompletionsRequest; completionTriggerCharacters; supportsModulesRequest; supportsRestartRequest; supportsExceptionOptions; supportsValueFormattingOptions; supportsExceptionInfoRequest; supportTerminateDebuggee; supportSuspendDebuggee; supportsDelayedStackTraceLoading})
     (obj10
    (opt "supportsCompletionsRequest" bool)
    (opt "completionTriggerCharacters" (list string))
    (opt "supportsModulesRequest" bool)
    (opt "supportsRestartRequest" bool)
    (opt "supportsExceptionOptions" bool)
    (opt "supportsValueFormattingOptions" bool)
    (opt "supportsExceptionInfoRequest" bool)
    (opt "supportTerminateDebuggee" bool)
    (opt "supportSuspendDebuggee" bool)
    (opt "supportsDelayedStackTraceLoading" bool))


     let make ?supportsCompletionsRequest ?completionTriggerCharacters ?supportsModulesRequest ?supportsRestartRequest ?supportsExceptionOptions ?supportsValueFormattingOptions ?supportsExceptionInfoRequest ?supportTerminateDebuggee ?supportSuspendDebuggee ?supportsDelayedStackTraceLoading () =
    {supportsCompletionsRequest; completionTriggerCharacters; supportsModulesRequest; supportsRestartRequest; supportsExceptionOptions; supportsValueFormattingOptions; supportsExceptionInfoRequest; supportTerminateDebuggee; supportSuspendDebuggee; supportsDelayedStackTraceLoading}

     let supportsCompletionsRequest t = t.supportsCompletionsRequest
    let completionTriggerCharacters t = t.completionTriggerCharacters
    let supportsModulesRequest t = t.supportsModulesRequest
    let supportsRestartRequest t = t.supportsRestartRequest
    let supportsExceptionOptions t = t.supportsExceptionOptions
    let supportsValueFormattingOptions t = t.supportsValueFormattingOptions
    let supportsExceptionInfoRequest t = t.supportsExceptionInfoRequest
    let supportTerminateDebuggee t = t.supportTerminateDebuggee
    let supportSuspendDebuggee t = t.supportSuspendDebuggee
    let supportsDelayedStackTraceLoading t = t.supportsDelayedStackTraceLoading

     end


    module Capabilities_20 = struct
     type t = { supportsLoadedSourcesRequest: (bool option  );
    supportsLogPoints: (bool option  );
    supportsTerminateThreadsRequest: (bool option  );
    supportsSetExpression: (bool option  );
    supportsTerminateRequest: (bool option  );
    supportsDataBreakpoints: (bool option  );
    supportsReadMemoryRequest: (bool option  );
    supportsWriteMemoryRequest: (bool option  );
    supportsDisassembleRequest: (bool option  );
    supportsCancelRequest: (bool option  ); } [@@deriving qcheck, eq]



     let enc =
     let open Data_encoding in
     (* Capabilities_20.t *)
             conv
     (fun {supportsLoadedSourcesRequest; supportsLogPoints; supportsTerminateThreadsRequest; supportsSetExpression; supportsTerminateRequest; supportsDataBreakpoints; supportsReadMemoryRequest; supportsWriteMemoryRequest; supportsDisassembleRequest; supportsCancelRequest} -> (supportsLoadedSourcesRequest, supportsLogPoints, supportsTerminateThreadsRequest, supportsSetExpression, supportsTerminateRequest, supportsDataBreakpoints, supportsReadMemoryRequest, supportsWriteMemoryRequest, supportsDisassembleRequest, supportsCancelRequest))
     (fun (supportsLoadedSourcesRequest, supportsLogPoints, supportsTerminateThreadsRequest, supportsSetExpression, supportsTerminateRequest, supportsDataBreakpoints, supportsReadMemoryRequest, supportsWriteMemoryRequest, supportsDisassembleRequest, supportsCancelRequest) -> {supportsLoadedSourcesRequest; supportsLogPoints; supportsTerminateThreadsRequest; supportsSetExpression; supportsTerminateRequest; supportsDataBreakpoints; supportsReadMemoryRequest; supportsWriteMemoryRequest; supportsDisassembleRequest; supportsCancelRequest})
     (obj10
    (opt "supportsLoadedSourcesRequest" bool)
    (opt "supportsLogPoints" bool)
    (opt "supportsTerminateThreadsRequest" bool)
    (opt "supportsSetExpression" bool)
    (opt "supportsTerminateRequest" bool)
    (opt "supportsDataBreakpoints" bool)
    (opt "supportsReadMemoryRequest" bool)
    (opt "supportsWriteMemoryRequest" bool)
    (opt "supportsDisassembleRequest" bool)
    (opt "supportsCancelRequest" bool))


     let make ?supportsLoadedSourcesRequest ?supportsLogPoints ?supportsTerminateThreadsRequest ?supportsSetExpression ?supportsTerminateRequest ?supportsDataBreakpoints ?supportsReadMemoryRequest ?supportsWriteMemoryRequest ?supportsDisassembleRequest ?supportsCancelRequest () =
    {supportsLoadedSourcesRequest; supportsLogPoints; supportsTerminateThreadsRequest; supportsSetExpression; supportsTerminateRequest; supportsDataBreakpoints; supportsReadMemoryRequest; supportsWriteMemoryRequest; supportsDisassembleRequest; supportsCancelRequest}

     let supportsLoadedSourcesRequest t = t.supportsLoadedSourcesRequest
    let supportsLogPoints t = t.supportsLogPoints
    let supportsTerminateThreadsRequest t = t.supportsTerminateThreadsRequest
    let supportsSetExpression t = t.supportsSetExpression
    let supportsTerminateRequest t = t.supportsTerminateRequest
    let supportsDataBreakpoints t = t.supportsDataBreakpoints
    let supportsReadMemoryRequest t = t.supportsReadMemoryRequest
    let supportsWriteMemoryRequest t = t.supportsWriteMemoryRequest
    let supportsDisassembleRequest t = t.supportsDisassembleRequest
    let supportsCancelRequest t = t.supportsCancelRequest

     end


    module Capabilities_30 = struct
     type t = { supportsBreakpointLocationsRequest: (bool option  );
    supportsClipboardContext: (bool option  );
    supportsSteppingGranularity: (bool option  );
    supportsInstructionBreakpoints: (bool option  );
    supportsExceptionFilterOptions: (bool option  );
    supportsSingleThreadExecutionRequests: (bool option  ); } [@@deriving qcheck, eq]



     let enc =
     let open Data_encoding in
     (* Capabilities_30.t *)
             conv
     (fun {supportsBreakpointLocationsRequest; supportsClipboardContext; supportsSteppingGranularity; supportsInstructionBreakpoints; supportsExceptionFilterOptions; supportsSingleThreadExecutionRequests} -> (supportsBreakpointLocationsRequest, supportsClipboardContext, supportsSteppingGranularity, supportsInstructionBreakpoints, supportsExceptionFilterOptions, supportsSingleThreadExecutionRequests))
     (fun (supportsBreakpointLocationsRequest, supportsClipboardContext, supportsSteppingGranularity, supportsInstructionBreakpoints, supportsExceptionFilterOptions, supportsSingleThreadExecutionRequests) -> {supportsBreakpointLocationsRequest; supportsClipboardContext; supportsSteppingGranularity; supportsInstructionBreakpoints; supportsExceptionFilterOptions; supportsSingleThreadExecutionRequests})
     (obj6
    (opt "supportsBreakpointLocationsRequest" bool)
    (opt "supportsClipboardContext" bool)
    (opt "supportsSteppingGranularity" bool)
    (opt "supportsInstructionBreakpoints" bool)
    (opt "supportsExceptionFilterOptions" bool)
    (opt "supportsSingleThreadExecutionRequests" bool))


     let make ?supportsBreakpointLocationsRequest ?supportsClipboardContext ?supportsSteppingGranularity ?supportsInstructionBreakpoints ?supportsExceptionFilterOptions ?supportsSingleThreadExecutionRequests () =
    {supportsBreakpointLocationsRequest; supportsClipboardContext; supportsSteppingGranularity; supportsInstructionBreakpoints; supportsExceptionFilterOptions; supportsSingleThreadExecutionRequests}

     let supportsBreakpointLocationsRequest t = t.supportsBreakpointLocationsRequest
    let supportsClipboardContext t = t.supportsClipboardContext
    let supportsSteppingGranularity t = t.supportsSteppingGranularity
    let supportsInstructionBreakpoints t = t.supportsInstructionBreakpoints
    let supportsExceptionFilterOptions t = t.supportsExceptionFilterOptions
    let supportsSingleThreadExecutionRequests t = t.supportsSingleThreadExecutionRequests

     end


     type t = (Capabilities_0.t * (Capabilities_10.t * (Capabilities_20.t * Capabilities_30.t))) [@@deriving qcheck, eq]

     let enc =
     let open Data_encoding in
     merge_objs Capabilities_0.enc @@ merge_objs Capabilities_10.enc @@ merge_objs Capabilities_20.enc Capabilities_30.enc

     let make ?supportsConfigurationDoneRequest ?supportsFunctionBreakpoints ?supportsConditionalBreakpoints ?supportsHitConditionalBreakpoints ?supportsEvaluateForHovers ?supportsStepBack ?supportsSetVariable ?supportsRestartFrame ?supportsGotoTargetsRequest ?supportsStepInTargetsRequest ?supportsCompletionsRequest ?completionTriggerCharacters ?supportsModulesRequest ?supportsRestartRequest ?supportsExceptionOptions ?supportsValueFormattingOptions ?supportsExceptionInfoRequest ?supportTerminateDebuggee ?supportSuspendDebuggee ?supportsDelayedStackTraceLoading ?supportsLoadedSourcesRequest ?supportsLogPoints ?supportsTerminateThreadsRequest ?supportsSetExpression ?supportsTerminateRequest ?supportsDataBreakpoints ?supportsReadMemoryRequest ?supportsWriteMemoryRequest ?supportsDisassembleRequest ?supportsCancelRequest ?supportsBreakpointLocationsRequest ?supportsClipboardContext ?supportsSteppingGranularity ?supportsInstructionBreakpoints ?supportsExceptionFilterOptions ?supportsSingleThreadExecutionRequests () =
    let t0 = Capabilities_0.make ?supportsConfigurationDoneRequest ?supportsFunctionBreakpoints ?supportsConditionalBreakpoints ?supportsHitConditionalBreakpoints ?supportsEvaluateForHovers ?supportsStepBack ?supportsSetVariable ?supportsRestartFrame ?supportsGotoTargetsRequest ?supportsStepInTargetsRequest () in

    let t1 = Capabilities_10.make ?supportsCompletionsRequest ?completionTriggerCharacters ?supportsModulesRequest ?supportsRestartRequest ?supportsExceptionOptions ?supportsValueFormattingOptions ?supportsExceptionInfoRequest ?supportTerminateDebuggee ?supportSuspendDebuggee ?supportsDelayedStackTraceLoading () in

    let t2 = Capabilities_20.make ?supportsLoadedSourcesRequest ?supportsLogPoints ?supportsTerminateThreadsRequest ?supportsSetExpression ?supportsTerminateRequest ?supportsDataBreakpoints ?supportsReadMemoryRequest ?supportsWriteMemoryRequest ?supportsDisassembleRequest ?supportsCancelRequest () in

    let t3 = Capabilities_30.make ?supportsBreakpointLocationsRequest ?supportsClipboardContext ?supportsSteppingGranularity ?supportsInstructionBreakpoints ?supportsExceptionFilterOptions ?supportsSingleThreadExecutionRequests () in

    (t0 , (t1 , (t2 , t3)))

     let supportsConfigurationDoneRequest (_t0 , (_t1 , (_t2 , _t3))) = Capabilities_0.supportsConfigurationDoneRequest _t0
    let supportsFunctionBreakpoints (_t0 , (_t1 , (_t2 , _t3))) = Capabilities_0.supportsFunctionBreakpoints _t0
    let supportsConditionalBreakpoints (_t0 , (_t1 , (_t2 , _t3))) = Capabilities_0.supportsConditionalBreakpoints _t0
    let supportsHitConditionalBreakpoints (_t0 , (_t1 , (_t2 , _t3))) = Capabilities_0.supportsHitConditionalBreakpoints _t0
    let supportsEvaluateForHovers (_t0 , (_t1 , (_t2 , _t3))) = Capabilities_0.supportsEvaluateForHovers _t0
    let supportsStepBack (_t0 , (_t1 , (_t2 , _t3))) = Capabilities_0.supportsStepBack _t0
    let supportsSetVariable (_t0 , (_t1 , (_t2 , _t3))) = Capabilities_0.supportsSetVariable _t0
    let supportsRestartFrame (_t0 , (_t1 , (_t2 , _t3))) = Capabilities_0.supportsRestartFrame _t0
    let supportsGotoTargetsRequest (_t0 , (_t1 , (_t2 , _t3))) = Capabilities_0.supportsGotoTargetsRequest _t0
    let supportsStepInTargetsRequest (_t0 , (_t1 , (_t2 , _t3))) = Capabilities_0.supportsStepInTargetsRequest _t0
    let supportsCompletionsRequest (_t0 , (_t1 , (_t2 , _t3))) = Capabilities_10.supportsCompletionsRequest _t1
    let completionTriggerCharacters (_t0 , (_t1 , (_t2 , _t3))) = Capabilities_10.completionTriggerCharacters _t1
    let supportsModulesRequest (_t0 , (_t1 , (_t2 , _t3))) = Capabilities_10.supportsModulesRequest _t1
    let supportsRestartRequest (_t0 , (_t1 , (_t2 , _t3))) = Capabilities_10.supportsRestartRequest _t1
    let supportsExceptionOptions (_t0 , (_t1 , (_t2 , _t3))) = Capabilities_10.supportsExceptionOptions _t1
    let supportsValueFormattingOptions (_t0 , (_t1 , (_t2 , _t3))) = Capabilities_10.supportsValueFormattingOptions _t1
    let supportsExceptionInfoRequest (_t0 , (_t1 , (_t2 , _t3))) = Capabilities_10.supportsExceptionInfoRequest _t1
    let supportTerminateDebuggee (_t0 , (_t1 , (_t2 , _t3))) = Capabilities_10.supportTerminateDebuggee _t1
    let supportSuspendDebuggee (_t0 , (_t1 , (_t2 , _t3))) = Capabilities_10.supportSuspendDebuggee _t1
    let supportsDelayedStackTraceLoading (_t0 , (_t1 , (_t2 , _t3))) = Capabilities_10.supportsDelayedStackTraceLoading _t1
    let supportsLoadedSourcesRequest (_t0 , (_t1 , (_t2 , _t3))) = Capabilities_20.supportsLoadedSourcesRequest _t2
    let supportsLogPoints (_t0 , (_t1 , (_t2 , _t3))) = Capabilities_20.supportsLogPoints _t2
    let supportsTerminateThreadsRequest (_t0 , (_t1 , (_t2 , _t3))) = Capabilities_20.supportsTerminateThreadsRequest _t2
    let supportsSetExpression (_t0 , (_t1 , (_t2 , _t3))) = Capabilities_20.supportsSetExpression _t2
    let supportsTerminateRequest (_t0 , (_t1 , (_t2 , _t3))) = Capabilities_20.supportsTerminateRequest _t2
    let supportsDataBreakpoints (_t0 , (_t1 , (_t2 , _t3))) = Capabilities_20.supportsDataBreakpoints _t2
    let supportsReadMemoryRequest (_t0 , (_t1 , (_t2 , _t3))) = Capabilities_20.supportsReadMemoryRequest _t2
    let supportsWriteMemoryRequest (_t0 , (_t1 , (_t2 , _t3))) = Capabilities_20.supportsWriteMemoryRequest _t2
    let supportsDisassembleRequest (_t0 , (_t1 , (_t2 , _t3))) = Capabilities_20.supportsDisassembleRequest _t2
    let supportsCancelRequest (_t0 , (_t1 , (_t2 , _t3))) = Capabilities_20.supportsCancelRequest _t2
    let supportsBreakpointLocationsRequest (_t0 , (_t1 , (_t2 , _t3))) = Capabilities_30.supportsBreakpointLocationsRequest _t3
    let supportsClipboardContext (_t0 , (_t1 , (_t2 , _t3))) = Capabilities_30.supportsClipboardContext _t3
    let supportsSteppingGranularity (_t0 , (_t1 , (_t2 , _t3))) = Capabilities_30.supportsSteppingGranularity _t3
    let supportsInstructionBreakpoints (_t0 , (_t1 , (_t2 , _t3))) = Capabilities_30.supportsInstructionBreakpoints _t3
    let supportsExceptionFilterOptions (_t0 , (_t1 , (_t2 , _t3))) = Capabilities_30.supportsExceptionFilterOptions _t3
    let supportsSingleThreadExecutionRequests (_t0 , (_t1 , (_t2 , _t3))) = Capabilities_30.supportsSingleThreadExecutionRequests _t3

     end


     end

     module Request  = struct

     open Data

     type _ t =

           | Fmap : ('a -> 'b) -> ('a -> 'b) t

           (* request GADT items *)

     (* request constructors *)

     end

     module Response = struct

     open Data

     type _ t =

           | Fmap : ('a -> 'b) -> ('a -> 'b) t

           (* response GADT items *)

     (* response constructors *)

     end

     module Event = struct

     open Data

     type _ t =

           | Fmap : ('a -> 'b) -> ('a -> 'b) t

           (* event GADT items *)


           (* event constructors *)

     end |}]


let%expect_test "Check anyOf example" =
  let schema_js = Ezjsonm.from_channel @@ open_in "data/anyof.json" in
  let dfs = Dfs.make ~schema_js in
  let actual = render dfs Messages in
  Printf.printf "%s" actual;
  [%expect {|
    (* NOTE this file was autogenerated - do not modify by hand *)

     module RequestMessage = Dap_request_message
     module ResponseMessage = Dap_response_message
     module EventMessage = Dap_event_message

     module Data = struct

     include Dap_base

     (* supporting data modules *) module SomeExample : sig
    type t
     val equal : t -> t -> bool
     val enc : t Data_encoding.t
     val gen : t QCheck.Gen.t
     val arb : t QCheck.arbitrary
     val make : ?moduleId:IntString.t -> ?adapterData:Data_encoding.json -> unit -> t
     val moduleId : t -> (IntString.t option  )
    val adapterData : t -> (Data_encoding.json option  )
    end = struct
     type t = { moduleId: (IntString.t option  );
    adapterData: (Data_encoding.json option [@gen Gen.gen_json_opt] [@equal Eq.equal_json_opt]); } [@@deriving qcheck, eq]



     let enc =
     let open Data_encoding in
     (* SomeExample.t *)
             conv
     (fun {moduleId; adapterData} -> (moduleId, adapterData))
     (fun (moduleId, adapterData) -> {moduleId; adapterData})
     (obj2
    (opt "moduleId" IntString.enc)
    (opt "adapterData" json))


     let make ?moduleId ?adapterData () =
    {moduleId; adapterData}

     let moduleId t = t.moduleId
    let adapterData t = t.adapterData

     end


     end

     module Request  = struct

     open Data

     type _ t =

           | Fmap : ('a -> 'b) -> ('a -> 'b) t

           (* request GADT items *)

     (* request constructors *)

     end

     module Response = struct

     open Data

     type _ t =

           | Fmap : ('a -> 'b) -> ('a -> 'b) t

           (* response GADT items *)

     (* response constructors *)

     end

     module Event = struct

     open Data

     type _ t =

           | Fmap : ('a -> 'b) -> ('a -> 'b) t

           (* event GADT items *)


           (* event constructors *)

     end |}]

let%expect_test "Check oneOf example" =
  let schema_js = Ezjsonm.from_channel @@ open_in "data/restartRequest.json" in
  let dfs = Dfs.make ~schema_js in
  let actual = render dfs Messages in
  Printf.printf "%s" actual;
  [%expect {|
    (* NOTE this file was autogenerated - do not modify by hand *)

     module RequestMessage = Dap_request_message
     module ResponseMessage = Dap_response_message
     module EventMessage = Dap_event_message

     module Data = struct

     include Dap_base

     (* supporting data modules *)

     end

     module Request  = struct

     open Data

     type _ t =

           | Fmap : ('a -> 'b) -> ('a -> 'b) t

           (* request GADT items *) | RestartRequest : (Dap_commands.restart, RestartArguments.t option, Presence.opt) RequestMessage.t -> (Dap_commands.restart, RestartArguments.t option, Presence.opt) RequestMessage.t t

     (* request constructors *) let restartRequest req = RestartRequest req

     end

     module Response = struct

     open Data

     type _ t =

           | Fmap : ('a -> 'b) -> ('a -> 'b) t

           (* response GADT items *)

     (* response constructors *)

     end

     module Event = struct

     open Data

     type _ t =

           | Fmap : ('a -> 'b) -> ('a -> 'b) t

           (* event GADT items *)


           (* event constructors *)

     end |}]


let%expect_test "Check nullable example" =
  let schema_js = Ezjsonm.from_channel @@ open_in "data/nullableString.json" in
  let dfs = Dfs.make ~schema_js in
  let actual = render dfs Messages in
  Printf.printf "%s" actual;
  [%expect {|
    (* NOTE this file was autogenerated - do not modify by hand *)

     module RequestMessage = Dap_request_message
     module ResponseMessage = Dap_response_message
     module EventMessage = Dap_event_message

     module Data = struct

     include Dap_base

     (* supporting data modules *) module ExceptionDetails : sig
    type t
     val equal : t -> t -> bool
     val enc : t Data_encoding.t
     val gen : t QCheck.Gen.t
     val arb : t QCheck.arbitrary
     val make : ?message:string -> typeName:string option -> unit -> t
     val message : t -> (string option  )
    val typeName : t -> (string option  )
    end = struct
     type t = { message: (string option [@gen Gen.gen_utf8_str_opt] );
    typeName: (string option [@gen Gen.gen_utf8_str_opt] ); } [@@deriving qcheck, eq]



     let enc =
     let open Data_encoding in
     (* ExceptionDetails.t *)
             conv
     (fun {message; typeName} -> (message, typeName))
     (fun (message, typeName) -> {message; typeName})
     (obj2
    (opt "message" string)
    (req "typeName" (option string)))


     let make ?message ~typeName () =
    {message; typeName}

     let message t = t.message
    let typeName t = t.typeName

     end


     end

     module Request  = struct

     open Data

     type _ t =

           | Fmap : ('a -> 'b) -> ('a -> 'b) t

           (* request GADT items *)

     (* request constructors *)

     end

     module Response = struct

     open Data

     type _ t =

           | Fmap : ('a -> 'b) -> ('a -> 'b) t

           (* response GADT items *)

     (* response constructors *)

     end

     module Event = struct

     open Data

     type _ t =

           | Fmap : ('a -> 'b) -> ('a -> 'b) t

           (* event GADT items *)


           (* event constructors *)

     end |}]


let%expect_test "Check valueFormat example" =
  let schema_js = Ezjsonm.from_channel @@ open_in "data/valueFormatExample.json" in
  let dfs = Dfs.make ~schema_js in
  let actual = render dfs Messages in
  Printf.printf "%s" actual;
  [%expect {|
    (* NOTE this file was autogenerated - do not modify by hand *)

     module RequestMessage = Dap_request_message
     module ResponseMessage = Dap_response_message
     module EventMessage = Dap_event_message

     module Data = struct

     include Dap_base

     (* supporting data modules *) module ValueFormat : sig
    type t
     val equal : t -> t -> bool
     val enc : t Data_encoding.t
     val gen : t QCheck.Gen.t
     val arb : t QCheck.arbitrary
     val make : ?hex:bool -> unit -> t
     val hex : t -> (bool option  )
    end = struct
     type t = { hex: (bool option  ); } [@@deriving qcheck, eq]



     let enc =
     let open Data_encoding in
     (* ValueFormat.t *)
             conv
     (fun {hex} -> hex)
     (fun hex -> {hex})
     (obj1
    (opt "hex" bool))


     let make ?hex () =
    {hex}

     let hex t = t.hex

     end


    module StackFrameFormat : sig
    type t
     val equal : t -> t -> bool
     val enc : t Data_encoding.t
     val gen : t QCheck.Gen.t
     val arb : t QCheck.arbitrary
     val make : ?hex:bool -> ?parameters:bool -> ?parameterTypes:bool -> ?parameterNames:bool -> ?parameterValues:bool -> ?line:bool -> ?module_:bool -> ?includeAll:bool -> unit -> t
     val hex : t -> (bool option  )
    val parameters : t -> (bool option  )
    val parameterTypes : t -> (bool option  )
    val parameterNames : t -> (bool option  )
    val parameterValues : t -> (bool option  )
    val line : t -> (bool option  )
    val module_ : t -> (bool option  )
    val includeAll : t -> (bool option  )
    end = struct
     type t = { hex: (bool option  );
    parameters: (bool option  );
    parameterTypes: (bool option  );
    parameterNames: (bool option  );
    parameterValues: (bool option  );
    line: (bool option  );
    module_: (bool option  );
    includeAll: (bool option  ); } [@@deriving qcheck, eq]



     let enc =
     let open Data_encoding in
     (* StackFrameFormat.t *)
             conv
     (fun {hex; parameters; parameterTypes; parameterNames; parameterValues; line; module_; includeAll} -> (hex, parameters, parameterTypes, parameterNames, parameterValues, line, module_, includeAll))
     (fun (hex, parameters, parameterTypes, parameterNames, parameterValues, line, module_, includeAll) -> {hex; parameters; parameterTypes; parameterNames; parameterValues; line; module_; includeAll})
     (obj8
    (opt "hex" bool)
    (opt "parameters" bool)
    (opt "parameterTypes" bool)
    (opt "parameterNames" bool)
    (opt "parameterValues" bool)
    (opt "line" bool)
    (opt "module" bool)
    (opt "includeAll" bool))


     let make ?hex ?parameters ?parameterTypes ?parameterNames ?parameterValues ?line ?module_ ?includeAll () =
    {hex; parameters; parameterTypes; parameterNames; parameterValues; line; module_; includeAll}

     let hex t = t.hex
    let parameters t = t.parameters
    let parameterTypes t = t.parameterTypes
    let parameterNames t = t.parameterNames
    let parameterValues t = t.parameterValues
    let line t = t.line
    let module_ t = t.module_
    let includeAll t = t.includeAll

     end


     end

     module Request  = struct

     open Data

     type _ t =

           | Fmap : ('a -> 'b) -> ('a -> 'b) t

           (* request GADT items *)

     (* request constructors *)

     end

     module Response = struct

     open Data

     type _ t =

           | Fmap : ('a -> 'b) -> ('a -> 'b) t

           (* response GADT items *)

     (* response constructors *)

     end

     module Event = struct

     open Data

     type _ t =

           | Fmap : ('a -> 'b) -> ('a -> 'b) t

           (* event GADT items *)


           (* event constructors *)

     end |}]

let%expect_test "Check empty example" =
  let schema_js = Ezjsonm.from_channel @@ open_in "data/emptyObject.json" in
  let dfs = Dfs.make ~schema_js in
  let actual = render dfs Messages in
  Printf.printf "%s" actual;
  [%expect {|
    (* NOTE this file was autogenerated - do not modify by hand *)

     module RequestMessage = Dap_request_message
     module ResponseMessage = Dap_response_message
     module EventMessage = Dap_event_message

     module Data = struct

     include Dap_base

     (* supporting data modules *) module ConfigurationDoneArguments : sig
     type t
     val equal : t -> t -> bool
     val enc : t Data_encoding.t
     val gen : t QCheck.Gen.t
     val arb : t QCheck.arbitrary
     val make : unit -> t
     end = struct
     type t = unit [@@deriving qcheck, eq]

     let enc = Data_encoding.empty

     let make () = ()

     end




     end

     module Request  = struct

     open Data

     type _ t =

           | Fmap : ('a -> 'b) -> ('a -> 'b) t

           (* request GADT items *) | ConfigurationDoneRequest : (Dap_commands.configurationDone, ConfigurationDoneArguments.t option, Presence.opt) RequestMessage.t -> (Dap_commands.configurationDone, ConfigurationDoneArguments.t option, Presence.opt) RequestMessage.t t

     (* request constructors *) let configurationDoneRequest req = ConfigurationDoneRequest req

     end

     module Response = struct

     open Data

     type _ t =

           | Fmap : ('a -> 'b) -> ('a -> 'b) t

           (* response GADT items *)

     (* response constructors *)

     end

     module Event = struct

     open Data

     type _ t =

           | Fmap : ('a -> 'b) -> ('a -> 'b) t

           (* event GADT items *)


           (* event constructors *)

     end |}]


let%expect_test "Check LaunchResponse empty body  example" =
  let schema_js = Ezjsonm.from_channel @@ open_in "data/launchResponseEmptyExample.json" in
  let dfs = Dfs.make ~schema_js in
  let actual = render dfs Messages in
  Printf.printf "%s" actual;
  [%expect {|
    (* NOTE this file was autogenerated - do not modify by hand *)

     module RequestMessage = Dap_request_message
     module ResponseMessage = Dap_response_message
     module EventMessage = Dap_event_message

     module Data = struct

     include Dap_base

     (* supporting data modules *)

     end

     module Request  = struct

     open Data

     type _ t =

           | Fmap : ('a -> 'b) -> ('a -> 'b) t

           (* request GADT items *)

     (* request constructors *)

     end

     module Response = struct

     open Data

     type _ t =

           | Fmap : ('a -> 'b) -> ('a -> 'b) t

           (* response GADT items *) | LaunchResponse : (Dap_commands.launch, EmptyObject.t option, Presence.opt) ResponseMessage.t -> (Dap_commands.launch, EmptyObject.t option, Presence.opt) ResponseMessage.t t

     (* response constructors *) let launchResponse resp = LaunchResponse resp

     end

     module Event = struct

     open Data

     type _ t =

           | Fmap : ('a -> 'b) -> ('a -> 'b) t

           (* event GADT items *)


           (* event constructors *)

     end |}]
