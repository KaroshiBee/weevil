(* NOTE this file was autogenerated - do not modify by hand *)

 include Dap_base

 module RequestMessage = Dap_request
 module ResponseMessage = Dap_response
 module EventMessage = Dap_event

 module Message : sig 
type t 
 val enc : t Data_encoding.t 
 val make : id:int -> format:string -> ?variables:Data_encoding.json -> ?sendTelemetry:bool -> ?showUser:bool -> ?url:string -> ?urlLabel:string -> unit -> t
end = struct 
 type t = { id: int;
format: string;
variables: Data_encoding.json option;
sendTelemetry: bool option;
showUser: bool option;
url: string option;
urlLabel: string option; }

 let enc = 
 let open Data_encoding in 
 (* Message.t *)
         conv 
 (fun {id; format; variables; sendTelemetry; showUser; url; urlLabel} -> (id, format, variables, sendTelemetry, showUser, url, urlLabel))
 (fun (id, format, variables, sendTelemetry, showUser, url, urlLabel) -> {id; format; variables; sendTelemetry; showUser; url; urlLabel})
 (obj7
(req "id" int31)
(req "format" string)
(opt "variables" json)
(opt "sendTelemetry" bool)
(opt "showUser" bool)
(opt "url" string)
(opt "urlLabel" string))


 let make ~id ~format ?variables ?sendTelemetry ?showUser ?url ?urlLabel () = 
{id; format; variables; sendTelemetry; showUser; url; urlLabel}

 end


module ErrorResponse_body : sig 
type t 
 val enc : t Data_encoding.t 
 val make : ?error:Message.t -> unit -> t
end = struct 
 type t = { error: Message.t option; }

 let enc = 
 let open Data_encoding in 
 (* ErrorResponse_body.t *)
         conv 
 (fun {error} -> error)
 (fun error -> {error})
 (obj1
(opt "error" Message.enc))


 let make ?error () = 
{error}

 end




module CancelArguments : sig 
type t 
 val enc : t Data_encoding.t 
 val make : ?requestId:int -> ?progressId:string -> unit -> t
end = struct 
 type t = { requestId: int option;
progressId: string option; }

 let enc = 
 let open Data_encoding in 
 (* CancelArguments.t *)
         conv 
 (fun {requestId; progressId} -> (requestId, progressId))
 (fun (requestId, progressId) -> {requestId; progressId})
 (obj2
(opt "requestId" int31)
(opt "progressId" string))


 let make ?requestId ?progressId () = 
{requestId; progressId}

 end








(* dont bother with a sig for enums, the inferred one is fine *)
 module StoppedEvent_body_reason = struct 
 type t = Step | Breakpoint | Exception | Pause | Entry | Goto | Function_breakpoint | Data_breakpoint | Instruction_breakpoint | Other of string 

 let enc = 
 let open Data_encoding in 
 conv 
 (function Step -> "step" | Breakpoint -> "breakpoint" | Exception -> "exception" | Pause -> "pause" | Entry -> "entry" | Goto -> "goto" | Function_breakpoint -> "function breakpoint" | Data_breakpoint -> "data breakpoint" | Instruction_breakpoint -> "instruction breakpoint" | Other s -> s)
 (function "step" -> Step | "breakpoint" -> Breakpoint | "exception" -> Exception | "pause" -> Pause | "entry" -> Entry | "goto" -> Goto | "function breakpoint" -> Function_breakpoint | "data breakpoint" -> Data_breakpoint | "instruction breakpoint" -> Instruction_breakpoint | _ as s -> Other s)
 string

 end


module StoppedEvent_body : sig 
type t 
 val enc : t Data_encoding.t 
 val make : reason:StoppedEvent_body_reason.t -> ?description:string -> ?threadId:int -> ?preserveFocusHint:bool -> ?text:string -> ?allThreadsStopped:bool -> ?hitBreakpointIds:int list -> unit -> t
end = struct 
 type t = { reason: StoppedEvent_body_reason.t;
description: string option;
threadId: int option;
preserveFocusHint: bool option;
text: string option;
allThreadsStopped: bool option;
hitBreakpointIds: int list option; }

 let enc = 
 let open Data_encoding in 
 (* StoppedEvent_body.t *)
         conv 
 (fun {reason; description; threadId; preserveFocusHint; text; allThreadsStopped; hitBreakpointIds} -> (reason, description, threadId, preserveFocusHint, text, allThreadsStopped, hitBreakpointIds))
 (fun (reason, description, threadId, preserveFocusHint, text, allThreadsStopped, hitBreakpointIds) -> {reason; description; threadId; preserveFocusHint; text; allThreadsStopped; hitBreakpointIds})
 (obj7
(req "reason" StoppedEvent_body_reason.enc)
(opt "description" string)
(opt "threadId" int31)
(opt "preserveFocusHint" bool)
(opt "text" string)
(opt "allThreadsStopped" bool)
(opt "hitBreakpointIds" (list int31)))


 let make ~reason ?description ?threadId ?preserveFocusHint ?text ?allThreadsStopped ?hitBreakpointIds () = 
{reason; description; threadId; preserveFocusHint; text; allThreadsStopped; hitBreakpointIds}

 end




module ContinuedEvent_body : sig 
type t 
 val enc : t Data_encoding.t 
 val make : threadId:int -> ?allThreadsContinued:bool -> unit -> t
end = struct 
 type t = { threadId: int;
allThreadsContinued: bool option; }

 let enc = 
 let open Data_encoding in 
 (* ContinuedEvent_body.t *)
         conv 
 (fun {threadId; allThreadsContinued} -> (threadId, allThreadsContinued))
 (fun (threadId, allThreadsContinued) -> {threadId; allThreadsContinued})
 (obj2
(req "threadId" int31)
(opt "allThreadsContinued" bool))


 let make ~threadId ?allThreadsContinued () = 
{threadId; allThreadsContinued}

 end




module ExitedEvent_body : sig 
type t 
 val enc : t Data_encoding.t 
 val make : exitCode:int -> unit -> t
end = struct 
 type t = { exitCode: int; }

 let enc = 
 let open Data_encoding in 
 (* ExitedEvent_body.t *)
         conv 
 (fun {exitCode} -> exitCode)
 (fun exitCode -> {exitCode})
 (obj1
(req "exitCode" int31))


 let make ~exitCode () = 
{exitCode}

 end




module TerminatedEvent_body : sig 
type t 
 val enc : t Data_encoding.t 
 val make : ?restart:Data_encoding.json -> unit -> t
end = struct 
 type t = { restart: Data_encoding.json option; }

 let enc = 
 let open Data_encoding in 
 (* TerminatedEvent_body.t *)
         conv 
 (fun {restart} -> restart)
 (fun restart -> {restart})
 (obj1
(opt "restart" json))


 let make ?restart () = 
{restart}

 end




(* dont bother with a sig for enums, the inferred one is fine *)
 module ThreadEvent_body_reason = struct 
 type t = Started | Exited | Other of string 

 let enc = 
 let open Data_encoding in 
 conv 
 (function Started -> "started" | Exited -> "exited" | Other s -> s)
 (function "started" -> Started | "exited" -> Exited | _ as s -> Other s)
 string

 end


module ThreadEvent_body : sig 
type t 
 val enc : t Data_encoding.t 
 val make : reason:ThreadEvent_body_reason.t -> threadId:int -> unit -> t
end = struct 
 type t = { reason: ThreadEvent_body_reason.t;
threadId: int; }

 let enc = 
 let open Data_encoding in 
 (* ThreadEvent_body.t *)
         conv 
 (fun {reason; threadId} -> (reason, threadId))
 (fun (reason, threadId) -> {reason; threadId})
 (obj2
(req "reason" ThreadEvent_body_reason.enc)
(req "threadId" int31))


 let make ~reason ~threadId () = 
{reason; threadId}

 end




(* dont bother with a sig for enums, the inferred one is fine *)
 module OutputEvent_body_category = struct 
 type t = Console | Important | Stdout | Stderr | Telemetry | Other of string 

 let enc = 
 let open Data_encoding in 
 conv 
 (function Console -> "console" | Important -> "important" | Stdout -> "stdout" | Stderr -> "stderr" | Telemetry -> "telemetry" | Other s -> s)
 (function "console" -> Console | "important" -> Important | "stdout" -> Stdout | "stderr" -> Stderr | "telemetry" -> Telemetry | _ as s -> Other s)
 string

 end


(* dont bother with a sig for enums, the inferred one is fine *)
 module OutputEvent_body_group = struct 
 type t = Start | StartCollapsed | End 

 let enc = 
 let open Data_encoding in 
 conv 
 (function Start -> "start" | StartCollapsed -> "startCollapsed" | End -> "end")
 (function "start" -> Start | "startCollapsed" -> StartCollapsed | "end" -> End | _ -> failwith "OutputEvent_body_group")
 string

 end


(* dont bother with a sig for enums, the inferred one is fine *)
 module Source_presentationHint = struct 
 type t = Normal | Emphasize | Deemphasize 

 let enc = 
 let open Data_encoding in 
 conv 
 (function Normal -> "normal" | Emphasize -> "emphasize" | Deemphasize -> "deemphasize")
 (function "normal" -> Normal | "emphasize" -> Emphasize | "deemphasize" -> Deemphasize | _ -> failwith "Source_presentationHint")
 string

 end


(* dont bother with a sig for enums, the inferred one is fine *)
 module ChecksumAlgorithm = struct 
 type t = MD5 | SHA1 | SHA256 | Timestamp 

 let enc = 
 let open Data_encoding in 
 conv 
 (function MD5 -> "MD5" | SHA1 -> "SHA1" | SHA256 -> "SHA256" | Timestamp -> "timestamp")
 (function "MD5" -> MD5 | "SHA1" -> SHA1 | "SHA256" -> SHA256 | "timestamp" -> Timestamp | _ -> failwith "ChecksumAlgorithm")
 string

 end


module Checksum : sig 
type t 
 val enc : t Data_encoding.t 
 val make : algorithm:ChecksumAlgorithm.t -> checksum:string -> unit -> t
end = struct 
 type t = { algorithm: ChecksumAlgorithm.t;
checksum: string; }

 let enc = 
 let open Data_encoding in 
 (* Checksum.t *)
         conv 
 (fun {algorithm; checksum} -> (algorithm, checksum))
 (fun (algorithm, checksum) -> {algorithm; checksum})
 (obj2
(req "algorithm" ChecksumAlgorithm.enc)
(req "checksum" string))


 let make ~algorithm ~checksum () = 
{algorithm; checksum}

 end


module Source : sig 
type t 
 val enc : t Data_encoding.t 
 val make : ?name:string -> ?path:string -> ?sourceReference:int -> ?presentationHint:Source_presentationHint.t -> ?origin:string -> ?sources:t list -> ?adapterData:Data_encoding.json -> ?checksums:Checksum.t list -> unit -> t
end = struct 
 type t = { name: string option;
path: string option;
sourceReference: int option;
presentationHint: Source_presentationHint.t option;
origin: string option;
sources: t list option;
adapterData: Data_encoding.json option;
checksums: Checksum.t list option; }

 let enc = 
 let open Data_encoding in 
 mu "Source.t" 
 ( fun e -> 
 conv 
 (fun {name; path; sourceReference; presentationHint; origin; sources; adapterData; checksums} -> (name, path, sourceReference, presentationHint, origin, sources, adapterData, checksums))
 (fun (name, path, sourceReference, presentationHint, origin, sources, adapterData, checksums) -> {name; path; sourceReference; presentationHint; origin; sources; adapterData; checksums})
 (obj8
(opt "name" string)
(opt "path" string)
(opt "sourceReference" int31)
(opt "presentationHint" Source_presentationHint.enc)
(opt "origin" string)
(opt "sources" (list e))
(opt "adapterData" json)
(opt "checksums" (list Checksum.enc)))
)

 let make ?name ?path ?sourceReference ?presentationHint ?origin ?sources ?adapterData ?checksums () = 
{name; path; sourceReference; presentationHint; origin; sources; adapterData; checksums}

 end


module OutputEvent_body : sig 
type t 
 val enc : t Data_encoding.t 
 val make : ?category:OutputEvent_body_category.t -> output:string -> ?group:OutputEvent_body_group.t -> ?variablesReference:int -> ?source:Source.t -> ?line:int -> ?column:int -> ?data:Data_encoding.json -> unit -> t
end = struct 
 type t = { category: OutputEvent_body_category.t option;
output: string;
group: OutputEvent_body_group.t option;
variablesReference: int option;
source: Source.t option;
line: int option;
column: int option;
data: Data_encoding.json option; }

 let enc = 
 let open Data_encoding in 
 (* OutputEvent_body.t *)
         conv 
 (fun {category; output; group; variablesReference; source; line; column; data} -> (category, output, group, variablesReference, source, line, column, data))
 (fun (category, output, group, variablesReference, source, line, column, data) -> {category; output; group; variablesReference; source; line; column; data})
 (obj8
(opt "category" OutputEvent_body_category.enc)
(req "output" string)
(opt "group" OutputEvent_body_group.enc)
(opt "variablesReference" int31)
(opt "source" Source.enc)
(opt "line" int31)
(opt "column" int31)
(opt "data" json))


 let make ?category ~output ?group ?variablesReference ?source ?line ?column ?data () = 
{category; output; group; variablesReference; source; line; column; data}

 end




(* dont bother with a sig for enums, the inferred one is fine *)
 module BreakpointEvent_body_reason = struct 
 type t = Changed | New | Removed | Other of string 

 let enc = 
 let open Data_encoding in 
 conv 
 (function Changed -> "changed" | New -> "new" | Removed -> "removed" | Other s -> s)
 (function "changed" -> Changed | "new" -> New | "removed" -> Removed | _ as s -> Other s)
 string

 end


module Breakpoint : sig 
type t 
 val enc : t Data_encoding.t 
 val make : ?id:int -> verified:bool -> ?message:string -> ?source:Source.t -> ?line:int -> ?column:int -> ?endLine:int -> ?endColumn:int -> ?instructionReference:string -> ?offset:int -> unit -> t
end = struct 
 type t = { id: int option;
verified: bool;
message: string option;
source: Source.t option;
line: int option;
column: int option;
endLine: int option;
endColumn: int option;
instructionReference: string option;
offset: int option; }

 let enc = 
 let open Data_encoding in 
 (* Breakpoint.t *)
         conv 
 (fun {id; verified; message; source; line; column; endLine; endColumn; instructionReference; offset} -> (id, verified, message, source, line, column, endLine, endColumn, instructionReference, offset))
 (fun (id, verified, message, source, line, column, endLine, endColumn, instructionReference, offset) -> {id; verified; message; source; line; column; endLine; endColumn; instructionReference; offset})
 (obj10
(opt "id" int31)
(req "verified" bool)
(opt "message" string)
(opt "source" Source.enc)
(opt "line" int31)
(opt "column" int31)
(opt "endLine" int31)
(opt "endColumn" int31)
(opt "instructionReference" string)
(opt "offset" int31))


 let make ?id ~verified ?message ?source ?line ?column ?endLine ?endColumn ?instructionReference ?offset () = 
{id; verified; message; source; line; column; endLine; endColumn; instructionReference; offset}

 end


module BreakpointEvent_body : sig 
type t 
 val enc : t Data_encoding.t 
 val make : reason:BreakpointEvent_body_reason.t -> breakpoint:Breakpoint.t -> unit -> t
end = struct 
 type t = { reason: BreakpointEvent_body_reason.t;
breakpoint: Breakpoint.t; }

 let enc = 
 let open Data_encoding in 
 (* BreakpointEvent_body.t *)
         conv 
 (fun {reason; breakpoint} -> (reason, breakpoint))
 (fun (reason, breakpoint) -> {reason; breakpoint})
 (obj2
(req "reason" BreakpointEvent_body_reason.enc)
(req "breakpoint" Breakpoint.enc))


 let make ~reason ~breakpoint () = 
{reason; breakpoint}

 end




(* dont bother with a sig for enums, the inferred one is fine *)
 module ModuleEvent_body_reason = struct 
 type t = New | Changed | Removed 

 let enc = 
 let open Data_encoding in 
 conv 
 (function New -> "new" | Changed -> "changed" | Removed -> "removed")
 (function "new" -> New | "changed" -> Changed | "removed" -> Removed | _ -> failwith "ModuleEvent_body_reason")
 string

 end


module Module_ : sig 
type t 
 val enc : t Data_encoding.t 
 val make : id:IntString.t -> name:string -> ?path:string -> ?isOptimized:bool -> ?isUserCode:bool -> ?version:string -> ?symbolStatus:string -> ?symbolFilePath:string -> ?dateTimeStamp:string -> ?addressRange:string -> unit -> t
end = struct 
 type t = { id: IntString.t;
name: string;
path: string option;
isOptimized: bool option;
isUserCode: bool option;
version: string option;
symbolStatus: string option;
symbolFilePath: string option;
dateTimeStamp: string option;
addressRange: string option; }

 let enc = 
 let open Data_encoding in 
 (* Module_.t *)
         conv 
 (fun {id; name; path; isOptimized; isUserCode; version; symbolStatus; symbolFilePath; dateTimeStamp; addressRange} -> (id, name, path, isOptimized, isUserCode, version, symbolStatus, symbolFilePath, dateTimeStamp, addressRange))
 (fun (id, name, path, isOptimized, isUserCode, version, symbolStatus, symbolFilePath, dateTimeStamp, addressRange) -> {id; name; path; isOptimized; isUserCode; version; symbolStatus; symbolFilePath; dateTimeStamp; addressRange})
 (obj10
(req "id" IntString.enc)
(req "name" string)
(opt "path" string)
(opt "isOptimized" bool)
(opt "isUserCode" bool)
(opt "version" string)
(opt "symbolStatus" string)
(opt "symbolFilePath" string)
(opt "dateTimeStamp" string)
(opt "addressRange" string))


 let make ~id ~name ?path ?isOptimized ?isUserCode ?version ?symbolStatus ?symbolFilePath ?dateTimeStamp ?addressRange () = 
{id; name; path; isOptimized; isUserCode; version; symbolStatus; symbolFilePath; dateTimeStamp; addressRange}

 end


module ModuleEvent_body : sig 
type t 
 val enc : t Data_encoding.t 
 val make : reason:ModuleEvent_body_reason.t -> module_:Module_.t -> unit -> t
end = struct 
 type t = { reason: ModuleEvent_body_reason.t;
module_: Module_.t; }

 let enc = 
 let open Data_encoding in 
 (* ModuleEvent_body.t *)
         conv 
 (fun {reason; module_} -> (reason, module_))
 (fun (reason, module_) -> {reason; module_})
 (obj2
(req "reason" ModuleEvent_body_reason.enc)
(req "module" Module_.enc))


 let make ~reason ~module_ () = 
{reason; module_}

 end




(* dont bother with a sig for enums, the inferred one is fine *)
 module LoadedSourceEvent_body_reason = struct 
 type t = New | Changed | Removed 

 let enc = 
 let open Data_encoding in 
 conv 
 (function New -> "new" | Changed -> "changed" | Removed -> "removed")
 (function "new" -> New | "changed" -> Changed | "removed" -> Removed | _ -> failwith "LoadedSourceEvent_body_reason")
 string

 end


module LoadedSourceEvent_body : sig 
type t 
 val enc : t Data_encoding.t 
 val make : reason:LoadedSourceEvent_body_reason.t -> source:Source.t -> unit -> t
end = struct 
 type t = { reason: LoadedSourceEvent_body_reason.t;
source: Source.t; }

 let enc = 
 let open Data_encoding in 
 (* LoadedSourceEvent_body.t *)
         conv 
 (fun {reason; source} -> (reason, source))
 (fun (reason, source) -> {reason; source})
 (obj2
(req "reason" LoadedSourceEvent_body_reason.enc)
(req "source" Source.enc))


 let make ~reason ~source () = 
{reason; source}

 end




(* dont bother with a sig for enums, the inferred one is fine *)
 module ProcessEvent_body_startMethod = struct 
 type t = Launch | Attach | AttachForSuspendedLaunch 

 let enc = 
 let open Data_encoding in 
 conv 
 (function Launch -> "launch" | Attach -> "attach" | AttachForSuspendedLaunch -> "attachForSuspendedLaunch")
 (function "launch" -> Launch | "attach" -> Attach | "attachForSuspendedLaunch" -> AttachForSuspendedLaunch | _ -> failwith "ProcessEvent_body_startMethod")
 string

 end


module ProcessEvent_body : sig 
type t 
 val enc : t Data_encoding.t 
 val make : name:string -> ?systemProcessId:int -> ?isLocalProcess:bool -> ?startMethod:ProcessEvent_body_startMethod.t -> ?pointerSize:int -> unit -> t
end = struct 
 type t = { name: string;
systemProcessId: int option;
isLocalProcess: bool option;
startMethod: ProcessEvent_body_startMethod.t option;
pointerSize: int option; }

 let enc = 
 let open Data_encoding in 
 (* ProcessEvent_body.t *)
         conv 
 (fun {name; systemProcessId; isLocalProcess; startMethod; pointerSize} -> (name, systemProcessId, isLocalProcess, startMethod, pointerSize))
 (fun (name, systemProcessId, isLocalProcess, startMethod, pointerSize) -> {name; systemProcessId; isLocalProcess; startMethod; pointerSize})
 (obj5
(req "name" string)
(opt "systemProcessId" int31)
(opt "isLocalProcess" bool)
(opt "startMethod" ProcessEvent_body_startMethod.enc)
(opt "pointerSize" int31))


 let make ~name ?systemProcessId ?isLocalProcess ?startMethod ?pointerSize () = 
{name; systemProcessId; isLocalProcess; startMethod; pointerSize}

 end




module ExceptionBreakpointsFilter : sig 
type t 
 val enc : t Data_encoding.t 
 val make : filter:string -> label:string -> ?description:string -> ?default:bool -> ?supportsCondition:bool -> ?conditionDescription:string -> unit -> t
end = struct 
 type t = { filter: string;
label: string;
description: string option;
default: bool option;
supportsCondition: bool option;
conditionDescription: string option; }

 let enc = 
 let open Data_encoding in 
 (* ExceptionBreakpointsFilter.t *)
         conv 
 (fun {filter; label; description; default; supportsCondition; conditionDescription} -> (filter, label, description, default, supportsCondition, conditionDescription))
 (fun (filter, label, description, default, supportsCondition, conditionDescription) -> {filter; label; description; default; supportsCondition; conditionDescription})
 (obj6
(req "filter" string)
(req "label" string)
(opt "description" string)
(opt "default" bool)
(opt "supportsCondition" bool)
(opt "conditionDescription" string))


 let make ~filter ~label ?description ?default ?supportsCondition ?conditionDescription () = 
{filter; label; description; default; supportsCondition; conditionDescription}

 end


(* dont bother with a sig for enums, the inferred one is fine *)
 module ColumnDescriptor_type_ = struct 
 type t = String | Number | Boolean | UnixTimestampUTC 

 let enc = 
 let open Data_encoding in 
 conv 
 (function String -> "string" | Number -> "number" | Boolean -> "boolean" | UnixTimestampUTC -> "unixTimestampUTC")
 (function "string" -> String | "number" -> Number | "boolean" -> Boolean | "unixTimestampUTC" -> UnixTimestampUTC | _ -> failwith "ColumnDescriptor_type_")
 string

 end


module ColumnDescriptor : sig 
type t 
 val enc : t Data_encoding.t 
 val make : attributeName:string -> label:string -> ?format:string -> ?type_:ColumnDescriptor_type_.t -> ?width:int -> unit -> t
end = struct 
 type t = { attributeName: string;
label: string;
format: string option;
type_: ColumnDescriptor_type_.t option;
width: int option; }

 let enc = 
 let open Data_encoding in 
 (* ColumnDescriptor.t *)
         conv 
 (fun {attributeName; label; format; type_; width} -> (attributeName, label, format, type_, width))
 (fun (attributeName, label, format, type_, width) -> {attributeName; label; format; type_; width})
 (obj5
(req "attributeName" string)
(req "label" string)
(opt "format" string)
(opt "type" ColumnDescriptor_type_.enc)
(opt "width" int31))


 let make ~attributeName ~label ?format ?type_ ?width () = 
{attributeName; label; format; type_; width}

 end


module Capabilities : sig 
type t 
 val enc : t Data_encoding.t 
 val make : ?supportsConfigurationDoneRequest:bool -> ?supportsFunctionBreakpoints:bool -> ?supportsConditionalBreakpoints:bool -> ?supportsHitConditionalBreakpoints:bool -> ?supportsEvaluateForHovers:bool -> ?exceptionBreakpointFilters:ExceptionBreakpointsFilter.t list -> ?supportsStepBack:bool -> ?supportsSetVariable:bool -> ?supportsRestartFrame:bool -> ?supportsGotoTargetsRequest:bool -> ?supportsStepInTargetsRequest:bool -> ?supportsCompletionsRequest:bool -> ?completionTriggerCharacters:string list -> ?supportsModulesRequest:bool -> ?additionalModuleColumns:ColumnDescriptor.t list -> ?supportedChecksumAlgorithms:ChecksumAlgorithm.t list -> ?supportsRestartRequest:bool -> ?supportsExceptionOptions:bool -> ?supportsValueFormattingOptions:bool -> ?supportsExceptionInfoRequest:bool -> ?supportTerminateDebuggee:bool -> ?supportSuspendDebuggee:bool -> ?supportsDelayedStackTraceLoading:bool -> ?supportsLoadedSourcesRequest:bool -> ?supportsLogPoints:bool -> ?supportsTerminateThreadsRequest:bool -> ?supportsSetExpression:bool -> ?supportsTerminateRequest:bool -> ?supportsDataBreakpoints:bool -> ?supportsReadMemoryRequest:bool -> ?supportsWriteMemoryRequest:bool -> ?supportsDisassembleRequest:bool -> ?supportsCancelRequest:bool -> ?supportsBreakpointLocationsRequest:bool -> ?supportsClipboardContext:bool -> ?supportsSteppingGranularity:bool -> ?supportsInstructionBreakpoints:bool -> ?supportsExceptionFilterOptions:bool -> ?supportsSingleThreadExecutionRequests:bool -> unit -> t
end = struct 
 module Capabilities_0 : sig 
type t 
 val enc : t Data_encoding.t 
 val make : ?supportsConfigurationDoneRequest:bool -> ?supportsFunctionBreakpoints:bool -> ?supportsConditionalBreakpoints:bool -> ?supportsHitConditionalBreakpoints:bool -> ?supportsEvaluateForHovers:bool -> ?exceptionBreakpointFilters:ExceptionBreakpointsFilter.t list -> ?supportsStepBack:bool -> ?supportsSetVariable:bool -> ?supportsRestartFrame:bool -> ?supportsGotoTargetsRequest:bool -> unit -> t
end = struct 
 type t = { supportsConfigurationDoneRequest: bool option;
supportsFunctionBreakpoints: bool option;
supportsConditionalBreakpoints: bool option;
supportsHitConditionalBreakpoints: bool option;
supportsEvaluateForHovers: bool option;
exceptionBreakpointFilters: ExceptionBreakpointsFilter.t list option;
supportsStepBack: bool option;
supportsSetVariable: bool option;
supportsRestartFrame: bool option;
supportsGotoTargetsRequest: bool option; }

 let enc = 
 let open Data_encoding in 
 (* Capabilities_0.t *)
         conv 
 (fun {supportsConfigurationDoneRequest; supportsFunctionBreakpoints; supportsConditionalBreakpoints; supportsHitConditionalBreakpoints; supportsEvaluateForHovers; exceptionBreakpointFilters; supportsStepBack; supportsSetVariable; supportsRestartFrame; supportsGotoTargetsRequest} -> (supportsConfigurationDoneRequest, supportsFunctionBreakpoints, supportsConditionalBreakpoints, supportsHitConditionalBreakpoints, supportsEvaluateForHovers, exceptionBreakpointFilters, supportsStepBack, supportsSetVariable, supportsRestartFrame, supportsGotoTargetsRequest))
 (fun (supportsConfigurationDoneRequest, supportsFunctionBreakpoints, supportsConditionalBreakpoints, supportsHitConditionalBreakpoints, supportsEvaluateForHovers, exceptionBreakpointFilters, supportsStepBack, supportsSetVariable, supportsRestartFrame, supportsGotoTargetsRequest) -> {supportsConfigurationDoneRequest; supportsFunctionBreakpoints; supportsConditionalBreakpoints; supportsHitConditionalBreakpoints; supportsEvaluateForHovers; exceptionBreakpointFilters; supportsStepBack; supportsSetVariable; supportsRestartFrame; supportsGotoTargetsRequest})
 (obj10
(opt "supportsConfigurationDoneRequest" bool)
(opt "supportsFunctionBreakpoints" bool)
(opt "supportsConditionalBreakpoints" bool)
(opt "supportsHitConditionalBreakpoints" bool)
(opt "supportsEvaluateForHovers" bool)
(opt "exceptionBreakpointFilters" (list ExceptionBreakpointsFilter.enc))
(opt "supportsStepBack" bool)
(opt "supportsSetVariable" bool)
(opt "supportsRestartFrame" bool)
(opt "supportsGotoTargetsRequest" bool))


 let make ?supportsConfigurationDoneRequest ?supportsFunctionBreakpoints ?supportsConditionalBreakpoints ?supportsHitConditionalBreakpoints ?supportsEvaluateForHovers ?exceptionBreakpointFilters ?supportsStepBack ?supportsSetVariable ?supportsRestartFrame ?supportsGotoTargetsRequest () = 
{supportsConfigurationDoneRequest; supportsFunctionBreakpoints; supportsConditionalBreakpoints; supportsHitConditionalBreakpoints; supportsEvaluateForHovers; exceptionBreakpointFilters; supportsStepBack; supportsSetVariable; supportsRestartFrame; supportsGotoTargetsRequest}

 end


module Capabilities_10 : sig 
type t 
 val enc : t Data_encoding.t 
 val make : ?supportsStepInTargetsRequest:bool -> ?supportsCompletionsRequest:bool -> ?completionTriggerCharacters:string list -> ?supportsModulesRequest:bool -> ?additionalModuleColumns:ColumnDescriptor.t list -> ?supportedChecksumAlgorithms:ChecksumAlgorithm.t list -> ?supportsRestartRequest:bool -> ?supportsExceptionOptions:bool -> ?supportsValueFormattingOptions:bool -> ?supportsExceptionInfoRequest:bool -> unit -> t
end = struct 
 type t = { supportsStepInTargetsRequest: bool option;
supportsCompletionsRequest: bool option;
completionTriggerCharacters: string list option;
supportsModulesRequest: bool option;
additionalModuleColumns: ColumnDescriptor.t list option;
supportedChecksumAlgorithms: ChecksumAlgorithm.t list option;
supportsRestartRequest: bool option;
supportsExceptionOptions: bool option;
supportsValueFormattingOptions: bool option;
supportsExceptionInfoRequest: bool option; }

 let enc = 
 let open Data_encoding in 
 (* Capabilities_10.t *)
         conv 
 (fun {supportsStepInTargetsRequest; supportsCompletionsRequest; completionTriggerCharacters; supportsModulesRequest; additionalModuleColumns; supportedChecksumAlgorithms; supportsRestartRequest; supportsExceptionOptions; supportsValueFormattingOptions; supportsExceptionInfoRequest} -> (supportsStepInTargetsRequest, supportsCompletionsRequest, completionTriggerCharacters, supportsModulesRequest, additionalModuleColumns, supportedChecksumAlgorithms, supportsRestartRequest, supportsExceptionOptions, supportsValueFormattingOptions, supportsExceptionInfoRequest))
 (fun (supportsStepInTargetsRequest, supportsCompletionsRequest, completionTriggerCharacters, supportsModulesRequest, additionalModuleColumns, supportedChecksumAlgorithms, supportsRestartRequest, supportsExceptionOptions, supportsValueFormattingOptions, supportsExceptionInfoRequest) -> {supportsStepInTargetsRequest; supportsCompletionsRequest; completionTriggerCharacters; supportsModulesRequest; additionalModuleColumns; supportedChecksumAlgorithms; supportsRestartRequest; supportsExceptionOptions; supportsValueFormattingOptions; supportsExceptionInfoRequest})
 (obj10
(opt "supportsStepInTargetsRequest" bool)
(opt "supportsCompletionsRequest" bool)
(opt "completionTriggerCharacters" (list string))
(opt "supportsModulesRequest" bool)
(opt "additionalModuleColumns" (list ColumnDescriptor.enc))
(opt "supportedChecksumAlgorithms" (list ChecksumAlgorithm.enc))
(opt "supportsRestartRequest" bool)
(opt "supportsExceptionOptions" bool)
(opt "supportsValueFormattingOptions" bool)
(opt "supportsExceptionInfoRequest" bool))


 let make ?supportsStepInTargetsRequest ?supportsCompletionsRequest ?completionTriggerCharacters ?supportsModulesRequest ?additionalModuleColumns ?supportedChecksumAlgorithms ?supportsRestartRequest ?supportsExceptionOptions ?supportsValueFormattingOptions ?supportsExceptionInfoRequest () = 
{supportsStepInTargetsRequest; supportsCompletionsRequest; completionTriggerCharacters; supportsModulesRequest; additionalModuleColumns; supportedChecksumAlgorithms; supportsRestartRequest; supportsExceptionOptions; supportsValueFormattingOptions; supportsExceptionInfoRequest}

 end


module Capabilities_20 : sig 
type t 
 val enc : t Data_encoding.t 
 val make : ?supportTerminateDebuggee:bool -> ?supportSuspendDebuggee:bool -> ?supportsDelayedStackTraceLoading:bool -> ?supportsLoadedSourcesRequest:bool -> ?supportsLogPoints:bool -> ?supportsTerminateThreadsRequest:bool -> ?supportsSetExpression:bool -> ?supportsTerminateRequest:bool -> ?supportsDataBreakpoints:bool -> ?supportsReadMemoryRequest:bool -> unit -> t
end = struct 
 type t = { supportTerminateDebuggee: bool option;
supportSuspendDebuggee: bool option;
supportsDelayedStackTraceLoading: bool option;
supportsLoadedSourcesRequest: bool option;
supportsLogPoints: bool option;
supportsTerminateThreadsRequest: bool option;
supportsSetExpression: bool option;
supportsTerminateRequest: bool option;
supportsDataBreakpoints: bool option;
supportsReadMemoryRequest: bool option; }

 let enc = 
 let open Data_encoding in 
 (* Capabilities_20.t *)
         conv 
 (fun {supportTerminateDebuggee; supportSuspendDebuggee; supportsDelayedStackTraceLoading; supportsLoadedSourcesRequest; supportsLogPoints; supportsTerminateThreadsRequest; supportsSetExpression; supportsTerminateRequest; supportsDataBreakpoints; supportsReadMemoryRequest} -> (supportTerminateDebuggee, supportSuspendDebuggee, supportsDelayedStackTraceLoading, supportsLoadedSourcesRequest, supportsLogPoints, supportsTerminateThreadsRequest, supportsSetExpression, supportsTerminateRequest, supportsDataBreakpoints, supportsReadMemoryRequest))
 (fun (supportTerminateDebuggee, supportSuspendDebuggee, supportsDelayedStackTraceLoading, supportsLoadedSourcesRequest, supportsLogPoints, supportsTerminateThreadsRequest, supportsSetExpression, supportsTerminateRequest, supportsDataBreakpoints, supportsReadMemoryRequest) -> {supportTerminateDebuggee; supportSuspendDebuggee; supportsDelayedStackTraceLoading; supportsLoadedSourcesRequest; supportsLogPoints; supportsTerminateThreadsRequest; supportsSetExpression; supportsTerminateRequest; supportsDataBreakpoints; supportsReadMemoryRequest})
 (obj10
(opt "supportTerminateDebuggee" bool)
(opt "supportSuspendDebuggee" bool)
(opt "supportsDelayedStackTraceLoading" bool)
(opt "supportsLoadedSourcesRequest" bool)
(opt "supportsLogPoints" bool)
(opt "supportsTerminateThreadsRequest" bool)
(opt "supportsSetExpression" bool)
(opt "supportsTerminateRequest" bool)
(opt "supportsDataBreakpoints" bool)
(opt "supportsReadMemoryRequest" bool))


 let make ?supportTerminateDebuggee ?supportSuspendDebuggee ?supportsDelayedStackTraceLoading ?supportsLoadedSourcesRequest ?supportsLogPoints ?supportsTerminateThreadsRequest ?supportsSetExpression ?supportsTerminateRequest ?supportsDataBreakpoints ?supportsReadMemoryRequest () = 
{supportTerminateDebuggee; supportSuspendDebuggee; supportsDelayedStackTraceLoading; supportsLoadedSourcesRequest; supportsLogPoints; supportsTerminateThreadsRequest; supportsSetExpression; supportsTerminateRequest; supportsDataBreakpoints; supportsReadMemoryRequest}

 end


module Capabilities_30 : sig 
type t 
 val enc : t Data_encoding.t 
 val make : ?supportsWriteMemoryRequest:bool -> ?supportsDisassembleRequest:bool -> ?supportsCancelRequest:bool -> ?supportsBreakpointLocationsRequest:bool -> ?supportsClipboardContext:bool -> ?supportsSteppingGranularity:bool -> ?supportsInstructionBreakpoints:bool -> ?supportsExceptionFilterOptions:bool -> ?supportsSingleThreadExecutionRequests:bool -> unit -> t
end = struct 
 type t = { supportsWriteMemoryRequest: bool option;
supportsDisassembleRequest: bool option;
supportsCancelRequest: bool option;
supportsBreakpointLocationsRequest: bool option;
supportsClipboardContext: bool option;
supportsSteppingGranularity: bool option;
supportsInstructionBreakpoints: bool option;
supportsExceptionFilterOptions: bool option;
supportsSingleThreadExecutionRequests: bool option; }

 let enc = 
 let open Data_encoding in 
 (* Capabilities_30.t *)
         conv 
 (fun {supportsWriteMemoryRequest; supportsDisassembleRequest; supportsCancelRequest; supportsBreakpointLocationsRequest; supportsClipboardContext; supportsSteppingGranularity; supportsInstructionBreakpoints; supportsExceptionFilterOptions; supportsSingleThreadExecutionRequests} -> (supportsWriteMemoryRequest, supportsDisassembleRequest, supportsCancelRequest, supportsBreakpointLocationsRequest, supportsClipboardContext, supportsSteppingGranularity, supportsInstructionBreakpoints, supportsExceptionFilterOptions, supportsSingleThreadExecutionRequests))
 (fun (supportsWriteMemoryRequest, supportsDisassembleRequest, supportsCancelRequest, supportsBreakpointLocationsRequest, supportsClipboardContext, supportsSteppingGranularity, supportsInstructionBreakpoints, supportsExceptionFilterOptions, supportsSingleThreadExecutionRequests) -> {supportsWriteMemoryRequest; supportsDisassembleRequest; supportsCancelRequest; supportsBreakpointLocationsRequest; supportsClipboardContext; supportsSteppingGranularity; supportsInstructionBreakpoints; supportsExceptionFilterOptions; supportsSingleThreadExecutionRequests})
 (obj9
(opt "supportsWriteMemoryRequest" bool)
(opt "supportsDisassembleRequest" bool)
(opt "supportsCancelRequest" bool)
(opt "supportsBreakpointLocationsRequest" bool)
(opt "supportsClipboardContext" bool)
(opt "supportsSteppingGranularity" bool)
(opt "supportsInstructionBreakpoints" bool)
(opt "supportsExceptionFilterOptions" bool)
(opt "supportsSingleThreadExecutionRequests" bool))


 let make ?supportsWriteMemoryRequest ?supportsDisassembleRequest ?supportsCancelRequest ?supportsBreakpointLocationsRequest ?supportsClipboardContext ?supportsSteppingGranularity ?supportsInstructionBreakpoints ?supportsExceptionFilterOptions ?supportsSingleThreadExecutionRequests () = 
{supportsWriteMemoryRequest; supportsDisassembleRequest; supportsCancelRequest; supportsBreakpointLocationsRequest; supportsClipboardContext; supportsSteppingGranularity; supportsInstructionBreakpoints; supportsExceptionFilterOptions; supportsSingleThreadExecutionRequests}

 end


 type t = (Capabilities_0.t * (Capabilities_10.t * (Capabilities_20.t * Capabilities_30.t)))

 let enc = 
 let open Data_encoding in 
 merge_objs Capabilities_0.enc @@ merge_objs Capabilities_10.enc @@ merge_objs Capabilities_20.enc Capabilities_30.enc

 let make ?supportsConfigurationDoneRequest ?supportsFunctionBreakpoints ?supportsConditionalBreakpoints ?supportsHitConditionalBreakpoints ?supportsEvaluateForHovers ?exceptionBreakpointFilters ?supportsStepBack ?supportsSetVariable ?supportsRestartFrame ?supportsGotoTargetsRequest ?supportsStepInTargetsRequest ?supportsCompletionsRequest ?completionTriggerCharacters ?supportsModulesRequest ?additionalModuleColumns ?supportedChecksumAlgorithms ?supportsRestartRequest ?supportsExceptionOptions ?supportsValueFormattingOptions ?supportsExceptionInfoRequest ?supportTerminateDebuggee ?supportSuspendDebuggee ?supportsDelayedStackTraceLoading ?supportsLoadedSourcesRequest ?supportsLogPoints ?supportsTerminateThreadsRequest ?supportsSetExpression ?supportsTerminateRequest ?supportsDataBreakpoints ?supportsReadMemoryRequest ?supportsWriteMemoryRequest ?supportsDisassembleRequest ?supportsCancelRequest ?supportsBreakpointLocationsRequest ?supportsClipboardContext ?supportsSteppingGranularity ?supportsInstructionBreakpoints ?supportsExceptionFilterOptions ?supportsSingleThreadExecutionRequests () = 
let t0 = Capabilities_0.make ?supportsConfigurationDoneRequest ?supportsFunctionBreakpoints ?supportsConditionalBreakpoints ?supportsHitConditionalBreakpoints ?supportsEvaluateForHovers ?exceptionBreakpointFilters ?supportsStepBack ?supportsSetVariable ?supportsRestartFrame ?supportsGotoTargetsRequest () in

let t1 = Capabilities_10.make ?supportsStepInTargetsRequest ?supportsCompletionsRequest ?completionTriggerCharacters ?supportsModulesRequest ?additionalModuleColumns ?supportedChecksumAlgorithms ?supportsRestartRequest ?supportsExceptionOptions ?supportsValueFormattingOptions ?supportsExceptionInfoRequest () in

let t2 = Capabilities_20.make ?supportTerminateDebuggee ?supportSuspendDebuggee ?supportsDelayedStackTraceLoading ?supportsLoadedSourcesRequest ?supportsLogPoints ?supportsTerminateThreadsRequest ?supportsSetExpression ?supportsTerminateRequest ?supportsDataBreakpoints ?supportsReadMemoryRequest () in

let t3 = Capabilities_30.make ?supportsWriteMemoryRequest ?supportsDisassembleRequest ?supportsCancelRequest ?supportsBreakpointLocationsRequest ?supportsClipboardContext ?supportsSteppingGranularity ?supportsInstructionBreakpoints ?supportsExceptionFilterOptions ?supportsSingleThreadExecutionRequests () in

(t0 , (t1 , (t2 , t3)))

 end


module CapabilitiesEvent_body : sig 
type t 
 val enc : t Data_encoding.t 
 val make : capabilities:Capabilities.t -> unit -> t
end = struct 
 type t = { capabilities: Capabilities.t; }

 let enc = 
 let open Data_encoding in 
 (* CapabilitiesEvent_body.t *)
         conv 
 (fun {capabilities} -> capabilities)
 (fun capabilities -> {capabilities})
 (obj1
(req "capabilities" Capabilities.enc))


 let make ~capabilities () = 
{capabilities}

 end




module ProgressStartEvent_body : sig 
type t 
 val enc : t Data_encoding.t 
 val make : progressId:string -> title:string -> ?requestId:int -> ?cancellable:bool -> ?message:string -> ?percentage:int -> unit -> t
end = struct 
 type t = { progressId: string;
title: string;
requestId: int option;
cancellable: bool option;
message: string option;
percentage: int option; }

 let enc = 
 let open Data_encoding in 
 (* ProgressStartEvent_body.t *)
         conv 
 (fun {progressId; title; requestId; cancellable; message; percentage} -> (progressId, title, requestId, cancellable, message, percentage))
 (fun (progressId, title, requestId, cancellable, message, percentage) -> {progressId; title; requestId; cancellable; message; percentage})
 (obj6
(req "progressId" string)
(req "title" string)
(opt "requestId" int31)
(opt "cancellable" bool)
(opt "message" string)
(opt "percentage" int31))


 let make ~progressId ~title ?requestId ?cancellable ?message ?percentage () = 
{progressId; title; requestId; cancellable; message; percentage}

 end




module ProgressUpdateEvent_body : sig 
type t 
 val enc : t Data_encoding.t 
 val make : progressId:string -> ?message:string -> ?percentage:int -> unit -> t
end = struct 
 type t = { progressId: string;
message: string option;
percentage: int option; }

 let enc = 
 let open Data_encoding in 
 (* ProgressUpdateEvent_body.t *)
         conv 
 (fun {progressId; message; percentage} -> (progressId, message, percentage))
 (fun (progressId, message, percentage) -> {progressId; message; percentage})
 (obj3
(req "progressId" string)
(opt "message" string)
(opt "percentage" int31))


 let make ~progressId ?message ?percentage () = 
{progressId; message; percentage}

 end




module ProgressEndEvent_body : sig 
type t 
 val enc : t Data_encoding.t 
 val make : progressId:string -> ?message:string -> unit -> t
end = struct 
 type t = { progressId: string;
message: string option; }

 let enc = 
 let open Data_encoding in 
 (* ProgressEndEvent_body.t *)
         conv 
 (fun {progressId; message} -> (progressId, message))
 (fun (progressId, message) -> {progressId; message})
 (obj2
(req "progressId" string)
(opt "message" string))


 let make ~progressId ?message () = 
{progressId; message}

 end




(* dont bother with a sig for enums, the inferred one is fine *)
 module InvalidatedAreas = struct 
 type t = All | Stacks | Threads | Variables | Other of string 

 let enc = 
 let open Data_encoding in 
 conv 
 (function All -> "all" | Stacks -> "stacks" | Threads -> "threads" | Variables -> "variables" | Other s -> s)
 (function "all" -> All | "stacks" -> Stacks | "threads" -> Threads | "variables" -> Variables | _ as s -> Other s)
 string

 end


module InvalidatedEvent_body : sig 
type t 
 val enc : t Data_encoding.t 
 val make : ?areas:InvalidatedAreas.t list -> ?threadId:int -> ?stackFrameId:int -> unit -> t
end = struct 
 type t = { areas: InvalidatedAreas.t list option;
threadId: int option;
stackFrameId: int option; }

 let enc = 
 let open Data_encoding in 
 (* InvalidatedEvent_body.t *)
         conv 
 (fun {areas; threadId; stackFrameId} -> (areas, threadId, stackFrameId))
 (fun (areas, threadId, stackFrameId) -> {areas; threadId; stackFrameId})
 (obj3
(opt "areas" (list InvalidatedAreas.enc))
(opt "threadId" int31)
(opt "stackFrameId" int31))


 let make ?areas ?threadId ?stackFrameId () = 
{areas; threadId; stackFrameId}

 end




module MemoryEvent_body : sig 
type t 
 val enc : t Data_encoding.t 
 val make : memoryReference:string -> offset:int -> count:int -> unit -> t
end = struct 
 type t = { memoryReference: string;
offset: int;
count: int; }

 let enc = 
 let open Data_encoding in 
 (* MemoryEvent_body.t *)
         conv 
 (fun {memoryReference; offset; count} -> (memoryReference, offset, count))
 (fun (memoryReference, offset, count) -> {memoryReference; offset; count})
 (obj3
(req "memoryReference" string)
(req "offset" int31)
(req "count" int31))


 let make ~memoryReference ~offset ~count () = 
{memoryReference; offset; count}

 end




(* dont bother with a sig for enums, the inferred one is fine *)
 module RunInTerminalRequestArguments_kind = struct 
 type t = Integrated | External 

 let enc = 
 let open Data_encoding in 
 conv 
 (function Integrated -> "integrated" | External -> "external")
 (function "integrated" -> Integrated | "external" -> External | _ -> failwith "RunInTerminalRequestArguments_kind")
 string

 end


module RunInTerminalRequestArguments : sig 
type t 
 val enc : t Data_encoding.t 
 val make : ?kind:RunInTerminalRequestArguments_kind.t -> ?title:string -> cwd:string -> args:string list -> ?env:Data_encoding.json -> unit -> t
end = struct 
 type t = { kind: RunInTerminalRequestArguments_kind.t option;
title: string option;
cwd: string;
args: string list;
env: Data_encoding.json option; }

 let enc = 
 let open Data_encoding in 
 (* RunInTerminalRequestArguments.t *)
         conv 
 (fun {kind; title; cwd; args; env} -> (kind, title, cwd, args, env))
 (fun (kind, title, cwd, args, env) -> {kind; title; cwd; args; env})
 (obj5
(opt "kind" RunInTerminalRequestArguments_kind.enc)
(opt "title" string)
(req "cwd" string)
(req "args" (list string))
(opt "env" json))


 let make ?kind ?title ~cwd ~args ?env () = 
{kind; title; cwd; args; env}

 end




module RunInTerminalResponse_body : sig 
type t 
 val enc : t Data_encoding.t 
 val make : ?processId:int -> ?shellProcessId:int -> unit -> t
end = struct 
 type t = { processId: int option;
shellProcessId: int option; }

 let enc = 
 let open Data_encoding in 
 (* RunInTerminalResponse_body.t *)
         conv 
 (fun {processId; shellProcessId} -> (processId, shellProcessId))
 (fun (processId, shellProcessId) -> {processId; shellProcessId})
 (obj2
(opt "processId" int31)
(opt "shellProcessId" int31))


 let make ?processId ?shellProcessId () = 
{processId; shellProcessId}

 end




(* dont bother with a sig for enums, the inferred one is fine *)
 module InitializeRequestArguments_pathFormat = struct 
 type t = Path | Uri | Other of string 

 let enc = 
 let open Data_encoding in 
 conv 
 (function Path -> "path" | Uri -> "uri" | Other s -> s)
 (function "path" -> Path | "uri" -> Uri | _ as s -> Other s)
 string

 end


module InitializeRequestArguments : sig 
type t 
 val enc : t Data_encoding.t 
 val make : ?clientID:string -> ?clientName:string -> adapterID:string -> ?locale:string -> ?linesStartAt1:bool -> ?columnsStartAt1:bool -> ?pathFormat:InitializeRequestArguments_pathFormat.t -> ?supportsVariableType:bool -> ?supportsVariablePaging:bool -> ?supportsRunInTerminalRequest:bool -> ?supportsMemoryReferences:bool -> ?supportsProgressReporting:bool -> ?supportsInvalidatedEvent:bool -> ?supportsMemoryEvent:bool -> unit -> t
end = struct 
 module InitializeRequestArguments_0 : sig 
type t 
 val enc : t Data_encoding.t 
 val make : ?clientID:string -> ?clientName:string -> adapterID:string -> ?locale:string -> ?linesStartAt1:bool -> ?columnsStartAt1:bool -> ?pathFormat:InitializeRequestArguments_pathFormat.t -> ?supportsVariableType:bool -> ?supportsVariablePaging:bool -> ?supportsRunInTerminalRequest:bool -> unit -> t
end = struct 
 type t = { clientID: string option;
clientName: string option;
adapterID: string;
locale: string option;
linesStartAt1: bool option;
columnsStartAt1: bool option;
pathFormat: InitializeRequestArguments_pathFormat.t option;
supportsVariableType: bool option;
supportsVariablePaging: bool option;
supportsRunInTerminalRequest: bool option; }

 let enc = 
 let open Data_encoding in 
 (* InitializeRequestArguments_0.t *)
         conv 
 (fun {clientID; clientName; adapterID; locale; linesStartAt1; columnsStartAt1; pathFormat; supportsVariableType; supportsVariablePaging; supportsRunInTerminalRequest} -> (clientID, clientName, adapterID, locale, linesStartAt1, columnsStartAt1, pathFormat, supportsVariableType, supportsVariablePaging, supportsRunInTerminalRequest))
 (fun (clientID, clientName, adapterID, locale, linesStartAt1, columnsStartAt1, pathFormat, supportsVariableType, supportsVariablePaging, supportsRunInTerminalRequest) -> {clientID; clientName; adapterID; locale; linesStartAt1; columnsStartAt1; pathFormat; supportsVariableType; supportsVariablePaging; supportsRunInTerminalRequest})
 (obj10
(opt "clientID" string)
(opt "clientName" string)
(req "adapterID" string)
(opt "locale" string)
(opt "linesStartAt1" bool)
(opt "columnsStartAt1" bool)
(opt "pathFormat" InitializeRequestArguments_pathFormat.enc)
(opt "supportsVariableType" bool)
(opt "supportsVariablePaging" bool)
(opt "supportsRunInTerminalRequest" bool))


 let make ?clientID ?clientName ~adapterID ?locale ?linesStartAt1 ?columnsStartAt1 ?pathFormat ?supportsVariableType ?supportsVariablePaging ?supportsRunInTerminalRequest () = 
{clientID; clientName; adapterID; locale; linesStartAt1; columnsStartAt1; pathFormat; supportsVariableType; supportsVariablePaging; supportsRunInTerminalRequest}

 end


module InitializeRequestArguments_10 : sig 
type t 
 val enc : t Data_encoding.t 
 val make : ?supportsMemoryReferences:bool -> ?supportsProgressReporting:bool -> ?supportsInvalidatedEvent:bool -> ?supportsMemoryEvent:bool -> unit -> t
end = struct 
 type t = { supportsMemoryReferences: bool option;
supportsProgressReporting: bool option;
supportsInvalidatedEvent: bool option;
supportsMemoryEvent: bool option; }

 let enc = 
 let open Data_encoding in 
 (* InitializeRequestArguments_10.t *)
         conv 
 (fun {supportsMemoryReferences; supportsProgressReporting; supportsInvalidatedEvent; supportsMemoryEvent} -> (supportsMemoryReferences, supportsProgressReporting, supportsInvalidatedEvent, supportsMemoryEvent))
 (fun (supportsMemoryReferences, supportsProgressReporting, supportsInvalidatedEvent, supportsMemoryEvent) -> {supportsMemoryReferences; supportsProgressReporting; supportsInvalidatedEvent; supportsMemoryEvent})
 (obj4
(opt "supportsMemoryReferences" bool)
(opt "supportsProgressReporting" bool)
(opt "supportsInvalidatedEvent" bool)
(opt "supportsMemoryEvent" bool))


 let make ?supportsMemoryReferences ?supportsProgressReporting ?supportsInvalidatedEvent ?supportsMemoryEvent () = 
{supportsMemoryReferences; supportsProgressReporting; supportsInvalidatedEvent; supportsMemoryEvent}

 end


 type t = (InitializeRequestArguments_0.t * InitializeRequestArguments_10.t)

 let enc = 
 let open Data_encoding in 
 merge_objs InitializeRequestArguments_0.enc InitializeRequestArguments_10.enc

 let make ?clientID ?clientName ~adapterID ?locale ?linesStartAt1 ?columnsStartAt1 ?pathFormat ?supportsVariableType ?supportsVariablePaging ?supportsRunInTerminalRequest ?supportsMemoryReferences ?supportsProgressReporting ?supportsInvalidatedEvent ?supportsMemoryEvent () = 
let t0 = InitializeRequestArguments_0.make ?clientID ?clientName ~adapterID ?locale ?linesStartAt1 ?columnsStartAt1 ?pathFormat ?supportsVariableType ?supportsVariablePaging ?supportsRunInTerminalRequest () in

let t1 = InitializeRequestArguments_10.make ?supportsMemoryReferences ?supportsProgressReporting ?supportsInvalidatedEvent ?supportsMemoryEvent () in

(t0 , t1)

 end






module ConfigurationDoneArguments : sig 
 type t 
 val enc : t Data_encoding.t 
 val make : unit -> t 
 end = struct 
 type t = unit

 let enc = Data_encoding.empty

 let make () = () 

 end


















module DisconnectArguments : sig 
type t 
 val enc : t Data_encoding.t 
 val make : ?restart:bool -> ?terminateDebuggee:bool -> ?suspendDebuggee:bool -> unit -> t
end = struct 
 type t = { restart: bool option;
terminateDebuggee: bool option;
suspendDebuggee: bool option; }

 let enc = 
 let open Data_encoding in 
 (* DisconnectArguments.t *)
         conv 
 (fun {restart; terminateDebuggee; suspendDebuggee} -> (restart, terminateDebuggee, suspendDebuggee))
 (fun (restart, terminateDebuggee, suspendDebuggee) -> {restart; terminateDebuggee; suspendDebuggee})
 (obj3
(opt "restart" bool)
(opt "terminateDebuggee" bool)
(opt "suspendDebuggee" bool))


 let make ?restart ?terminateDebuggee ?suspendDebuggee () = 
{restart; terminateDebuggee; suspendDebuggee}

 end






module TerminateArguments : sig 
type t 
 val enc : t Data_encoding.t 
 val make : ?restart:bool -> unit -> t
end = struct 
 type t = { restart: bool option; }

 let enc = 
 let open Data_encoding in 
 (* TerminateArguments.t *)
         conv 
 (fun {restart} -> restart)
 (fun restart -> {restart})
 (obj1
(opt "restart" bool))


 let make ?restart () = 
{restart}

 end






module BreakpointLocationsArguments : sig 
type t 
 val enc : t Data_encoding.t 
 val make : source:Source.t -> line:int -> ?column:int -> ?endLine:int -> ?endColumn:int -> unit -> t
end = struct 
 type t = { source: Source.t;
line: int;
column: int option;
endLine: int option;
endColumn: int option; }

 let enc = 
 let open Data_encoding in 
 (* BreakpointLocationsArguments.t *)
         conv 
 (fun {source; line; column; endLine; endColumn} -> (source, line, column, endLine, endColumn))
 (fun (source, line, column, endLine, endColumn) -> {source; line; column; endLine; endColumn})
 (obj5
(req "source" Source.enc)
(req "line" int31)
(opt "column" int31)
(opt "endLine" int31)
(opt "endColumn" int31))


 let make ~source ~line ?column ?endLine ?endColumn () = 
{source; line; column; endLine; endColumn}

 end




module BreakpointLocation : sig 
type t 
 val enc : t Data_encoding.t 
 val make : line:int -> ?column:int -> ?endLine:int -> ?endColumn:int -> unit -> t
end = struct 
 type t = { line: int;
column: int option;
endLine: int option;
endColumn: int option; }

 let enc = 
 let open Data_encoding in 
 (* BreakpointLocation.t *)
         conv 
 (fun {line; column; endLine; endColumn} -> (line, column, endLine, endColumn))
 (fun (line, column, endLine, endColumn) -> {line; column; endLine; endColumn})
 (obj4
(req "line" int31)
(opt "column" int31)
(opt "endLine" int31)
(opt "endColumn" int31))


 let make ~line ?column ?endLine ?endColumn () = 
{line; column; endLine; endColumn}

 end


module BreakpointLocationsResponse_body : sig 
type t 
 val enc : t Data_encoding.t 
 val make : breakpoints:BreakpointLocation.t list -> unit -> t
end = struct 
 type t = { breakpoints: BreakpointLocation.t list; }

 let enc = 
 let open Data_encoding in 
 (* BreakpointLocationsResponse_body.t *)
         conv 
 (fun {breakpoints} -> breakpoints)
 (fun breakpoints -> {breakpoints})
 (obj1
(req "breakpoints" (list BreakpointLocation.enc)))


 let make ~breakpoints () = 
{breakpoints}

 end




module SourceBreakpoint : sig 
type t 
 val enc : t Data_encoding.t 
 val make : line:int -> ?column:int -> ?condition:string -> ?hitCondition:string -> ?logMessage:string -> unit -> t
end = struct 
 type t = { line: int;
column: int option;
condition: string option;
hitCondition: string option;
logMessage: string option; }

 let enc = 
 let open Data_encoding in 
 (* SourceBreakpoint.t *)
         conv 
 (fun {line; column; condition; hitCondition; logMessage} -> (line, column, condition, hitCondition, logMessage))
 (fun (line, column, condition, hitCondition, logMessage) -> {line; column; condition; hitCondition; logMessage})
 (obj5
(req "line" int31)
(opt "column" int31)
(opt "condition" string)
(opt "hitCondition" string)
(opt "logMessage" string))


 let make ~line ?column ?condition ?hitCondition ?logMessage () = 
{line; column; condition; hitCondition; logMessage}

 end


module SetBreakpointsArguments : sig 
type t 
 val enc : t Data_encoding.t 
 val make : source:Source.t -> ?breakpoints:SourceBreakpoint.t list -> ?lines:int list -> ?sourceModified:bool -> unit -> t
end = struct 
 type t = { source: Source.t;
breakpoints: SourceBreakpoint.t list option;
lines: int list option;
sourceModified: bool option; }

 let enc = 
 let open Data_encoding in 
 (* SetBreakpointsArguments.t *)
         conv 
 (fun {source; breakpoints; lines; sourceModified} -> (source, breakpoints, lines, sourceModified))
 (fun (source, breakpoints, lines, sourceModified) -> {source; breakpoints; lines; sourceModified})
 (obj4
(req "source" Source.enc)
(opt "breakpoints" (list SourceBreakpoint.enc))
(opt "lines" (list int31))
(opt "sourceModified" bool))


 let make ~source ?breakpoints ?lines ?sourceModified () = 
{source; breakpoints; lines; sourceModified}

 end




module SetBreakpointsResponse_body : sig 
type t 
 val enc : t Data_encoding.t 
 val make : breakpoints:Breakpoint.t list -> unit -> t
end = struct 
 type t = { breakpoints: Breakpoint.t list; }

 let enc = 
 let open Data_encoding in 
 (* SetBreakpointsResponse_body.t *)
         conv 
 (fun {breakpoints} -> breakpoints)
 (fun breakpoints -> {breakpoints})
 (obj1
(req "breakpoints" (list Breakpoint.enc)))


 let make ~breakpoints () = 
{breakpoints}

 end




module FunctionBreakpoint : sig 
type t 
 val enc : t Data_encoding.t 
 val make : name:string -> ?condition:string -> ?hitCondition:string -> unit -> t
end = struct 
 type t = { name: string;
condition: string option;
hitCondition: string option; }

 let enc = 
 let open Data_encoding in 
 (* FunctionBreakpoint.t *)
         conv 
 (fun {name; condition; hitCondition} -> (name, condition, hitCondition))
 (fun (name, condition, hitCondition) -> {name; condition; hitCondition})
 (obj3
(req "name" string)
(opt "condition" string)
(opt "hitCondition" string))


 let make ~name ?condition ?hitCondition () = 
{name; condition; hitCondition}

 end


module SetFunctionBreakpointsArguments : sig 
type t 
 val enc : t Data_encoding.t 
 val make : breakpoints:FunctionBreakpoint.t list -> unit -> t
end = struct 
 type t = { breakpoints: FunctionBreakpoint.t list; }

 let enc = 
 let open Data_encoding in 
 (* SetFunctionBreakpointsArguments.t *)
         conv 
 (fun {breakpoints} -> breakpoints)
 (fun breakpoints -> {breakpoints})
 (obj1
(req "breakpoints" (list FunctionBreakpoint.enc)))


 let make ~breakpoints () = 
{breakpoints}

 end




module SetFunctionBreakpointsResponse_body : sig 
type t 
 val enc : t Data_encoding.t 
 val make : breakpoints:Breakpoint.t list -> unit -> t
end = struct 
 type t = { breakpoints: Breakpoint.t list; }

 let enc = 
 let open Data_encoding in 
 (* SetFunctionBreakpointsResponse_body.t *)
         conv 
 (fun {breakpoints} -> breakpoints)
 (fun breakpoints -> {breakpoints})
 (obj1
(req "breakpoints" (list Breakpoint.enc)))


 let make ~breakpoints () = 
{breakpoints}

 end




module ExceptionFilterOptions : sig 
type t 
 val enc : t Data_encoding.t 
 val make : filterId:string -> ?condition:string -> unit -> t
end = struct 
 type t = { filterId: string;
condition: string option; }

 let enc = 
 let open Data_encoding in 
 (* ExceptionFilterOptions.t *)
         conv 
 (fun {filterId; condition} -> (filterId, condition))
 (fun (filterId, condition) -> {filterId; condition})
 (obj2
(req "filterId" string)
(opt "condition" string))


 let make ~filterId ?condition () = 
{filterId; condition}

 end


module ExceptionPathSegment : sig 
type t 
 val enc : t Data_encoding.t 
 val make : ?negate:bool -> names:string list -> unit -> t
end = struct 
 type t = { negate: bool option;
names: string list; }

 let enc = 
 let open Data_encoding in 
 (* ExceptionPathSegment.t *)
         conv 
 (fun {negate; names} -> (negate, names))
 (fun (negate, names) -> {negate; names})
 (obj2
(opt "negate" bool)
(req "names" (list string)))


 let make ?negate ~names () = 
{negate; names}

 end


(* dont bother with a sig for enums, the inferred one is fine *)
 module ExceptionBreakMode = struct 
 type t = Never | Always | Unhandled | UserUnhandled 

 let enc = 
 let open Data_encoding in 
 conv 
 (function Never -> "never" | Always -> "always" | Unhandled -> "unhandled" | UserUnhandled -> "userUnhandled")
 (function "never" -> Never | "always" -> Always | "unhandled" -> Unhandled | "userUnhandled" -> UserUnhandled | _ -> failwith "ExceptionBreakMode")
 string

 end


module ExceptionOptions : sig 
type t 
 val enc : t Data_encoding.t 
 val make : ?path:ExceptionPathSegment.t list -> breakMode:ExceptionBreakMode.t -> unit -> t
end = struct 
 type t = { path: ExceptionPathSegment.t list option;
breakMode: ExceptionBreakMode.t; }

 let enc = 
 let open Data_encoding in 
 (* ExceptionOptions.t *)
         conv 
 (fun {path; breakMode} -> (path, breakMode))
 (fun (path, breakMode) -> {path; breakMode})
 (obj2
(opt "path" (list ExceptionPathSegment.enc))
(req "breakMode" ExceptionBreakMode.enc))


 let make ?path ~breakMode () = 
{path; breakMode}

 end


module SetExceptionBreakpointsArguments : sig 
type t 
 val enc : t Data_encoding.t 
 val make : filters:string list -> ?filterOptions:ExceptionFilterOptions.t list -> ?exceptionOptions:ExceptionOptions.t list -> unit -> t
end = struct 
 type t = { filters: string list;
filterOptions: ExceptionFilterOptions.t list option;
exceptionOptions: ExceptionOptions.t list option; }

 let enc = 
 let open Data_encoding in 
 (* SetExceptionBreakpointsArguments.t *)
         conv 
 (fun {filters; filterOptions; exceptionOptions} -> (filters, filterOptions, exceptionOptions))
 (fun (filters, filterOptions, exceptionOptions) -> {filters; filterOptions; exceptionOptions})
 (obj3
(req "filters" (list string))
(opt "filterOptions" (list ExceptionFilterOptions.enc))
(opt "exceptionOptions" (list ExceptionOptions.enc)))


 let make ~filters ?filterOptions ?exceptionOptions () = 
{filters; filterOptions; exceptionOptions}

 end




module SetExceptionBreakpointsResponse_body : sig 
type t 
 val enc : t Data_encoding.t 
 val make : ?breakpoints:Breakpoint.t list -> unit -> t
end = struct 
 type t = { breakpoints: Breakpoint.t list option; }

 let enc = 
 let open Data_encoding in 
 (* SetExceptionBreakpointsResponse_body.t *)
         conv 
 (fun {breakpoints} -> breakpoints)
 (fun breakpoints -> {breakpoints})
 (obj1
(opt "breakpoints" (list Breakpoint.enc)))


 let make ?breakpoints () = 
{breakpoints}

 end




module DataBreakpointInfoArguments : sig 
type t 
 val enc : t Data_encoding.t 
 val make : ?variablesReference:int -> name:string -> unit -> t
end = struct 
 type t = { variablesReference: int option;
name: string; }

 let enc = 
 let open Data_encoding in 
 (* DataBreakpointInfoArguments.t *)
         conv 
 (fun {variablesReference; name} -> (variablesReference, name))
 (fun (variablesReference, name) -> {variablesReference; name})
 (obj2
(opt "variablesReference" int31)
(req "name" string))


 let make ?variablesReference ~name () = 
{variablesReference; name}

 end




(* dont bother with a sig for enums, the inferred one is fine *)
 module DataBreakpointAccessType = struct 
 type t = Read | Write | ReadWrite 

 let enc = 
 let open Data_encoding in 
 conv 
 (function Read -> "read" | Write -> "write" | ReadWrite -> "readWrite")
 (function "read" -> Read | "write" -> Write | "readWrite" -> ReadWrite | _ -> failwith "DataBreakpointAccessType")
 string

 end


module DataBreakpointInfoResponse_body : sig 
type t 
 val enc : t Data_encoding.t 
 val make : dataId:string option -> description:string -> ?accessTypes:DataBreakpointAccessType.t list -> ?canPersist:bool -> unit -> t
end = struct 
 type t = { dataId: string option;
description: string;
accessTypes: DataBreakpointAccessType.t list option;
canPersist: bool option; }

 let enc = 
 let open Data_encoding in 
 (* DataBreakpointInfoResponse_body.t *)
         conv 
 (fun {dataId; description; accessTypes; canPersist} -> (dataId, description, accessTypes, canPersist))
 (fun (dataId, description, accessTypes, canPersist) -> {dataId; description; accessTypes; canPersist})
 (obj4
(req "dataId" (option string))
(req "description" string)
(opt "accessTypes" (list DataBreakpointAccessType.enc))
(opt "canPersist" bool))


 let make ~dataId ~description ?accessTypes ?canPersist () = 
{dataId; description; accessTypes; canPersist}

 end




module DataBreakpoint : sig 
type t 
 val enc : t Data_encoding.t 
 val make : dataId:string -> ?accessType:DataBreakpointAccessType.t -> ?condition:string -> ?hitCondition:string -> unit -> t
end = struct 
 type t = { dataId: string;
accessType: DataBreakpointAccessType.t option;
condition: string option;
hitCondition: string option; }

 let enc = 
 let open Data_encoding in 
 (* DataBreakpoint.t *)
         conv 
 (fun {dataId; accessType; condition; hitCondition} -> (dataId, accessType, condition, hitCondition))
 (fun (dataId, accessType, condition, hitCondition) -> {dataId; accessType; condition; hitCondition})
 (obj4
(req "dataId" string)
(opt "accessType" DataBreakpointAccessType.enc)
(opt "condition" string)
(opt "hitCondition" string))


 let make ~dataId ?accessType ?condition ?hitCondition () = 
{dataId; accessType; condition; hitCondition}

 end


module SetDataBreakpointsArguments : sig 
type t 
 val enc : t Data_encoding.t 
 val make : breakpoints:DataBreakpoint.t list -> unit -> t
end = struct 
 type t = { breakpoints: DataBreakpoint.t list; }

 let enc = 
 let open Data_encoding in 
 (* SetDataBreakpointsArguments.t *)
         conv 
 (fun {breakpoints} -> breakpoints)
 (fun breakpoints -> {breakpoints})
 (obj1
(req "breakpoints" (list DataBreakpoint.enc)))


 let make ~breakpoints () = 
{breakpoints}

 end




module SetDataBreakpointsResponse_body : sig 
type t 
 val enc : t Data_encoding.t 
 val make : breakpoints:Breakpoint.t list -> unit -> t
end = struct 
 type t = { breakpoints: Breakpoint.t list; }

 let enc = 
 let open Data_encoding in 
 (* SetDataBreakpointsResponse_body.t *)
         conv 
 (fun {breakpoints} -> breakpoints)
 (fun breakpoints -> {breakpoints})
 (obj1
(req "breakpoints" (list Breakpoint.enc)))


 let make ~breakpoints () = 
{breakpoints}

 end




module InstructionBreakpoint : sig 
type t 
 val enc : t Data_encoding.t 
 val make : instructionReference:string -> ?offset:int -> ?condition:string -> ?hitCondition:string -> unit -> t
end = struct 
 type t = { instructionReference: string;
offset: int option;
condition: string option;
hitCondition: string option; }

 let enc = 
 let open Data_encoding in 
 (* InstructionBreakpoint.t *)
         conv 
 (fun {instructionReference; offset; condition; hitCondition} -> (instructionReference, offset, condition, hitCondition))
 (fun (instructionReference, offset, condition, hitCondition) -> {instructionReference; offset; condition; hitCondition})
 (obj4
(req "instructionReference" string)
(opt "offset" int31)
(opt "condition" string)
(opt "hitCondition" string))


 let make ~instructionReference ?offset ?condition ?hitCondition () = 
{instructionReference; offset; condition; hitCondition}

 end


module SetInstructionBreakpointsArguments : sig 
type t 
 val enc : t Data_encoding.t 
 val make : breakpoints:InstructionBreakpoint.t list -> unit -> t
end = struct 
 type t = { breakpoints: InstructionBreakpoint.t list; }

 let enc = 
 let open Data_encoding in 
 (* SetInstructionBreakpointsArguments.t *)
         conv 
 (fun {breakpoints} -> breakpoints)
 (fun breakpoints -> {breakpoints})
 (obj1
(req "breakpoints" (list InstructionBreakpoint.enc)))


 let make ~breakpoints () = 
{breakpoints}

 end




module SetInstructionBreakpointsResponse_body : sig 
type t 
 val enc : t Data_encoding.t 
 val make : breakpoints:Breakpoint.t list -> unit -> t
end = struct 
 type t = { breakpoints: Breakpoint.t list; }

 let enc = 
 let open Data_encoding in 
 (* SetInstructionBreakpointsResponse_body.t *)
         conv 
 (fun {breakpoints} -> breakpoints)
 (fun breakpoints -> {breakpoints})
 (obj1
(req "breakpoints" (list Breakpoint.enc)))


 let make ~breakpoints () = 
{breakpoints}

 end




module ContinueArguments : sig 
type t 
 val enc : t Data_encoding.t 
 val make : threadId:int -> ?singleThread:bool -> unit -> t
end = struct 
 type t = { threadId: int;
singleThread: bool option; }

 let enc = 
 let open Data_encoding in 
 (* ContinueArguments.t *)
         conv 
 (fun {threadId; singleThread} -> (threadId, singleThread))
 (fun (threadId, singleThread) -> {threadId; singleThread})
 (obj2
(req "threadId" int31)
(opt "singleThread" bool))


 let make ~threadId ?singleThread () = 
{threadId; singleThread}

 end




module ContinueResponse_body : sig 
type t 
 val enc : t Data_encoding.t 
 val make : ?allThreadsContinued:bool -> unit -> t
end = struct 
 type t = { allThreadsContinued: bool option; }

 let enc = 
 let open Data_encoding in 
 (* ContinueResponse_body.t *)
         conv 
 (fun {allThreadsContinued} -> allThreadsContinued)
 (fun allThreadsContinued -> {allThreadsContinued})
 (obj1
(opt "allThreadsContinued" bool))


 let make ?allThreadsContinued () = 
{allThreadsContinued}

 end




(* dont bother with a sig for enums, the inferred one is fine *)
 module SteppingGranularity = struct 
 type t = Statement | Line | Instruction 

 let enc = 
 let open Data_encoding in 
 conv 
 (function Statement -> "statement" | Line -> "line" | Instruction -> "instruction")
 (function "statement" -> Statement | "line" -> Line | "instruction" -> Instruction | _ -> failwith "SteppingGranularity")
 string

 end


module NextArguments : sig 
type t 
 val enc : t Data_encoding.t 
 val make : threadId:int -> ?singleThread:bool -> ?granularity:SteppingGranularity.t -> unit -> t
end = struct 
 type t = { threadId: int;
singleThread: bool option;
granularity: SteppingGranularity.t option; }

 let enc = 
 let open Data_encoding in 
 (* NextArguments.t *)
         conv 
 (fun {threadId; singleThread; granularity} -> (threadId, singleThread, granularity))
 (fun (threadId, singleThread, granularity) -> {threadId; singleThread; granularity})
 (obj3
(req "threadId" int31)
(opt "singleThread" bool)
(opt "granularity" SteppingGranularity.enc))


 let make ~threadId ?singleThread ?granularity () = 
{threadId; singleThread; granularity}

 end






module StepInArguments : sig 
type t 
 val enc : t Data_encoding.t 
 val make : threadId:int -> ?singleThread:bool -> ?targetId:int -> ?granularity:SteppingGranularity.t -> unit -> t
end = struct 
 type t = { threadId: int;
singleThread: bool option;
targetId: int option;
granularity: SteppingGranularity.t option; }

 let enc = 
 let open Data_encoding in 
 (* StepInArguments.t *)
         conv 
 (fun {threadId; singleThread; targetId; granularity} -> (threadId, singleThread, targetId, granularity))
 (fun (threadId, singleThread, targetId, granularity) -> {threadId; singleThread; targetId; granularity})
 (obj4
(req "threadId" int31)
(opt "singleThread" bool)
(opt "targetId" int31)
(opt "granularity" SteppingGranularity.enc))


 let make ~threadId ?singleThread ?targetId ?granularity () = 
{threadId; singleThread; targetId; granularity}

 end






module StepOutArguments : sig 
type t 
 val enc : t Data_encoding.t 
 val make : threadId:int -> ?singleThread:bool -> ?granularity:SteppingGranularity.t -> unit -> t
end = struct 
 type t = { threadId: int;
singleThread: bool option;
granularity: SteppingGranularity.t option; }

 let enc = 
 let open Data_encoding in 
 (* StepOutArguments.t *)
         conv 
 (fun {threadId; singleThread; granularity} -> (threadId, singleThread, granularity))
 (fun (threadId, singleThread, granularity) -> {threadId; singleThread; granularity})
 (obj3
(req "threadId" int31)
(opt "singleThread" bool)
(opt "granularity" SteppingGranularity.enc))


 let make ~threadId ?singleThread ?granularity () = 
{threadId; singleThread; granularity}

 end






module StepBackArguments : sig 
type t 
 val enc : t Data_encoding.t 
 val make : threadId:int -> ?singleThread:bool -> ?granularity:SteppingGranularity.t -> unit -> t
end = struct 
 type t = { threadId: int;
singleThread: bool option;
granularity: SteppingGranularity.t option; }

 let enc = 
 let open Data_encoding in 
 (* StepBackArguments.t *)
         conv 
 (fun {threadId; singleThread; granularity} -> (threadId, singleThread, granularity))
 (fun (threadId, singleThread, granularity) -> {threadId; singleThread; granularity})
 (obj3
(req "threadId" int31)
(opt "singleThread" bool)
(opt "granularity" SteppingGranularity.enc))


 let make ~threadId ?singleThread ?granularity () = 
{threadId; singleThread; granularity}

 end






module ReverseContinueArguments : sig 
type t 
 val enc : t Data_encoding.t 
 val make : threadId:int -> ?singleThread:bool -> unit -> t
end = struct 
 type t = { threadId: int;
singleThread: bool option; }

 let enc = 
 let open Data_encoding in 
 (* ReverseContinueArguments.t *)
         conv 
 (fun {threadId; singleThread} -> (threadId, singleThread))
 (fun (threadId, singleThread) -> {threadId; singleThread})
 (obj2
(req "threadId" int31)
(opt "singleThread" bool))


 let make ~threadId ?singleThread () = 
{threadId; singleThread}

 end






module RestartFrameArguments : sig 
type t 
 val enc : t Data_encoding.t 
 val make : frameId:int -> unit -> t
end = struct 
 type t = { frameId: int; }

 let enc = 
 let open Data_encoding in 
 (* RestartFrameArguments.t *)
         conv 
 (fun {frameId} -> frameId)
 (fun frameId -> {frameId})
 (obj1
(req "frameId" int31))


 let make ~frameId () = 
{frameId}

 end






module GotoArguments : sig 
type t 
 val enc : t Data_encoding.t 
 val make : threadId:int -> targetId:int -> unit -> t
end = struct 
 type t = { threadId: int;
targetId: int; }

 let enc = 
 let open Data_encoding in 
 (* GotoArguments.t *)
         conv 
 (fun {threadId; targetId} -> (threadId, targetId))
 (fun (threadId, targetId) -> {threadId; targetId})
 (obj2
(req "threadId" int31)
(req "targetId" int31))


 let make ~threadId ~targetId () = 
{threadId; targetId}

 end






module PauseArguments : sig 
type t 
 val enc : t Data_encoding.t 
 val make : threadId:int -> unit -> t
end = struct 
 type t = { threadId: int; }

 let enc = 
 let open Data_encoding in 
 (* PauseArguments.t *)
         conv 
 (fun {threadId} -> threadId)
 (fun threadId -> {threadId})
 (obj1
(req "threadId" int31))


 let make ~threadId () = 
{threadId}

 end






module ValueFormat : sig 
type t 
 val enc : t Data_encoding.t 
 val make : ?hex:bool -> unit -> t
end = struct 
 type t = { hex: bool option; }

 let enc = 
 let open Data_encoding in 
 (* ValueFormat.t *)
         conv 
 (fun {hex} -> hex)
 (fun hex -> {hex})
 (obj1
(opt "hex" bool))


 let make ?hex () = 
{hex}

 end


module StackFrameFormat : sig 
type t 
 val enc : t Data_encoding.t 
 val make : ?hex:bool -> ?parameters:bool -> ?parameterTypes:bool -> ?parameterNames:bool -> ?parameterValues:bool -> ?line:bool -> ?module_:bool -> ?includeAll:bool -> unit -> t
end = struct 
 type t = { hex: bool option;
parameters: bool option;
parameterTypes: bool option;
parameterNames: bool option;
parameterValues: bool option;
line: bool option;
module_: bool option;
includeAll: bool option; }

 let enc = 
 let open Data_encoding in 
 (* StackFrameFormat.t *)
         conv 
 (fun {hex; parameters; parameterTypes; parameterNames; parameterValues; line; module_; includeAll} -> (hex, parameters, parameterTypes, parameterNames, parameterValues, line, module_, includeAll))
 (fun (hex, parameters, parameterTypes, parameterNames, parameterValues, line, module_, includeAll) -> {hex; parameters; parameterTypes; parameterNames; parameterValues; line; module_; includeAll})
 (obj8
(opt "hex" bool)
(opt "parameters" bool)
(opt "parameterTypes" bool)
(opt "parameterNames" bool)
(opt "parameterValues" bool)
(opt "line" bool)
(opt "module" bool)
(opt "includeAll" bool))


 let make ?hex ?parameters ?parameterTypes ?parameterNames ?parameterValues ?line ?module_ ?includeAll () = 
{hex; parameters; parameterTypes; parameterNames; parameterValues; line; module_; includeAll}

 end


module StackTraceArguments : sig 
type t 
 val enc : t Data_encoding.t 
 val make : threadId:int -> ?startFrame:int -> ?levels:int -> ?format:StackFrameFormat.t -> unit -> t
end = struct 
 type t = { threadId: int;
startFrame: int option;
levels: int option;
format: StackFrameFormat.t option; }

 let enc = 
 let open Data_encoding in 
 (* StackTraceArguments.t *)
         conv 
 (fun {threadId; startFrame; levels; format} -> (threadId, startFrame, levels, format))
 (fun (threadId, startFrame, levels, format) -> {threadId; startFrame; levels; format})
 (obj4
(req "threadId" int31)
(opt "startFrame" int31)
(opt "levels" int31)
(opt "format" StackFrameFormat.enc))


 let make ~threadId ?startFrame ?levels ?format () = 
{threadId; startFrame; levels; format}

 end




(* dont bother with a sig for enums, the inferred one is fine *)
 module StackFrame_presentationHint = struct 
 type t = Normal | Label | Subtle 

 let enc = 
 let open Data_encoding in 
 conv 
 (function Normal -> "normal" | Label -> "label" | Subtle -> "subtle")
 (function "normal" -> Normal | "label" -> Label | "subtle" -> Subtle | _ -> failwith "StackFrame_presentationHint")
 string

 end


module StackFrame : sig 
type t 
 val enc : t Data_encoding.t 
 val make : id:int -> name:string -> ?source:Source.t -> line:int -> column:int -> ?endLine:int -> ?endColumn:int -> ?canRestart:bool -> ?instructionPointerReference:string -> ?moduleId:IntString.t -> ?presentationHint:StackFrame_presentationHint.t -> unit -> t
end = struct 
 module StackFrame_0 : sig 
type t 
 val enc : t Data_encoding.t 
 val make : id:int -> name:string -> ?source:Source.t -> line:int -> column:int -> ?endLine:int -> ?endColumn:int -> ?canRestart:bool -> ?instructionPointerReference:string -> ?moduleId:IntString.t -> unit -> t
end = struct 
 type t = { id: int;
name: string;
source: Source.t option;
line: int;
column: int;
endLine: int option;
endColumn: int option;
canRestart: bool option;
instructionPointerReference: string option;
moduleId: IntString.t option; }

 let enc = 
 let open Data_encoding in 
 (* StackFrame_0.t *)
         conv 
 (fun {id; name; source; line; column; endLine; endColumn; canRestart; instructionPointerReference; moduleId} -> (id, name, source, line, column, endLine, endColumn, canRestart, instructionPointerReference, moduleId))
 (fun (id, name, source, line, column, endLine, endColumn, canRestart, instructionPointerReference, moduleId) -> {id; name; source; line; column; endLine; endColumn; canRestart; instructionPointerReference; moduleId})
 (obj10
(req "id" int31)
(req "name" string)
(opt "source" Source.enc)
(req "line" int31)
(req "column" int31)
(opt "endLine" int31)
(opt "endColumn" int31)
(opt "canRestart" bool)
(opt "instructionPointerReference" string)
(opt "moduleId" IntString.enc))


 let make ~id ~name ?source ~line ~column ?endLine ?endColumn ?canRestart ?instructionPointerReference ?moduleId () = 
{id; name; source; line; column; endLine; endColumn; canRestart; instructionPointerReference; moduleId}

 end


module StackFrame_10 : sig 
type t 
 val enc : t Data_encoding.t 
 val make : ?presentationHint:StackFrame_presentationHint.t -> unit -> t
end = struct 
 type t = { presentationHint: StackFrame_presentationHint.t option; }

 let enc = 
 let open Data_encoding in 
 (* StackFrame_10.t *)
         conv 
 (fun {presentationHint} -> presentationHint)
 (fun presentationHint -> {presentationHint})
 (obj1
(opt "presentationHint" StackFrame_presentationHint.enc))


 let make ?presentationHint () = 
{presentationHint}

 end


 type t = (StackFrame_0.t * StackFrame_10.t)

 let enc = 
 let open Data_encoding in 
 merge_objs StackFrame_0.enc StackFrame_10.enc

 let make ~id ~name ?source ~line ~column ?endLine ?endColumn ?canRestart ?instructionPointerReference ?moduleId ?presentationHint () = 
let t0 = StackFrame_0.make ~id ~name ?source ~line ~column ?endLine ?endColumn ?canRestart ?instructionPointerReference ?moduleId () in

let t1 = StackFrame_10.make ?presentationHint () in

(t0 , t1)

 end


module StackTraceResponse_body : sig 
type t 
 val enc : t Data_encoding.t 
 val make : stackFrames:StackFrame.t list -> ?totalFrames:int -> unit -> t
end = struct 
 type t = { stackFrames: StackFrame.t list;
totalFrames: int option; }

 let enc = 
 let open Data_encoding in 
 (* StackTraceResponse_body.t *)
         conv 
 (fun {stackFrames; totalFrames} -> (stackFrames, totalFrames))
 (fun (stackFrames, totalFrames) -> {stackFrames; totalFrames})
 (obj2
(req "stackFrames" (list StackFrame.enc))
(opt "totalFrames" int31))


 let make ~stackFrames ?totalFrames () = 
{stackFrames; totalFrames}

 end




module ScopesArguments : sig 
type t 
 val enc : t Data_encoding.t 
 val make : frameId:int -> unit -> t
end = struct 
 type t = { frameId: int; }

 let enc = 
 let open Data_encoding in 
 (* ScopesArguments.t *)
         conv 
 (fun {frameId} -> frameId)
 (fun frameId -> {frameId})
 (obj1
(req "frameId" int31))


 let make ~frameId () = 
{frameId}

 end




(* dont bother with a sig for enums, the inferred one is fine *)
 module Scope_presentationHint = struct 
 type t = Arguments | Locals | Registers | Other of string 

 let enc = 
 let open Data_encoding in 
 conv 
 (function Arguments -> "arguments" | Locals -> "locals" | Registers -> "registers" | Other s -> s)
 (function "arguments" -> Arguments | "locals" -> Locals | "registers" -> Registers | _ as s -> Other s)
 string

 end


module Scope : sig 
type t 
 val enc : t Data_encoding.t 
 val make : name:string -> ?presentationHint:Scope_presentationHint.t -> variablesReference:int -> ?namedVariables:int -> ?indexedVariables:int -> expensive:bool -> ?source:Source.t -> ?line:int -> ?column:int -> ?endLine:int -> ?endColumn:int -> unit -> t
end = struct 
 module Scope_0 : sig 
type t 
 val enc : t Data_encoding.t 
 val make : name:string -> ?presentationHint:Scope_presentationHint.t -> variablesReference:int -> ?namedVariables:int -> ?indexedVariables:int -> expensive:bool -> ?source:Source.t -> ?line:int -> ?column:int -> ?endLine:int -> unit -> t
end = struct 
 type t = { name: string;
presentationHint: Scope_presentationHint.t option;
variablesReference: int;
namedVariables: int option;
indexedVariables: int option;
expensive: bool;
source: Source.t option;
line: int option;
column: int option;
endLine: int option; }

 let enc = 
 let open Data_encoding in 
 (* Scope_0.t *)
         conv 
 (fun {name; presentationHint; variablesReference; namedVariables; indexedVariables; expensive; source; line; column; endLine} -> (name, presentationHint, variablesReference, namedVariables, indexedVariables, expensive, source, line, column, endLine))
 (fun (name, presentationHint, variablesReference, namedVariables, indexedVariables, expensive, source, line, column, endLine) -> {name; presentationHint; variablesReference; namedVariables; indexedVariables; expensive; source; line; column; endLine})
 (obj10
(req "name" string)
(opt "presentationHint" Scope_presentationHint.enc)
(req "variablesReference" int31)
(opt "namedVariables" int31)
(opt "indexedVariables" int31)
(req "expensive" bool)
(opt "source" Source.enc)
(opt "line" int31)
(opt "column" int31)
(opt "endLine" int31))


 let make ~name ?presentationHint ~variablesReference ?namedVariables ?indexedVariables ~expensive ?source ?line ?column ?endLine () = 
{name; presentationHint; variablesReference; namedVariables; indexedVariables; expensive; source; line; column; endLine}

 end


module Scope_10 : sig 
type t 
 val enc : t Data_encoding.t 
 val make : ?endColumn:int -> unit -> t
end = struct 
 type t = { endColumn: int option; }

 let enc = 
 let open Data_encoding in 
 (* Scope_10.t *)
         conv 
 (fun {endColumn} -> endColumn)
 (fun endColumn -> {endColumn})
 (obj1
(opt "endColumn" int31))


 let make ?endColumn () = 
{endColumn}

 end


 type t = (Scope_0.t * Scope_10.t)

 let enc = 
 let open Data_encoding in 
 merge_objs Scope_0.enc Scope_10.enc

 let make ~name ?presentationHint ~variablesReference ?namedVariables ?indexedVariables ~expensive ?source ?line ?column ?endLine ?endColumn () = 
let t0 = Scope_0.make ~name ?presentationHint ~variablesReference ?namedVariables ?indexedVariables ~expensive ?source ?line ?column ?endLine () in

let t1 = Scope_10.make ?endColumn () in

(t0 , t1)

 end


module ScopesResponse_body : sig 
type t 
 val enc : t Data_encoding.t 
 val make : scopes:Scope.t list -> unit -> t
end = struct 
 type t = { scopes: Scope.t list; }

 let enc = 
 let open Data_encoding in 
 (* ScopesResponse_body.t *)
         conv 
 (fun {scopes} -> scopes)
 (fun scopes -> {scopes})
 (obj1
(req "scopes" (list Scope.enc)))


 let make ~scopes () = 
{scopes}

 end




(* dont bother with a sig for enums, the inferred one is fine *)
 module VariablesArguments_filter = struct 
 type t = Indexed | Named 

 let enc = 
 let open Data_encoding in 
 conv 
 (function Indexed -> "indexed" | Named -> "named")
 (function "indexed" -> Indexed | "named" -> Named | _ -> failwith "VariablesArguments_filter")
 string

 end


module VariablesArguments : sig 
type t 
 val enc : t Data_encoding.t 
 val make : variablesReference:int -> ?filter:VariablesArguments_filter.t -> ?start:int -> ?count:int -> ?format:ValueFormat.t -> unit -> t
end = struct 
 type t = { variablesReference: int;
filter: VariablesArguments_filter.t option;
start: int option;
count: int option;
format: ValueFormat.t option; }

 let enc = 
 let open Data_encoding in 
 (* VariablesArguments.t *)
         conv 
 (fun {variablesReference; filter; start; count; format} -> (variablesReference, filter, start, count, format))
 (fun (variablesReference, filter, start, count, format) -> {variablesReference; filter; start; count; format})
 (obj5
(req "variablesReference" int31)
(opt "filter" VariablesArguments_filter.enc)
(opt "start" int31)
(opt "count" int31)
(opt "format" ValueFormat.enc))


 let make ~variablesReference ?filter ?start ?count ?format () = 
{variablesReference; filter; start; count; format}

 end




(* dont bother with a sig for enums, the inferred one is fine *)
 module VariablePresentationHint_kind = struct 
 type t = Property | Method | Class | Data | Event | BaseClass | InnerClass | Interface | MostDerivedClass | Virtual | DataBreakpoint | Other of string 

 let enc = 
 let open Data_encoding in 
 conv 
 (function Property -> "property" | Method -> "method" | Class -> "class" | Data -> "data" | Event -> "event" | BaseClass -> "baseClass" | InnerClass -> "innerClass" | Interface -> "interface" | MostDerivedClass -> "mostDerivedClass" | Virtual -> "virtual" | DataBreakpoint -> "dataBreakpoint" | Other s -> s)
 (function "property" -> Property | "method" -> Method | "class" -> Class | "data" -> Data | "event" -> Event | "baseClass" -> BaseClass | "innerClass" -> InnerClass | "interface" -> Interface | "mostDerivedClass" -> MostDerivedClass | "virtual" -> Virtual | "dataBreakpoint" -> DataBreakpoint | _ as s -> Other s)
 string

 end


(* dont bother with a sig for enums, the inferred one is fine *)
 module VariablePresentationHint_attributes_items = struct 
 type t = Static | Constant | ReadOnly | RawString | HasObjectId | CanHaveObjectId | HasSideEffects | HasDataBreakpoint | Other of string 

 let enc = 
 let open Data_encoding in 
 conv 
 (function Static -> "static" | Constant -> "constant" | ReadOnly -> "readOnly" | RawString -> "rawString" | HasObjectId -> "hasObjectId" | CanHaveObjectId -> "canHaveObjectId" | HasSideEffects -> "hasSideEffects" | HasDataBreakpoint -> "hasDataBreakpoint" | Other s -> s)
 (function "static" -> Static | "constant" -> Constant | "readOnly" -> ReadOnly | "rawString" -> RawString | "hasObjectId" -> HasObjectId | "canHaveObjectId" -> CanHaveObjectId | "hasSideEffects" -> HasSideEffects | "hasDataBreakpoint" -> HasDataBreakpoint | _ as s -> Other s)
 string

 end


(* dont bother with a sig for enums, the inferred one is fine *)
 module VariablePresentationHint_visibility = struct 
 type t = Public | Private | Protected | Internal | Final | Other of string 

 let enc = 
 let open Data_encoding in 
 conv 
 (function Public -> "public" | Private -> "private" | Protected -> "protected" | Internal -> "internal" | Final -> "final" | Other s -> s)
 (function "public" -> Public | "private" -> Private | "protected" -> Protected | "internal" -> Internal | "final" -> Final | _ as s -> Other s)
 string

 end


module VariablePresentationHint : sig 
type t 
 val enc : t Data_encoding.t 
 val make : ?kind:VariablePresentationHint_kind.t -> ?attributes:VariablePresentationHint_attributes_items.t list -> ?visibility:VariablePresentationHint_visibility.t -> ?lazy_:bool -> unit -> t
end = struct 
 type t = { kind: VariablePresentationHint_kind.t option;
attributes: VariablePresentationHint_attributes_items.t list option;
visibility: VariablePresentationHint_visibility.t option;
lazy_: bool option; }

 let enc = 
 let open Data_encoding in 
 (* VariablePresentationHint.t *)
         conv 
 (fun {kind; attributes; visibility; lazy_} -> (kind, attributes, visibility, lazy_))
 (fun (kind, attributes, visibility, lazy_) -> {kind; attributes; visibility; lazy_})
 (obj4
(opt "kind" VariablePresentationHint_kind.enc)
(opt "attributes" (list VariablePresentationHint_attributes_items.enc))
(opt "visibility" VariablePresentationHint_visibility.enc)
(opt "lazy" bool))


 let make ?kind ?attributes ?visibility ?lazy_ () = 
{kind; attributes; visibility; lazy_}

 end


module Variable_ : sig 
type t 
 val enc : t Data_encoding.t 
 val make : name:string -> value:string -> ?type_:string -> ?presentationHint:VariablePresentationHint.t -> ?evaluateName:string -> variablesReference:int -> ?namedVariables:int -> ?indexedVariables:int -> ?memoryReference:string -> unit -> t
end = struct 
 type t = { name: string;
value: string;
type_: string option;
presentationHint: VariablePresentationHint.t option;
evaluateName: string option;
variablesReference: int;
namedVariables: int option;
indexedVariables: int option;
memoryReference: string option; }

 let enc = 
 let open Data_encoding in 
 (* Variable_.t *)
         conv 
 (fun {name; value; type_; presentationHint; evaluateName; variablesReference; namedVariables; indexedVariables; memoryReference} -> (name, value, type_, presentationHint, evaluateName, variablesReference, namedVariables, indexedVariables, memoryReference))
 (fun (name, value, type_, presentationHint, evaluateName, variablesReference, namedVariables, indexedVariables, memoryReference) -> {name; value; type_; presentationHint; evaluateName; variablesReference; namedVariables; indexedVariables; memoryReference})
 (obj9
(req "name" string)
(req "value" string)
(opt "type" string)
(opt "presentationHint" VariablePresentationHint.enc)
(opt "evaluateName" string)
(req "variablesReference" int31)
(opt "namedVariables" int31)
(opt "indexedVariables" int31)
(opt "memoryReference" string))


 let make ~name ~value ?type_ ?presentationHint ?evaluateName ~variablesReference ?namedVariables ?indexedVariables ?memoryReference () = 
{name; value; type_; presentationHint; evaluateName; variablesReference; namedVariables; indexedVariables; memoryReference}

 end


module VariablesResponse_body : sig 
type t 
 val enc : t Data_encoding.t 
 val make : variables:Variable_.t list -> unit -> t
end = struct 
 type t = { variables: Variable_.t list; }

 let enc = 
 let open Data_encoding in 
 (* VariablesResponse_body.t *)
         conv 
 (fun {variables} -> variables)
 (fun variables -> {variables})
 (obj1
(req "variables" (list Variable_.enc)))


 let make ~variables () = 
{variables}

 end




module SetVariableArguments : sig 
type t 
 val enc : t Data_encoding.t 
 val make : variablesReference:int -> name:string -> value:string -> ?format:ValueFormat.t -> unit -> t
end = struct 
 type t = { variablesReference: int;
name: string;
value: string;
format: ValueFormat.t option; }

 let enc = 
 let open Data_encoding in 
 (* SetVariableArguments.t *)
         conv 
 (fun {variablesReference; name; value; format} -> (variablesReference, name, value, format))
 (fun (variablesReference, name, value, format) -> {variablesReference; name; value; format})
 (obj4
(req "variablesReference" int31)
(req "name" string)
(req "value" string)
(opt "format" ValueFormat.enc))


 let make ~variablesReference ~name ~value ?format () = 
{variablesReference; name; value; format}

 end




module SetVariableResponse_body : sig 
type t 
 val enc : t Data_encoding.t 
 val make : value:string -> ?type_:string -> ?variablesReference:int -> ?namedVariables:int -> ?indexedVariables:int -> unit -> t
end = struct 
 type t = { value: string;
type_: string option;
variablesReference: int option;
namedVariables: int option;
indexedVariables: int option; }

 let enc = 
 let open Data_encoding in 
 (* SetVariableResponse_body.t *)
         conv 
 (fun {value; type_; variablesReference; namedVariables; indexedVariables} -> (value, type_, variablesReference, namedVariables, indexedVariables))
 (fun (value, type_, variablesReference, namedVariables, indexedVariables) -> {value; type_; variablesReference; namedVariables; indexedVariables})
 (obj5
(req "value" string)
(opt "type" string)
(opt "variablesReference" int31)
(opt "namedVariables" int31)
(opt "indexedVariables" int31))


 let make ~value ?type_ ?variablesReference ?namedVariables ?indexedVariables () = 
{value; type_; variablesReference; namedVariables; indexedVariables}

 end




module SourceArguments : sig 
type t 
 val enc : t Data_encoding.t 
 val make : ?source:Source.t -> sourceReference:int -> unit -> t
end = struct 
 type t = { source: Source.t option;
sourceReference: int; }

 let enc = 
 let open Data_encoding in 
 (* SourceArguments.t *)
         conv 
 (fun {source; sourceReference} -> (source, sourceReference))
 (fun (source, sourceReference) -> {source; sourceReference})
 (obj2
(opt "source" Source.enc)
(req "sourceReference" int31))


 let make ?source ~sourceReference () = 
{source; sourceReference}

 end




module SourceResponse_body : sig 
type t 
 val enc : t Data_encoding.t 
 val make : content:string -> ?mimeType:string -> unit -> t
end = struct 
 type t = { content: string;
mimeType: string option; }

 let enc = 
 let open Data_encoding in 
 (* SourceResponse_body.t *)
         conv 
 (fun {content; mimeType} -> (content, mimeType))
 (fun (content, mimeType) -> {content; mimeType})
 (obj2
(req "content" string)
(opt "mimeType" string))


 let make ~content ?mimeType () = 
{content; mimeType}

 end






module Thread : sig 
type t 
 val enc : t Data_encoding.t 
 val make : id:int -> name:string -> unit -> t
end = struct 
 type t = { id: int;
name: string; }

 let enc = 
 let open Data_encoding in 
 (* Thread.t *)
         conv 
 (fun {id; name} -> (id, name))
 (fun (id, name) -> {id; name})
 (obj2
(req "id" int31)
(req "name" string))


 let make ~id ~name () = 
{id; name}

 end


module ThreadsResponse_body : sig 
type t 
 val enc : t Data_encoding.t 
 val make : threads:Thread.t list -> unit -> t
end = struct 
 type t = { threads: Thread.t list; }

 let enc = 
 let open Data_encoding in 
 (* ThreadsResponse_body.t *)
         conv 
 (fun {threads} -> threads)
 (fun threads -> {threads})
 (obj1
(req "threads" (list Thread.enc)))


 let make ~threads () = 
{threads}

 end




module TerminateThreadsArguments : sig 
type t 
 val enc : t Data_encoding.t 
 val make : ?threadIds:int list -> unit -> t
end = struct 
 type t = { threadIds: int list option; }

 let enc = 
 let open Data_encoding in 
 (* TerminateThreadsArguments.t *)
         conv 
 (fun {threadIds} -> threadIds)
 (fun threadIds -> {threadIds})
 (obj1
(opt "threadIds" (list int31)))


 let make ?threadIds () = 
{threadIds}

 end






module ModulesArguments : sig 
type t 
 val enc : t Data_encoding.t 
 val make : ?startModule:int -> ?moduleCount:int -> unit -> t
end = struct 
 type t = { startModule: int option;
moduleCount: int option; }

 let enc = 
 let open Data_encoding in 
 (* ModulesArguments.t *)
         conv 
 (fun {startModule; moduleCount} -> (startModule, moduleCount))
 (fun (startModule, moduleCount) -> {startModule; moduleCount})
 (obj2
(opt "startModule" int31)
(opt "moduleCount" int31))


 let make ?startModule ?moduleCount () = 
{startModule; moduleCount}

 end




module ModulesResponse_body : sig 
type t 
 val enc : t Data_encoding.t 
 val make : modules:Module_.t list -> ?totalModules:int -> unit -> t
end = struct 
 type t = { modules: Module_.t list;
totalModules: int option; }

 let enc = 
 let open Data_encoding in 
 (* ModulesResponse_body.t *)
         conv 
 (fun {modules; totalModules} -> (modules, totalModules))
 (fun (modules, totalModules) -> {modules; totalModules})
 (obj2
(req "modules" (list Module_.enc))
(opt "totalModules" int31))


 let make ~modules ?totalModules () = 
{modules; totalModules}

 end




module LoadedSourcesArguments : sig 
 type t 
 val enc : t Data_encoding.t 
 val make : unit -> t 
 end = struct 
 type t = unit

 let enc = Data_encoding.empty

 let make () = () 

 end




module LoadedSourcesResponse_body : sig 
type t 
 val enc : t Data_encoding.t 
 val make : sources:Source.t list -> unit -> t
end = struct 
 type t = { sources: Source.t list; }

 let enc = 
 let open Data_encoding in 
 (* LoadedSourcesResponse_body.t *)
         conv 
 (fun {sources} -> sources)
 (fun sources -> {sources})
 (obj1
(req "sources" (list Source.enc)))


 let make ~sources () = 
{sources}

 end




(* dont bother with a sig for enums, the inferred one is fine *)
 module EvaluateArguments_context = struct 
 type t = Variables | Watch | Repl | Hover | Clipboard | Other of string 

 let enc = 
 let open Data_encoding in 
 conv 
 (function Variables -> "variables" | Watch -> "watch" | Repl -> "repl" | Hover -> "hover" | Clipboard -> "clipboard" | Other s -> s)
 (function "variables" -> Variables | "watch" -> Watch | "repl" -> Repl | "hover" -> Hover | "clipboard" -> Clipboard | _ as s -> Other s)
 string

 end


module EvaluateArguments : sig 
type t 
 val enc : t Data_encoding.t 
 val make : expression:string -> ?frameId:int -> ?context:EvaluateArguments_context.t -> ?format:ValueFormat.t -> unit -> t
end = struct 
 type t = { expression: string;
frameId: int option;
context: EvaluateArguments_context.t option;
format: ValueFormat.t option; }

 let enc = 
 let open Data_encoding in 
 (* EvaluateArguments.t *)
         conv 
 (fun {expression; frameId; context; format} -> (expression, frameId, context, format))
 (fun (expression, frameId, context, format) -> {expression; frameId; context; format})
 (obj4
(req "expression" string)
(opt "frameId" int31)
(opt "context" EvaluateArguments_context.enc)
(opt "format" ValueFormat.enc))


 let make ~expression ?frameId ?context ?format () = 
{expression; frameId; context; format}

 end




module EvaluateResponse_body : sig 
type t 
 val enc : t Data_encoding.t 
 val make : result:string -> ?type_:string -> ?presentationHint:VariablePresentationHint.t -> variablesReference:int -> ?namedVariables:int -> ?indexedVariables:int -> ?memoryReference:string -> unit -> t
end = struct 
 type t = { result: string;
type_: string option;
presentationHint: VariablePresentationHint.t option;
variablesReference: int;
namedVariables: int option;
indexedVariables: int option;
memoryReference: string option; }

 let enc = 
 let open Data_encoding in 
 (* EvaluateResponse_body.t *)
         conv 
 (fun {result; type_; presentationHint; variablesReference; namedVariables; indexedVariables; memoryReference} -> (result, type_, presentationHint, variablesReference, namedVariables, indexedVariables, memoryReference))
 (fun (result, type_, presentationHint, variablesReference, namedVariables, indexedVariables, memoryReference) -> {result; type_; presentationHint; variablesReference; namedVariables; indexedVariables; memoryReference})
 (obj7
(req "result" string)
(opt "type" string)
(opt "presentationHint" VariablePresentationHint.enc)
(req "variablesReference" int31)
(opt "namedVariables" int31)
(opt "indexedVariables" int31)
(opt "memoryReference" string))


 let make ~result ?type_ ?presentationHint ~variablesReference ?namedVariables ?indexedVariables ?memoryReference () = 
{result; type_; presentationHint; variablesReference; namedVariables; indexedVariables; memoryReference}

 end




module SetExpressionArguments : sig 
type t 
 val enc : t Data_encoding.t 
 val make : expression:string -> value:string -> ?frameId:int -> ?format:ValueFormat.t -> unit -> t
end = struct 
 type t = { expression: string;
value: string;
frameId: int option;
format: ValueFormat.t option; }

 let enc = 
 let open Data_encoding in 
 (* SetExpressionArguments.t *)
         conv 
 (fun {expression; value; frameId; format} -> (expression, value, frameId, format))
 (fun (expression, value, frameId, format) -> {expression; value; frameId; format})
 (obj4
(req "expression" string)
(req "value" string)
(opt "frameId" int31)
(opt "format" ValueFormat.enc))


 let make ~expression ~value ?frameId ?format () = 
{expression; value; frameId; format}

 end




module SetExpressionResponse_body : sig 
type t 
 val enc : t Data_encoding.t 
 val make : value:string -> ?type_:string -> ?presentationHint:VariablePresentationHint.t -> ?variablesReference:int -> ?namedVariables:int -> ?indexedVariables:int -> unit -> t
end = struct 
 type t = { value: string;
type_: string option;
presentationHint: VariablePresentationHint.t option;
variablesReference: int option;
namedVariables: int option;
indexedVariables: int option; }

 let enc = 
 let open Data_encoding in 
 (* SetExpressionResponse_body.t *)
         conv 
 (fun {value; type_; presentationHint; variablesReference; namedVariables; indexedVariables} -> (value, type_, presentationHint, variablesReference, namedVariables, indexedVariables))
 (fun (value, type_, presentationHint, variablesReference, namedVariables, indexedVariables) -> {value; type_; presentationHint; variablesReference; namedVariables; indexedVariables})
 (obj6
(req "value" string)
(opt "type" string)
(opt "presentationHint" VariablePresentationHint.enc)
(opt "variablesReference" int31)
(opt "namedVariables" int31)
(opt "indexedVariables" int31))


 let make ~value ?type_ ?presentationHint ?variablesReference ?namedVariables ?indexedVariables () = 
{value; type_; presentationHint; variablesReference; namedVariables; indexedVariables}

 end




module StepInTargetsArguments : sig 
type t 
 val enc : t Data_encoding.t 
 val make : frameId:int -> unit -> t
end = struct 
 type t = { frameId: int; }

 let enc = 
 let open Data_encoding in 
 (* StepInTargetsArguments.t *)
         conv 
 (fun {frameId} -> frameId)
 (fun frameId -> {frameId})
 (obj1
(req "frameId" int31))


 let make ~frameId () = 
{frameId}

 end




module StepInTarget : sig 
type t 
 val enc : t Data_encoding.t 
 val make : id:int -> label:string -> ?line:int -> ?column:int -> ?endLine:int -> ?endColumn:int -> unit -> t
end = struct 
 type t = { id: int;
label: string;
line: int option;
column: int option;
endLine: int option;
endColumn: int option; }

 let enc = 
 let open Data_encoding in 
 (* StepInTarget.t *)
         conv 
 (fun {id; label; line; column; endLine; endColumn} -> (id, label, line, column, endLine, endColumn))
 (fun (id, label, line, column, endLine, endColumn) -> {id; label; line; column; endLine; endColumn})
 (obj6
(req "id" int31)
(req "label" string)
(opt "line" int31)
(opt "column" int31)
(opt "endLine" int31)
(opt "endColumn" int31))


 let make ~id ~label ?line ?column ?endLine ?endColumn () = 
{id; label; line; column; endLine; endColumn}

 end


module StepInTargetsResponse_body : sig 
type t 
 val enc : t Data_encoding.t 
 val make : targets:StepInTarget.t list -> unit -> t
end = struct 
 type t = { targets: StepInTarget.t list; }

 let enc = 
 let open Data_encoding in 
 (* StepInTargetsResponse_body.t *)
         conv 
 (fun {targets} -> targets)
 (fun targets -> {targets})
 (obj1
(req "targets" (list StepInTarget.enc)))


 let make ~targets () = 
{targets}

 end




module GotoTargetsArguments : sig 
type t 
 val enc : t Data_encoding.t 
 val make : source:Source.t -> line:int -> ?column:int -> unit -> t
end = struct 
 type t = { source: Source.t;
line: int;
column: int option; }

 let enc = 
 let open Data_encoding in 
 (* GotoTargetsArguments.t *)
         conv 
 (fun {source; line; column} -> (source, line, column))
 (fun (source, line, column) -> {source; line; column})
 (obj3
(req "source" Source.enc)
(req "line" int31)
(opt "column" int31))


 let make ~source ~line ?column () = 
{source; line; column}

 end




module GotoTarget : sig 
type t 
 val enc : t Data_encoding.t 
 val make : id:int -> label:string -> line:int -> ?column:int -> ?endLine:int -> ?endColumn:int -> ?instructionPointerReference:string -> unit -> t
end = struct 
 type t = { id: int;
label: string;
line: int;
column: int option;
endLine: int option;
endColumn: int option;
instructionPointerReference: string option; }

 let enc = 
 let open Data_encoding in 
 (* GotoTarget.t *)
         conv 
 (fun {id; label; line; column; endLine; endColumn; instructionPointerReference} -> (id, label, line, column, endLine, endColumn, instructionPointerReference))
 (fun (id, label, line, column, endLine, endColumn, instructionPointerReference) -> {id; label; line; column; endLine; endColumn; instructionPointerReference})
 (obj7
(req "id" int31)
(req "label" string)
(req "line" int31)
(opt "column" int31)
(opt "endLine" int31)
(opt "endColumn" int31)
(opt "instructionPointerReference" string))


 let make ~id ~label ~line ?column ?endLine ?endColumn ?instructionPointerReference () = 
{id; label; line; column; endLine; endColumn; instructionPointerReference}

 end


module GotoTargetsResponse_body : sig 
type t 
 val enc : t Data_encoding.t 
 val make : targets:GotoTarget.t list -> unit -> t
end = struct 
 type t = { targets: GotoTarget.t list; }

 let enc = 
 let open Data_encoding in 
 (* GotoTargetsResponse_body.t *)
         conv 
 (fun {targets} -> targets)
 (fun targets -> {targets})
 (obj1
(req "targets" (list GotoTarget.enc)))


 let make ~targets () = 
{targets}

 end




module CompletionsArguments : sig 
type t 
 val enc : t Data_encoding.t 
 val make : ?frameId:int -> text:string -> column:int -> ?line:int -> unit -> t
end = struct 
 type t = { frameId: int option;
text: string;
column: int;
line: int option; }

 let enc = 
 let open Data_encoding in 
 (* CompletionsArguments.t *)
         conv 
 (fun {frameId; text; column; line} -> (frameId, text, column, line))
 (fun (frameId, text, column, line) -> {frameId; text; column; line})
 (obj4
(opt "frameId" int31)
(req "text" string)
(req "column" int31)
(opt "line" int31))


 let make ?frameId ~text ~column ?line () = 
{frameId; text; column; line}

 end




(* dont bother with a sig for enums, the inferred one is fine *)
 module CompletionItemType = struct 
 type t = Method | Function | Constructor | Field | Variable_ | Class | Interface | Module_ | Property | Unit | Value | Enum | Keyword | Snippet | Text | Color | File | Reference | Customcolor 

 let enc = 
 let open Data_encoding in 
 conv 
 (function Method -> "method" | Function -> "function" | Constructor -> "constructor" | Field -> "field" | Variable_ -> "variable" | Class -> "class" | Interface -> "interface" | Module_ -> "module" | Property -> "property" | Unit -> "unit" | Value -> "value" | Enum -> "enum" | Keyword -> "keyword" | Snippet -> "snippet" | Text -> "text" | Color -> "color" | File -> "file" | Reference -> "reference" | Customcolor -> "customcolor")
 (function "method" -> Method | "function" -> Function | "constructor" -> Constructor | "field" -> Field | "variable" -> Variable_ | "class" -> Class | "interface" -> Interface | "module" -> Module_ | "property" -> Property | "unit" -> Unit | "value" -> Value | "enum" -> Enum | "keyword" -> Keyword | "snippet" -> Snippet | "text" -> Text | "color" -> Color | "file" -> File | "reference" -> Reference | "customcolor" -> Customcolor | _ -> failwith "CompletionItemType")
 string

 end


module CompletionItem : sig 
type t 
 val enc : t Data_encoding.t 
 val make : label:string -> ?text:string -> ?sortText:string -> ?detail:string -> ?type_:CompletionItemType.t -> ?start:int -> ?length:int -> ?selectionStart:int -> ?selectionLength:int -> unit -> t
end = struct 
 type t = { label: string;
text: string option;
sortText: string option;
detail: string option;
type_: CompletionItemType.t option;
start: int option;
length: int option;
selectionStart: int option;
selectionLength: int option; }

 let enc = 
 let open Data_encoding in 
 (* CompletionItem.t *)
         conv 
 (fun {label; text; sortText; detail; type_; start; length; selectionStart; selectionLength} -> (label, text, sortText, detail, type_, start, length, selectionStart, selectionLength))
 (fun (label, text, sortText, detail, type_, start, length, selectionStart, selectionLength) -> {label; text; sortText; detail; type_; start; length; selectionStart; selectionLength})
 (obj9
(req "label" string)
(opt "text" string)
(opt "sortText" string)
(opt "detail" string)
(opt "type" CompletionItemType.enc)
(opt "start" int31)
(opt "length" int31)
(opt "selectionStart" int31)
(opt "selectionLength" int31))


 let make ~label ?text ?sortText ?detail ?type_ ?start ?length ?selectionStart ?selectionLength () = 
{label; text; sortText; detail; type_; start; length; selectionStart; selectionLength}

 end


module CompletionsResponse_body : sig 
type t 
 val enc : t Data_encoding.t 
 val make : targets:CompletionItem.t list -> unit -> t
end = struct 
 type t = { targets: CompletionItem.t list; }

 let enc = 
 let open Data_encoding in 
 (* CompletionsResponse_body.t *)
         conv 
 (fun {targets} -> targets)
 (fun targets -> {targets})
 (obj1
(req "targets" (list CompletionItem.enc)))


 let make ~targets () = 
{targets}

 end




module ExceptionInfoArguments : sig 
type t 
 val enc : t Data_encoding.t 
 val make : threadId:int -> unit -> t
end = struct 
 type t = { threadId: int; }

 let enc = 
 let open Data_encoding in 
 (* ExceptionInfoArguments.t *)
         conv 
 (fun {threadId} -> threadId)
 (fun threadId -> {threadId})
 (obj1
(req "threadId" int31))


 let make ~threadId () = 
{threadId}

 end




module ExceptionDetails : sig 
type t 
 val enc : t Data_encoding.t 
 val make : ?message:string -> ?typeName:string -> ?fullTypeName:string -> ?evaluateName:string -> ?stackTrace:string -> ?innerException:t list -> unit -> t
end = struct 
 type t = { message: string option;
typeName: string option;
fullTypeName: string option;
evaluateName: string option;
stackTrace: string option;
innerException: t list option; }

 let enc = 
 let open Data_encoding in 
 mu "ExceptionDetails.t" 
 ( fun e -> 
 conv 
 (fun {message; typeName; fullTypeName; evaluateName; stackTrace; innerException} -> (message, typeName, fullTypeName, evaluateName, stackTrace, innerException))
 (fun (message, typeName, fullTypeName, evaluateName, stackTrace, innerException) -> {message; typeName; fullTypeName; evaluateName; stackTrace; innerException})
 (obj6
(opt "message" string)
(opt "typeName" string)
(opt "fullTypeName" string)
(opt "evaluateName" string)
(opt "stackTrace" string)
(opt "innerException" (list e)))
)

 let make ?message ?typeName ?fullTypeName ?evaluateName ?stackTrace ?innerException () = 
{message; typeName; fullTypeName; evaluateName; stackTrace; innerException}

 end


module ExceptionInfoResponse_body : sig 
type t 
 val enc : t Data_encoding.t 
 val make : exceptionId:string -> ?description:string -> breakMode:ExceptionBreakMode.t -> ?details:ExceptionDetails.t -> unit -> t
end = struct 
 type t = { exceptionId: string;
description: string option;
breakMode: ExceptionBreakMode.t;
details: ExceptionDetails.t option; }

 let enc = 
 let open Data_encoding in 
 (* ExceptionInfoResponse_body.t *)
         conv 
 (fun {exceptionId; description; breakMode; details} -> (exceptionId, description, breakMode, details))
 (fun (exceptionId, description, breakMode, details) -> {exceptionId; description; breakMode; details})
 (obj4
(req "exceptionId" string)
(opt "description" string)
(req "breakMode" ExceptionBreakMode.enc)
(opt "details" ExceptionDetails.enc))


 let make ~exceptionId ?description ~breakMode ?details () = 
{exceptionId; description; breakMode; details}

 end




module ReadMemoryArguments : sig 
type t 
 val enc : t Data_encoding.t 
 val make : memoryReference:string -> ?offset:int -> count:int -> unit -> t
end = struct 
 type t = { memoryReference: string;
offset: int option;
count: int; }

 let enc = 
 let open Data_encoding in 
 (* ReadMemoryArguments.t *)
         conv 
 (fun {memoryReference; offset; count} -> (memoryReference, offset, count))
 (fun (memoryReference, offset, count) -> {memoryReference; offset; count})
 (obj3
(req "memoryReference" string)
(opt "offset" int31)
(req "count" int31))


 let make ~memoryReference ?offset ~count () = 
{memoryReference; offset; count}

 end




module ReadMemoryResponse_body : sig 
type t 
 val enc : t Data_encoding.t 
 val make : address:string -> ?unreadableBytes:int -> ?data:string -> unit -> t
end = struct 
 type t = { address: string;
unreadableBytes: int option;
data: string option; }

 let enc = 
 let open Data_encoding in 
 (* ReadMemoryResponse_body.t *)
         conv 
 (fun {address; unreadableBytes; data} -> (address, unreadableBytes, data))
 (fun (address, unreadableBytes, data) -> {address; unreadableBytes; data})
 (obj3
(req "address" string)
(opt "unreadableBytes" int31)
(opt "data" string))


 let make ~address ?unreadableBytes ?data () = 
{address; unreadableBytes; data}

 end




module WriteMemoryArguments : sig 
type t 
 val enc : t Data_encoding.t 
 val make : memoryReference:string -> ?offset:int -> ?allowPartial:bool -> data:string -> unit -> t
end = struct 
 type t = { memoryReference: string;
offset: int option;
allowPartial: bool option;
data: string; }

 let enc = 
 let open Data_encoding in 
 (* WriteMemoryArguments.t *)
         conv 
 (fun {memoryReference; offset; allowPartial; data} -> (memoryReference, offset, allowPartial, data))
 (fun (memoryReference, offset, allowPartial, data) -> {memoryReference; offset; allowPartial; data})
 (obj4
(req "memoryReference" string)
(opt "offset" int31)
(opt "allowPartial" bool)
(req "data" string))


 let make ~memoryReference ?offset ?allowPartial ~data () = 
{memoryReference; offset; allowPartial; data}

 end




module WriteMemoryResponse_body : sig 
type t 
 val enc : t Data_encoding.t 
 val make : ?offset:int -> ?bytesWritten:int -> unit -> t
end = struct 
 type t = { offset: int option;
bytesWritten: int option; }

 let enc = 
 let open Data_encoding in 
 (* WriteMemoryResponse_body.t *)
         conv 
 (fun {offset; bytesWritten} -> (offset, bytesWritten))
 (fun (offset, bytesWritten) -> {offset; bytesWritten})
 (obj2
(opt "offset" int31)
(opt "bytesWritten" int31))


 let make ?offset ?bytesWritten () = 
{offset; bytesWritten}

 end




module DisassembleArguments : sig 
type t 
 val enc : t Data_encoding.t 
 val make : memoryReference:string -> ?offset:int -> ?instructionOffset:int -> instructionCount:int -> ?resolveSymbols:bool -> unit -> t
end = struct 
 type t = { memoryReference: string;
offset: int option;
instructionOffset: int option;
instructionCount: int;
resolveSymbols: bool option; }

 let enc = 
 let open Data_encoding in 
 (* DisassembleArguments.t *)
         conv 
 (fun {memoryReference; offset; instructionOffset; instructionCount; resolveSymbols} -> (memoryReference, offset, instructionOffset, instructionCount, resolveSymbols))
 (fun (memoryReference, offset, instructionOffset, instructionCount, resolveSymbols) -> {memoryReference; offset; instructionOffset; instructionCount; resolveSymbols})
 (obj5
(req "memoryReference" string)
(opt "offset" int31)
(opt "instructionOffset" int31)
(req "instructionCount" int31)
(opt "resolveSymbols" bool))


 let make ~memoryReference ?offset ?instructionOffset ~instructionCount ?resolveSymbols () = 
{memoryReference; offset; instructionOffset; instructionCount; resolveSymbols}

 end




module DisassembledInstruction : sig 
type t 
 val enc : t Data_encoding.t 
 val make : address:string -> ?instructionBytes:string -> instruction:string -> ?symbol:string -> ?location:Source.t -> ?line:int -> ?column:int -> ?endLine:int -> ?endColumn:int -> unit -> t
end = struct 
 type t = { address: string;
instructionBytes: string option;
instruction: string;
symbol: string option;
location: Source.t option;
line: int option;
column: int option;
endLine: int option;
endColumn: int option; }

 let enc = 
 let open Data_encoding in 
 (* DisassembledInstruction.t *)
         conv 
 (fun {address; instructionBytes; instruction; symbol; location; line; column; endLine; endColumn} -> (address, instructionBytes, instruction, symbol, location, line, column, endLine, endColumn))
 (fun (address, instructionBytes, instruction, symbol, location, line, column, endLine, endColumn) -> {address; instructionBytes; instruction; symbol; location; line; column; endLine; endColumn})
 (obj9
(req "address" string)
(opt "instructionBytes" string)
(req "instruction" string)
(opt "symbol" string)
(opt "location" Source.enc)
(opt "line" int31)
(opt "column" int31)
(opt "endLine" int31)
(opt "endColumn" int31))


 let make ~address ?instructionBytes ~instruction ?symbol ?location ?line ?column ?endLine ?endColumn () = 
{address; instructionBytes; instruction; symbol; location; line; column; endLine; endColumn}

 end


module DisassembleResponse_body : sig 
type t 
 val enc : t Data_encoding.t 
 val make : instructions:DisassembledInstruction.t list -> unit -> t
end = struct 
 type t = { instructions: DisassembledInstruction.t list; }

 let enc = 
 let open Data_encoding in 
 (* DisassembleResponse_body.t *)
         conv 
 (fun {instructions} -> instructions)
 (fun instructions -> {instructions})
 (obj1
(req "instructions" (list DisassembledInstruction.enc)))


 let make ~instructions () = 
{instructions}

 end




module ModulesViewDescriptor : sig 
type t 
 val enc : t Data_encoding.t 
 val make : columns:ColumnDescriptor.t list -> unit -> t
end = struct 
 type t = { columns: ColumnDescriptor.t list; }

 let enc = 
 let open Data_encoding in 
 (* ModulesViewDescriptor.t *)
         conv 
 (fun {columns} -> columns)
 (fun columns -> {columns})
 (obj1
(req "columns" (list ColumnDescriptor.enc)))


 let make ~columns () = 
{columns}

 end


 type (_,_,_) request = 
| CancelRequest : (Dap_commands.cancel, CancelArguments.t option, RequestMessage.opt) RequestMessage.t -> (Dap_commands.cancel, CancelArguments.t option, RequestMessage.opt) request
| RunInTerminalRequest : (Dap_commands.runInTerminal, RunInTerminalRequestArguments.t, RequestMessage.req) RequestMessage.t -> (Dap_commands.runInTerminal, RunInTerminalRequestArguments.t, RequestMessage.req) request
| InitializeRequest : (Dap_commands.initialize, InitializeRequestArguments.t, RequestMessage.req) RequestMessage.t -> (Dap_commands.initialize, InitializeRequestArguments.t, RequestMessage.req) request
| ConfigurationDoneRequest : (Dap_commands.configurationDone, ConfigurationDoneArguments.t option, RequestMessage.opt) RequestMessage.t -> (Dap_commands.configurationDone, ConfigurationDoneArguments.t option, RequestMessage.opt) request
| LaunchRequest : (Dap_commands.launch, LaunchRequestArguments.t, RequestMessage.req) RequestMessage.t -> (Dap_commands.launch, LaunchRequestArguments.t, RequestMessage.req) request
| AttachRequest : (Dap_commands.attach, AttachRequestArguments.t, RequestMessage.req) RequestMessage.t -> (Dap_commands.attach, AttachRequestArguments.t, RequestMessage.req) request
| RestartRequest : (Dap_commands.restart, RestartArguments.t option, RequestMessage.opt) RequestMessage.t -> (Dap_commands.restart, RestartArguments.t option, RequestMessage.opt) request
| DisconnectRequest : (Dap_commands.disconnect, DisconnectArguments.t option, RequestMessage.opt) RequestMessage.t -> (Dap_commands.disconnect, DisconnectArguments.t option, RequestMessage.opt) request
| TerminateRequest : (Dap_commands.terminate, TerminateArguments.t option, RequestMessage.opt) RequestMessage.t -> (Dap_commands.terminate, TerminateArguments.t option, RequestMessage.opt) request
| BreakpointLocationsRequest : (Dap_commands.breakpointLocations, BreakpointLocationsArguments.t option, RequestMessage.opt) RequestMessage.t -> (Dap_commands.breakpointLocations, BreakpointLocationsArguments.t option, RequestMessage.opt) request
| SetBreakpointsRequest : (Dap_commands.setBreakpoints, SetBreakpointsArguments.t, RequestMessage.req) RequestMessage.t -> (Dap_commands.setBreakpoints, SetBreakpointsArguments.t, RequestMessage.req) request
| SetFunctionBreakpointsRequest : (Dap_commands.setFunctionBreakpoints, SetFunctionBreakpointsArguments.t, RequestMessage.req) RequestMessage.t -> (Dap_commands.setFunctionBreakpoints, SetFunctionBreakpointsArguments.t, RequestMessage.req) request
| SetExceptionBreakpointsRequest : (Dap_commands.setExceptionBreakpoints, SetExceptionBreakpointsArguments.t, RequestMessage.req) RequestMessage.t -> (Dap_commands.setExceptionBreakpoints, SetExceptionBreakpointsArguments.t, RequestMessage.req) request
| DataBreakpointInfoRequest : (Dap_commands.dataBreakpointInfo, DataBreakpointInfoArguments.t, RequestMessage.req) RequestMessage.t -> (Dap_commands.dataBreakpointInfo, DataBreakpointInfoArguments.t, RequestMessage.req) request
| SetDataBreakpointsRequest : (Dap_commands.setDataBreakpoints, SetDataBreakpointsArguments.t, RequestMessage.req) RequestMessage.t -> (Dap_commands.setDataBreakpoints, SetDataBreakpointsArguments.t, RequestMessage.req) request
| SetInstructionBreakpointsRequest : (Dap_commands.setInstructionBreakpoints, SetInstructionBreakpointsArguments.t, RequestMessage.req) RequestMessage.t -> (Dap_commands.setInstructionBreakpoints, SetInstructionBreakpointsArguments.t, RequestMessage.req) request
| ContinueRequest : (Dap_commands.continue, ContinueArguments.t, RequestMessage.req) RequestMessage.t -> (Dap_commands.continue, ContinueArguments.t, RequestMessage.req) request
| NextRequest : (Dap_commands.next, NextArguments.t, RequestMessage.req) RequestMessage.t -> (Dap_commands.next, NextArguments.t, RequestMessage.req) request
| StepInRequest : (Dap_commands.stepIn, StepInArguments.t, RequestMessage.req) RequestMessage.t -> (Dap_commands.stepIn, StepInArguments.t, RequestMessage.req) request
| StepOutRequest : (Dap_commands.stepOut, StepOutArguments.t, RequestMessage.req) RequestMessage.t -> (Dap_commands.stepOut, StepOutArguments.t, RequestMessage.req) request
| StepBackRequest : (Dap_commands.stepBack, StepBackArguments.t, RequestMessage.req) RequestMessage.t -> (Dap_commands.stepBack, StepBackArguments.t, RequestMessage.req) request
| ReverseContinueRequest : (Dap_commands.reverseContinue, ReverseContinueArguments.t, RequestMessage.req) RequestMessage.t -> (Dap_commands.reverseContinue, ReverseContinueArguments.t, RequestMessage.req) request
| RestartFrameRequest : (Dap_commands.restartFrame, RestartFrameArguments.t, RequestMessage.req) RequestMessage.t -> (Dap_commands.restartFrame, RestartFrameArguments.t, RequestMessage.req) request
| GotoRequest : (Dap_commands.goto, GotoArguments.t, RequestMessage.req) RequestMessage.t -> (Dap_commands.goto, GotoArguments.t, RequestMessage.req) request
| PauseRequest : (Dap_commands.pause, PauseArguments.t, RequestMessage.req) RequestMessage.t -> (Dap_commands.pause, PauseArguments.t, RequestMessage.req) request
| StackTraceRequest : (Dap_commands.stackTrace, StackTraceArguments.t, RequestMessage.req) RequestMessage.t -> (Dap_commands.stackTrace, StackTraceArguments.t, RequestMessage.req) request
| ScopesRequest : (Dap_commands.scopes, ScopesArguments.t, RequestMessage.req) RequestMessage.t -> (Dap_commands.scopes, ScopesArguments.t, RequestMessage.req) request
| VariablesRequest : (Dap_commands.variables, VariablesArguments.t, RequestMessage.req) RequestMessage.t -> (Dap_commands.variables, VariablesArguments.t, RequestMessage.req) request
| SetVariableRequest : (Dap_commands.setVariable, SetVariableArguments.t, RequestMessage.req) RequestMessage.t -> (Dap_commands.setVariable, SetVariableArguments.t, RequestMessage.req) request
| SourceRequest : (Dap_commands.source, SourceArguments.t, RequestMessage.req) RequestMessage.t -> (Dap_commands.source, SourceArguments.t, RequestMessage.req) request
| ThreadsRequest : (Dap_commands.threads, EmptyObject.t option, RequestMessage.opt) RequestMessage.t -> (Dap_commands.threads, EmptyObject.t option, RequestMessage.opt) request
| TerminateThreadsRequest : (Dap_commands.terminateThreads, TerminateThreadsArguments.t, RequestMessage.req) RequestMessage.t -> (Dap_commands.terminateThreads, TerminateThreadsArguments.t, RequestMessage.req) request
| ModulesRequest : (Dap_commands.modules, ModulesArguments.t, RequestMessage.req) RequestMessage.t -> (Dap_commands.modules, ModulesArguments.t, RequestMessage.req) request
| LoadedSourcesRequest : (Dap_commands.loadedSources, LoadedSourcesArguments.t option, RequestMessage.opt) RequestMessage.t -> (Dap_commands.loadedSources, LoadedSourcesArguments.t option, RequestMessage.opt) request
| EvaluateRequest : (Dap_commands.evaluate, EvaluateArguments.t, RequestMessage.req) RequestMessage.t -> (Dap_commands.evaluate, EvaluateArguments.t, RequestMessage.req) request
| SetExpressionRequest : (Dap_commands.setExpression, SetExpressionArguments.t, RequestMessage.req) RequestMessage.t -> (Dap_commands.setExpression, SetExpressionArguments.t, RequestMessage.req) request
| StepInTargetsRequest : (Dap_commands.stepInTargets, StepInTargetsArguments.t, RequestMessage.req) RequestMessage.t -> (Dap_commands.stepInTargets, StepInTargetsArguments.t, RequestMessage.req) request
| GotoTargetsRequest : (Dap_commands.gotoTargets, GotoTargetsArguments.t, RequestMessage.req) RequestMessage.t -> (Dap_commands.gotoTargets, GotoTargetsArguments.t, RequestMessage.req) request
| CompletionsRequest : (Dap_commands.completions, CompletionsArguments.t, RequestMessage.req) RequestMessage.t -> (Dap_commands.completions, CompletionsArguments.t, RequestMessage.req) request
| ExceptionInfoRequest : (Dap_commands.exceptionInfo, ExceptionInfoArguments.t, RequestMessage.req) RequestMessage.t -> (Dap_commands.exceptionInfo, ExceptionInfoArguments.t, RequestMessage.req) request
| ReadMemoryRequest : (Dap_commands.readMemory, ReadMemoryArguments.t, RequestMessage.req) RequestMessage.t -> (Dap_commands.readMemory, ReadMemoryArguments.t, RequestMessage.req) request
| WriteMemoryRequest : (Dap_commands.writeMemory, WriteMemoryArguments.t, RequestMessage.req) RequestMessage.t -> (Dap_commands.writeMemory, WriteMemoryArguments.t, RequestMessage.req) request
| DisassembleRequest : (Dap_commands.disassemble, DisassembleArguments.t, RequestMessage.req) RequestMessage.t -> (Dap_commands.disassemble, DisassembleArguments.t, RequestMessage.req) request

 type (_,_,_) response = 
| ErrorResponse : (Dap_commands.error, ErrorResponse_body.t, ResponseMessage.req) ResponseMessage.t -> (Dap_commands.error, ErrorResponse_body.t, ResponseMessage.req) response
| CancelResponse : (Dap_commands.cancel, EmptyObject.t option, ResponseMessage.opt) ResponseMessage.t -> (Dap_commands.cancel, EmptyObject.t option, ResponseMessage.opt) response
| RunInTerminalResponse : (Dap_commands.runInTerminal, RunInTerminalResponse_body.t, ResponseMessage.req) ResponseMessage.t -> (Dap_commands.runInTerminal, RunInTerminalResponse_body.t, ResponseMessage.req) response
| InitializeResponse : (Dap_commands.initialize, Capabilities.t option, ResponseMessage.opt) ResponseMessage.t -> (Dap_commands.initialize, Capabilities.t option, ResponseMessage.opt) response
| ConfigurationDoneResponse : (Dap_commands.configurationDone, EmptyObject.t option, ResponseMessage.opt) ResponseMessage.t -> (Dap_commands.configurationDone, EmptyObject.t option, ResponseMessage.opt) response
| LaunchResponse : (Dap_commands.launch, EmptyObject.t option, ResponseMessage.opt) ResponseMessage.t -> (Dap_commands.launch, EmptyObject.t option, ResponseMessage.opt) response
| AttachResponse : (Dap_commands.attach, EmptyObject.t option, ResponseMessage.opt) ResponseMessage.t -> (Dap_commands.attach, EmptyObject.t option, ResponseMessage.opt) response
| RestartResponse : (Dap_commands.restart, EmptyObject.t option, ResponseMessage.opt) ResponseMessage.t -> (Dap_commands.restart, EmptyObject.t option, ResponseMessage.opt) response
| DisconnectResponse : (Dap_commands.disconnect, EmptyObject.t option, ResponseMessage.opt) ResponseMessage.t -> (Dap_commands.disconnect, EmptyObject.t option, ResponseMessage.opt) response
| TerminateResponse : (Dap_commands.terminate, EmptyObject.t option, ResponseMessage.opt) ResponseMessage.t -> (Dap_commands.terminate, EmptyObject.t option, ResponseMessage.opt) response
| BreakpointLocationsResponse : (Dap_commands.breakpointLocations, BreakpointLocationsResponse_body.t, ResponseMessage.req) ResponseMessage.t -> (Dap_commands.breakpointLocations, BreakpointLocationsResponse_body.t, ResponseMessage.req) response
| SetBreakpointsResponse : (Dap_commands.setBreakpoints, SetBreakpointsResponse_body.t, ResponseMessage.req) ResponseMessage.t -> (Dap_commands.setBreakpoints, SetBreakpointsResponse_body.t, ResponseMessage.req) response
| SetFunctionBreakpointsResponse : (Dap_commands.setFunctionBreakpoints, SetFunctionBreakpointsResponse_body.t, ResponseMessage.req) ResponseMessage.t -> (Dap_commands.setFunctionBreakpoints, SetFunctionBreakpointsResponse_body.t, ResponseMessage.req) response
| SetExceptionBreakpointsResponse : (Dap_commands.setExceptionBreakpoints, SetExceptionBreakpointsResponse_body.t option, ResponseMessage.opt) ResponseMessage.t -> (Dap_commands.setExceptionBreakpoints, SetExceptionBreakpointsResponse_body.t option, ResponseMessage.opt) response
| DataBreakpointInfoResponse : (Dap_commands.dataBreakpointInfo, DataBreakpointInfoResponse_body.t, ResponseMessage.req) ResponseMessage.t -> (Dap_commands.dataBreakpointInfo, DataBreakpointInfoResponse_body.t, ResponseMessage.req) response
| SetDataBreakpointsResponse : (Dap_commands.setDataBreakpoints, SetDataBreakpointsResponse_body.t, ResponseMessage.req) ResponseMessage.t -> (Dap_commands.setDataBreakpoints, SetDataBreakpointsResponse_body.t, ResponseMessage.req) response
| SetInstructionBreakpointsResponse : (Dap_commands.setInstructionBreakpoints, SetInstructionBreakpointsResponse_body.t, ResponseMessage.req) ResponseMessage.t -> (Dap_commands.setInstructionBreakpoints, SetInstructionBreakpointsResponse_body.t, ResponseMessage.req) response
| ContinueResponse : (Dap_commands.continue, ContinueResponse_body.t, ResponseMessage.req) ResponseMessage.t -> (Dap_commands.continue, ContinueResponse_body.t, ResponseMessage.req) response
| NextResponse : (Dap_commands.next, EmptyObject.t option, ResponseMessage.opt) ResponseMessage.t -> (Dap_commands.next, EmptyObject.t option, ResponseMessage.opt) response
| StepInResponse : (Dap_commands.stepIn, EmptyObject.t option, ResponseMessage.opt) ResponseMessage.t -> (Dap_commands.stepIn, EmptyObject.t option, ResponseMessage.opt) response
| StepOutResponse : (Dap_commands.stepOut, EmptyObject.t option, ResponseMessage.opt) ResponseMessage.t -> (Dap_commands.stepOut, EmptyObject.t option, ResponseMessage.opt) response
| StepBackResponse : (Dap_commands.stepBack, EmptyObject.t option, ResponseMessage.opt) ResponseMessage.t -> (Dap_commands.stepBack, EmptyObject.t option, ResponseMessage.opt) response
| ReverseContinueResponse : (Dap_commands.reverseContinue, EmptyObject.t option, ResponseMessage.opt) ResponseMessage.t -> (Dap_commands.reverseContinue, EmptyObject.t option, ResponseMessage.opt) response
| RestartFrameResponse : (Dap_commands.restartFrame, EmptyObject.t option, ResponseMessage.opt) ResponseMessage.t -> (Dap_commands.restartFrame, EmptyObject.t option, ResponseMessage.opt) response
| GotoResponse : (Dap_commands.goto, EmptyObject.t option, ResponseMessage.opt) ResponseMessage.t -> (Dap_commands.goto, EmptyObject.t option, ResponseMessage.opt) response
| PauseResponse : (Dap_commands.pause, EmptyObject.t option, ResponseMessage.opt) ResponseMessage.t -> (Dap_commands.pause, EmptyObject.t option, ResponseMessage.opt) response
| StackTraceResponse : (Dap_commands.stackTrace, StackTraceResponse_body.t, ResponseMessage.req) ResponseMessage.t -> (Dap_commands.stackTrace, StackTraceResponse_body.t, ResponseMessage.req) response
| ScopesResponse : (Dap_commands.scopes, ScopesResponse_body.t, ResponseMessage.req) ResponseMessage.t -> (Dap_commands.scopes, ScopesResponse_body.t, ResponseMessage.req) response
| VariablesResponse : (Dap_commands.variables, VariablesResponse_body.t, ResponseMessage.req) ResponseMessage.t -> (Dap_commands.variables, VariablesResponse_body.t, ResponseMessage.req) response
| SetVariableResponse : (Dap_commands.setVariable, SetVariableResponse_body.t, ResponseMessage.req) ResponseMessage.t -> (Dap_commands.setVariable, SetVariableResponse_body.t, ResponseMessage.req) response
| SourceResponse : (Dap_commands.source, SourceResponse_body.t, ResponseMessage.req) ResponseMessage.t -> (Dap_commands.source, SourceResponse_body.t, ResponseMessage.req) response
| ThreadsResponse : (Dap_commands.threads, ThreadsResponse_body.t, ResponseMessage.req) ResponseMessage.t -> (Dap_commands.threads, ThreadsResponse_body.t, ResponseMessage.req) response
| TerminateThreadsResponse : (Dap_commands.terminateThreads, EmptyObject.t option, ResponseMessage.opt) ResponseMessage.t -> (Dap_commands.terminateThreads, EmptyObject.t option, ResponseMessage.opt) response
| ModulesResponse : (Dap_commands.modules, ModulesResponse_body.t, ResponseMessage.req) ResponseMessage.t -> (Dap_commands.modules, ModulesResponse_body.t, ResponseMessage.req) response
| LoadedSourcesResponse : (Dap_commands.loadedSources, LoadedSourcesResponse_body.t, ResponseMessage.req) ResponseMessage.t -> (Dap_commands.loadedSources, LoadedSourcesResponse_body.t, ResponseMessage.req) response
| EvaluateResponse : (Dap_commands.evaluate, EvaluateResponse_body.t, ResponseMessage.req) ResponseMessage.t -> (Dap_commands.evaluate, EvaluateResponse_body.t, ResponseMessage.req) response
| SetExpressionResponse : (Dap_commands.setExpression, SetExpressionResponse_body.t, ResponseMessage.req) ResponseMessage.t -> (Dap_commands.setExpression, SetExpressionResponse_body.t, ResponseMessage.req) response
| StepInTargetsResponse : (Dap_commands.stepInTargets, StepInTargetsResponse_body.t, ResponseMessage.req) ResponseMessage.t -> (Dap_commands.stepInTargets, StepInTargetsResponse_body.t, ResponseMessage.req) response
| GotoTargetsResponse : (Dap_commands.gotoTargets, GotoTargetsResponse_body.t, ResponseMessage.req) ResponseMessage.t -> (Dap_commands.gotoTargets, GotoTargetsResponse_body.t, ResponseMessage.req) response
| CompletionsResponse : (Dap_commands.completions, CompletionsResponse_body.t, ResponseMessage.req) ResponseMessage.t -> (Dap_commands.completions, CompletionsResponse_body.t, ResponseMessage.req) response
| ExceptionInfoResponse : (Dap_commands.exceptionInfo, ExceptionInfoResponse_body.t, ResponseMessage.req) ResponseMessage.t -> (Dap_commands.exceptionInfo, ExceptionInfoResponse_body.t, ResponseMessage.req) response
| ReadMemoryResponse : (Dap_commands.readMemory, ReadMemoryResponse_body.t option, ResponseMessage.opt) ResponseMessage.t -> (Dap_commands.readMemory, ReadMemoryResponse_body.t option, ResponseMessage.opt) response
| WriteMemoryResponse : (Dap_commands.writeMemory, WriteMemoryResponse_body.t option, ResponseMessage.opt) ResponseMessage.t -> (Dap_commands.writeMemory, WriteMemoryResponse_body.t option, ResponseMessage.opt) response
| DisassembleResponse : (Dap_commands.disassemble, DisassembleResponse_body.t option, ResponseMessage.opt) ResponseMessage.t -> (Dap_commands.disassemble, DisassembleResponse_body.t option, ResponseMessage.opt) response

 type (_,_,_) event = 
| InitializedEvent : (Dap_events.initialized, EmptyObject.t option, EventMessage.opt) EventMessage.t -> (Dap_events.initialized, EmptyObject.t option, EventMessage.opt) event
| StoppedEvent : (Dap_events.stopped, StoppedEvent_body.t, EventMessage.req) EventMessage.t -> (Dap_events.stopped, StoppedEvent_body.t, EventMessage.req) event
| ContinuedEvent : (Dap_events.continued, ContinuedEvent_body.t, EventMessage.req) EventMessage.t -> (Dap_events.continued, ContinuedEvent_body.t, EventMessage.req) event
| ExitedEvent : (Dap_events.exited, ExitedEvent_body.t, EventMessage.req) EventMessage.t -> (Dap_events.exited, ExitedEvent_body.t, EventMessage.req) event
| TerminatedEvent : (Dap_events.terminated, TerminatedEvent_body.t option, EventMessage.opt) EventMessage.t -> (Dap_events.terminated, TerminatedEvent_body.t option, EventMessage.opt) event
| ThreadEvent : (Dap_events.thread, ThreadEvent_body.t, EventMessage.req) EventMessage.t -> (Dap_events.thread, ThreadEvent_body.t, EventMessage.req) event
| OutputEvent : (Dap_events.output, OutputEvent_body.t, EventMessage.req) EventMessage.t -> (Dap_events.output, OutputEvent_body.t, EventMessage.req) event
| BreakpointEvent : (Dap_events.breakpoint, BreakpointEvent_body.t, EventMessage.req) EventMessage.t -> (Dap_events.breakpoint, BreakpointEvent_body.t, EventMessage.req) event
| ModuleEvent : (Dap_events.module_, ModuleEvent_body.t, EventMessage.req) EventMessage.t -> (Dap_events.module_, ModuleEvent_body.t, EventMessage.req) event
| LoadedSourceEvent : (Dap_events.loadedSource, LoadedSourceEvent_body.t, EventMessage.req) EventMessage.t -> (Dap_events.loadedSource, LoadedSourceEvent_body.t, EventMessage.req) event
| ProcessEvent : (Dap_events.process, ProcessEvent_body.t, EventMessage.req) EventMessage.t -> (Dap_events.process, ProcessEvent_body.t, EventMessage.req) event
| CapabilitiesEvent : (Dap_events.capabilities, CapabilitiesEvent_body.t, EventMessage.req) EventMessage.t -> (Dap_events.capabilities, CapabilitiesEvent_body.t, EventMessage.req) event
| ProgressStartEvent : (Dap_events.progressStart, ProgressStartEvent_body.t, EventMessage.req) EventMessage.t -> (Dap_events.progressStart, ProgressStartEvent_body.t, EventMessage.req) event
| ProgressUpdateEvent : (Dap_events.progressUpdate, ProgressUpdateEvent_body.t, EventMessage.req) EventMessage.t -> (Dap_events.progressUpdate, ProgressUpdateEvent_body.t, EventMessage.req) event
| ProgressEndEvent : (Dap_events.progressEnd, ProgressEndEvent_body.t, EventMessage.req) EventMessage.t -> (Dap_events.progressEnd, ProgressEndEvent_body.t, EventMessage.req) event
| InvalidatedEvent : (Dap_events.invalidated, InvalidatedEvent_body.t, EventMessage.req) EventMessage.t -> (Dap_events.invalidated, InvalidatedEvent_body.t, EventMessage.req) event
| MemoryEvent : (Dap_events.memory, MemoryEvent_body.t, EventMessage.req) EventMessage.t -> (Dap_events.memory, MemoryEvent_body.t, EventMessage.req) event

